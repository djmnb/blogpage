<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>k8s</title>
      <link href="/2022/12/19/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s-2/"/>
      <url>/2022/12/19/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s-2/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><strong>传统部署时代：</strong> 早期,是直接将应用程序部署在物理机上，无法对应用程序进行资源限制,如果有多个应用,就会出现资源分配的问题,比如一个应用占据大量资源,使用其他应用性能下降,一种解决方案是单个应用放在单个服务器上,这样的话,虽然做到了资源隔离,但是如果一个应用程序资源利用率不高的时候,剩余的资源又无法分配各其他应用程序,而且物理服务器的维护成本变得很高。</p><p><strong>虚拟化部署时代：</strong> 作为解决方案，引入了虚拟化功能，它允许您在单个物理服务器的 CPU 上运行多个虚拟机VM。虚拟化功能允许应用程序在 VM 之间隔离，并提供安全级别，因为一个应用程序的信息不能被另一应用程序自由地访问。</p><p><strong>容器部署时代：</strong> 容器类似于 VM，但是它们具有轻量级的隔离属性，可以在应用程序之间共享操作系统OS。因此，容器被认为是目前最轻量级的。容器与 VM 类似，具有自己的文件系统、CPU、内存、进程空间等。由于它们与基础架构分离，因此可以跨云和 OS 分发进行移植。而在容器时代，Docker容器引擎是最流行的一个。</p><p>Kubernetes 为你提供了一个<strong>可弹性运行分布式系统</strong>的框架。 Kubernetes 会满足你的<strong>扩展要求、故障转移你的应用、提供部署模式</strong>等</p><p>k8s提供的功能有:</p><ul><li><strong>服务发现和负载均衡</strong>   使用ip或者dns名称暴露容器ip,让service发现,当service流量过大的时候,会负载均衡到这些容器中</li><li><strong>存储编排</strong>  允许自动挂载选择的存储系统</li><li><strong>自动部署和回滚</strong>   通过更改期望状态,就能够实现容器的自动部署和历史版本回滚</li><li><strong>自动完成装箱计算</strong> 在用户提供了容器需要的资源的基础上,k8s根据容器实际情况分配资源,以最佳方式利用资源</li><li><strong>自我修复</strong>  k8s 可以重新启动失败的容器,或者替换容器,或者杀死不响应的容器</li><li><strong>秘钥和配置管理</strong> Kubernetes 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。 你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥</li></ul><h1 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h1><h2 id="APIServer"><a href="#APIServer" class="headerlink" title="APIServer"></a>APIServer</h2><p>系统管理指令的统一入口,担负着统揽全局的重任,任何对资源的增删改查都得交给它后才能交给etcd</p><p>功能:</p><ul><li>对外提供restful的管理接口,方便对资源对象的增删改查</li><li>配置k8s资源对象,将资源对象的当前状态与期望状态存储在etcd中,供其他组件使用,除了etcd,k8s没有其他的持久化结点</li><li>系统日志收集,并且提供api供访问</li></ul><h2 id="scheduler"><a href="#scheduler" class="headerlink" title="scheduler"></a>scheduler</h2><p>在可用的工作结点列表通过算法选取一个结点与待调度的pod进行绑定</p><p>调度算法:</p><p>首先经历一系列的Predicates判断这个pod能不能在我这个结点上运行,下面列举在default算法中可用的Predicates</p><ul><li>PodFitsHostPorts: 查看pod容器需要用的宿主机端口是否有冲突</li><li>podFitsResources: 检查结点上的资源是否够用,就是检测结点已有pod对资源的需求量+待调度的pod资源需求量 是否超过工作结点的容量</li><li>NoDiskConfict: 检查容器挂在的卷是否有冲突,只对特定的容器卷有效,因为这些容器卷有它们自己的挂载规则,比如禁止两个pod共享同一个容器卷</li><li>NoVolumeZoneConfict: 检查pod的挂载卷的zone限制是否与node对应的zone-lable相匹配</li><li>MatchNodeSelector: 检查工作结点的lables属性是否和pod的标签选择器是否一致</li><li>hostname: 如果在pod中指定了宿主机,那么将会调度他到指定的宿主机结点上运行</li></ul><p>经历了上述硬性筛选之后,顺利过关的工作结点就会来到打分流程,下面列举打分策略:</p><ul><li>LeastRequestedPriority: 计算原则是尽可能的将pod调度到资源占用比小的结点上</li><li>BalanceResourceAllocation: 调度时尽可能选取cpu和内存利用率相近的结点</li><li>SelectorSpreadPriority: 对于相同的service的pod在节点上尽可能的分散</li><li>NodeAffinityPriority: 根据用户指定pod的工作结点亲和性进行打分</li><li>ImageLocalityPriorite: 根据pod需要的镜像进行打分,pod需要的镜像大小和越大(pod可以运行多个容器),打分越高</li></ul><p>最后计算加权和,看哪个工作结点分高</p><h2 id="controller-manager"><a href="#controller-manager" class="headerlink" title="controller manager"></a>controller manager</h2><p>管理k8s中的各种控制器,确保这些资源永远保持在用户所预期的状态</p><p>controller manager 控制pod与工作结点等资源正常运行的本质,就是靠这些控制器定时对pod,工作结点等资源进行检查,然后判断实际状态是否与期望状态一直,不一致的话则会通知apiserver进行增删改.</p><p>服务端点控制: **检测pod与service之间的对应关系是否正常,**保证始终运行在用户所期望的状态</p><p>副本管理控制器:  保证实际副本数量与期望数量一致</p><p>垃圾回收控制器: 删除处于终止状态pod的信息,不是删除容器哦</p><p>结点控制器: 检查工作结点是否可用,工作结点通过kubelet定时发送数据给master结点,如果在一段时间内没有发送,则认为工作结点不可以工作</p><p>资源配额控制器:  对一个namespace 的资源进行配置</p><h2 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h2><p>kubelet是工作结点中最重要的进程,负责创建和管理容器,还有容器和镜像的垃圾回收</p><h2 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h2><p>实现服务发现与负载均衡,在后端pod的ip发生变化的时候,也能察觉到,并且维护着service与pod之间的对应关系,将发往service的流量正确的导向pod</p><h2 id="核心组件协作流程"><a href="#核心组件协作流程" class="headerlink" title="核心组件协作流程"></a>核心组件协作流程</h2><h3 id="创建pod"><a href="#创建pod" class="headerlink" title="创建pod"></a>创建pod</h3><p>我们通过kubectl发起一个创建pod的请求后,kubectl会先检查命令是否正确,然后解析命令生成的pod资源文件发送给apiserver,apiserver收到请求后,进行用户认证,授权,和资源配额控制,验证通过后,apiserver调用etcd的存储接口在后台数据库创建一个pod对象,scheduler定期从etcd获取可用工作结点列表和待调度的pod,在发现有待调度的pod且有工作结点的时候,会通过筛选结点,给结点打分,选出最优结点,然后调用apiserver提供的api在etcd中创建一个binding对象,描述在一个工作结点绑定运行的所有pod信息,kubelet监听到apiserver上要创建pod,然后在本地创建对应的pod</p><h1 id="基础环境部署"><a href="#基础环境部署" class="headerlink" title="基础环境部署"></a>基础环境部署</h1><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>用了三台虚拟机,都是centos7 </p><p>192.168.100.3  master结点</p><p>192.168.100.4  work1结点</p><p>192.168.100.5  work2结点</p><h3 id="修改hostname"><a href="#修改hostname" class="headerlink" title="修改hostname"></a>修改hostname</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">master上执行</span></span><br><span class="line">hostnamectl set-hostname master</span><br><span class="line">exec bash</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">work1 上执行</span></span><br><span class="line">hostnamectl set-hostname work1</span><br><span class="line">exec bash</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">work2 上执行</span></span><br><span class="line">hostnamectl set-hostname work2</span><br></pre></td></tr></table></figure><h3 id="配置hosts文件-所有结点"><a href="#配置hosts文件-所有结点" class="headerlink" title="配置hosts文件(所有结点)"></a>配置hosts文件(所有结点)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">两台机器都执行</span></span><br><span class="line">cat &gt;&gt; /etc/hosts &lt;&lt; EOF</span><br><span class="line">192.168.100.3  master</span><br><span class="line">192.168.100.4  work1</span><br><span class="line">192.168.100.5  work2</span><br><span class="line">192.168.100.3  cluster-endpoint</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h3 id="配置ssh互信-所有结点"><a href="#配置ssh互信-所有结点" class="headerlink" title="配置ssh互信(所有结点)"></a>配置ssh互信(所有结点)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">所有机器都执行</span></span><br><span class="line">ssh-keygen</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一直回车得到秘钥</span></span><br><span class="line"></span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub root@master</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub root@work1</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub root@work2</span><br></pre></td></tr></table></figure><h3 id="设置时间同步-所有结点"><a href="#设置时间同步-所有结点" class="headerlink" title="设置时间同步(所有结点)"></a>设置时间同步(所有结点)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum install chrony -y</span><br><span class="line">systemctl start chronyd</span><br><span class="line">systemctl enable chronyd</span><br><span class="line">chronyc sources</span><br></pre></td></tr></table></figure><h3 id="关闭防火墙-所有结点"><a href="#关闭防火墙-所有结点" class="headerlink" title="关闭防火墙(所有结点)"></a>关闭防火墙(所有结点)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure><h3 id="关闭交换区-所有结点"><a href="#关闭交换区-所有结点" class="headerlink" title="关闭交换区(所有结点)"></a>关闭交换区(所有结点)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">swapoff -a</span><br><span class="line">sed -ri &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab</span><br></pre></td></tr></table></figure><h3 id="禁用seninux-所有结点"><a href="#禁用seninux-所有结点" class="headerlink" title="禁用seninux(所有结点)"></a>禁用seninux(所有结点)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setenforce 0</span><br><span class="line">sed -i &#x27;s/^SELINUX=enforcing$/SELINUX=disabled/&#x27; /etc/selinux/config</span><br></pre></td></tr></table></figure><h3 id="允许-iptables-检查桥接流量-所有结点"><a href="#允许-iptables-检查桥接流量-所有结点" class="headerlink" title="允许 iptables 检查桥接流量(所有结点)"></a>允许 iptables 检查桥接流量(所有结点)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">modprobe br_netfilter</span><br><span class="line"></span><br><span class="line">cat &lt;&lt;EOF | sudo tee /etc/modules-load.d/k8s.conf</span><br><span class="line">overlay</span><br><span class="line">br_netfilter</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">modprobe overlay</span><br><span class="line">modprobe br_netfilter</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置所需的 sysctl 参数，参数在重新启动后保持不变</span></span><br><span class="line">cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-iptables  = 1</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.ipv4.ip_forward                 = 1</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">应用 sysctl 参数而不重新启动</span></span><br><span class="line">sudo sysctl --system</span><br></pre></td></tr></table></figure><h3 id="安装docker-所有结点"><a href="#安装docker-所有结点" class="headerlink" title="安装docker(所有结点)"></a>安装docker(所有结点)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置yum源</span></span><br><span class="line">cd /etc/yum.repos.d ; mkdir bak; mv CentOS-Base.repo bak/</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-8.repo (这个是centos8的源)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装yum-config-manager配置工具</span></span><br><span class="line">yum -y install yum-utils</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置yum源</span></span><br><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装docker-ce版本</span></span><br><span class="line">yum install -y docker-ce</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开机自启</span></span><br><span class="line">systemctl enable docker</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看版本号</span></span><br><span class="line">docker --version</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Docker镜像源设置</span></span><br><span class="line">cat &gt;/etc/docker/daemon.json&lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">   &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载</span></span><br><span class="line">systemctl reload docker</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="配置k8s源-所有结点"><a href="#配置k8s源-所有结点" class="headerlink" title="配置k8s源(所有结点)"></a>配置k8s源(所有结点)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF</span><br><span class="line">[k8s]</span><br><span class="line">name=k8s</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h3 id="将-sandbox-image-镜像源设置为阿里云-google-containers-镜像源-一条一条命令来哦-所有结点"><a href="#将-sandbox-image-镜像源设置为阿里云-google-containers-镜像源-一条一条命令来哦-所有结点" class="headerlink" title="将 sandbox_image 镜像源设置为阿里云 google_containers 镜像源(一条一条命令来哦)(所有结点)"></a>将 sandbox_image 镜像源设置为阿里云 google_containers 镜像源(一条一条命令来哦)(所有结点)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">导出默认配置，config.toml这个文件默认是不存在的</span></span><br><span class="line">containerd config default &gt; /etc/containerd/config.toml</span><br><span class="line">grep sandbox_image  /etc/containerd/config.toml</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把 sandbox_image = <span class="string">&quot;registry.k8s.io/pause:3.6&quot;</span>(不同版本对应的可能不同)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">改成 sandbox_image = <span class="string">&quot;registry.aliyuncs.com/google_containers/pause/pause:3.6&quot;</span></span></span><br><span class="line">sed -i &quot;s#registry.k8s.io/pause#registry.aliyuncs.com/google_containers/pause#g&quot;   /etc/containerd/config.toml</span><br><span class="line">grep sandbox_image  /etc/containerd/config.toml</span><br></pre></td></tr></table></figure><p><img src="/2022/12/19/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s-2/../img/k8s-2assets/image-20221211155339486.png" alt="image-20221211155339486"></p><h3 id="配置container国内镜像源"><a href="#配置container国内镜像源" class="headerlink" title="配置container国内镜像源"></a>配置container国内镜像源</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 打开配置文件</span><br><span class="line">vim /etc/containerd/config.toml </span><br><span class="line"></span><br><span class="line"># 改成下面这种格式</span><br><span class="line"> [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors]</span><br><span class="line">      [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors.&quot;docker.io&quot;]</span><br><span class="line">         endpoint = [&quot;https://o13jbvy6.mirror.aliyuncs.com&quot;]</span><br><span class="line"></span><br><span class="line"># 重启containerd</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart containerd</span><br><span class="line">systemctl status containerd</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/12/19/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s-2/../img/k8s-2assets/image-20221212204732132.png" alt="image-20221212204732132"></p><p>得一层一层来,<a href="https://blog.csdn.net/cyxinda/article/details/124999938">https://blog.csdn.net/cyxinda/article/details/124999938</a> (可以参考这个博客)</p><h3 id="配置-containerd-cgroup-驱动程序-systemd-所有结点"><a href="#配置-containerd-cgroup-驱动程序-systemd-所有结点" class="headerlink" title="配置 containerd cgroup 驱动程序 systemd(所有结点)"></a>配置 containerd cgroup 驱动程序 systemd(所有结点)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;s#SystemdCgroup = false#SystemdCgroup = true#g&#x27; /etc/containerd/config.toml</span><br><span class="line">systemctl restart containerd</span><br></pre></td></tr></table></figure><h3 id="安装-kubeadm，kubelet-和-kubectl-所有结点"><a href="#安装-kubeadm，kubelet-和-kubectl-所有结点" class="headerlink" title="安装 kubeadm，kubelet 和 kubectl(所有结点)"></a>安装 kubeadm，kubelet 和 kubectl(所有结点)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不指定版本就是最新版本，当前最新版就是1.24.1</span></span><br><span class="line">yum install -y kubelet-1.24.1  kubeadm-1.24.1  kubectl-1.24.1 --disableexcludes=kubernetes</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">disableexcludes=kubernetes：禁掉除了这个kubernetes之外的别的仓库</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置为开机自启并现在立刻启动服务 --now：立刻启动服务</span></span><br><span class="line">systemctl enable --now kubelet</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看状态，这里需要等待一段时间再查看服务状态，启动会有点慢</span></span><br><span class="line">systemctl status kubelet</span><br></pre></td></tr></table></figure><h3 id="使用kubeadm初始化集群-master"><a href="#使用kubeadm初始化集群-master" class="headerlink" title="使用kubeadm初始化集群(master)"></a>使用kubeadm初始化集群(master)</h3><p>下载好镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry.aliyuncs.com/google_containers/kube-apiserver:v1.24.1</span><br><span class="line">docker pull registry.aliyuncs.com/google_containers/kube-controller-manager:v1.24.1</span><br><span class="line">docker pull registry.aliyuncs.com/google_containers/kube-scheduler:v1.24.1</span><br><span class="line">docker pull registry.aliyuncs.com/google_containers/kube-proxy:v1.24.1</span><br><span class="line">docker pull registry.aliyuncs.com/google_containers/pause:3.7</span><br><span class="line">docker pull registry.aliyuncs.com/google_containers/etcd:3.5.3-0</span><br><span class="line">docker pull registry.aliyuncs.com/google_containers/coredns:v1.8.6</span><br></pre></td></tr></table></figure><p>设置kubectl 自动补全</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">来到家目录</span></span><br><span class="line">cd ~</span><br><span class="line">echo &#x27;source &lt;(kubectl completion bash)&#x27; &gt;&gt;~/.bashrc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新加载bash</span></span><br><span class="line">exec bash</span><br></pre></td></tr></table></figure><p>初始化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init \</span><br><span class="line">  --apiserver-advertise-address=192.168.100.3 \</span><br><span class="line">  --image-repository registry.aliyuncs.com/google_containers \</span><br><span class="line">  --control-plane-endpoint=cluster-endpoint \</span><br><span class="line">  --kubernetes-version v1.24.1 \</span><br><span class="line">  --service-cidr=10.1.0.0/16 \</span><br><span class="line">  --pod-network-cidr=10.244.0.0/16 \</span><br><span class="line">  --v=5</span><br><span class="line">  </span><br><span class="line"><span class="meta prompt_"> # </span><span class="language-bash">–image-repository string：    这个用于指定从什么位置来拉取镜像（1.13版本才有的），默认值是k8s.gcr.io，我们将其指定为国内镜像地址：registry.aliyuncs.com/google_containers</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">–kubernetes-version string：  指定kubenets版本号，默认值是stable-1，会导致从https://dl.k8s.io/release/stable-1.txt下载最新的版本号，我们可以将其指定为固定版本（v1.22.1）来跳过网络请求。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">–apiserver-advertise-address  指明用 Master 的哪个 interface 与 Cluster 的其他节点通信。如果 Master 有多个 interface，建议明确指定，如果不指定，kubeadm 会自动选择有默认网关的 interface。这里的ip为master节点ip，记得更换。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">–pod-network-cidr             指定 Pod 网络的范围。Kubernetes 支持多种网络方案，而且不同网络方案对  –pod-network-cidr有自己的要求，这里设置为10.244.0.0/16 是因为我们将使用 flannel 网络方案，必须设置成这个 CIDR。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--control-plane-endpoint     cluster-endpoint 是映射到该 IP 的自定义 DNS 名称，这里配置hosts映射：192.168.0.113   cluster-endpoint。 这将允许你将 --control-plane-endpoint=cluster-endpoint 传递给 kubeadm init，并将相同的 DNS 名称传递给 kubeadm <span class="built_in">join</span>。 稍后你可以修改 cluster-endpoint 以指向高可用性方案中的负载均衡器的地址。</span></span><br></pre></td></tr></table></figure><p>执行提示出来的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure><p>此时master结点还是notready的状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes </span><br></pre></td></tr></table></figure><p><img src="/2022/12/19/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s-2/../img/k8s-2assets/image-20221211162528752.png" alt="image-20221211162528752"></p><p>需要安装一个网络插件</p><h3 id="安装网络插件-master结点"><a href="#安装网络插件-master结点" class="headerlink" title="安装网络插件(master结点)"></a>安装网络插件(master结点)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#提前下载好镜像</span><br><span class="line">docker pull quay.io/coreos/flannel:v0.14.0</span><br><span class="line"># 这里可能不成功,最好是下载好这个文件然后上传到虚拟机,在执行这个命令</span><br><span class="line">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有pod的状态</span><br><span class="line">kubectl get pods -A </span><br></pre></td></tr></table></figure><p>当所有pod都在running的时候,主节点就准备好了</p><p><img src="/2022/12/19/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s-2/../img/k8s-2assets/image-20221211163314011.png" alt="image-20221211163314011"></p><h3 id="work结点加入集群"><a href="#work结点加入集群" class="headerlink" title="work结点加入集群"></a>work结点加入集群</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在master结点上面执行下面命令得到加入主节点的命令</span><br><span class="line">kubeadm token create --print-join-command</span><br></pre></td></tr></table></figure><p><img src="/2022/12/19/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s-2/../img/k8s-2assets/image-20221211163647701.png" alt="image-20221211163647701"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#在work1结点中输入这个命令</span><br><span class="line">kubeadm join cluster-endpoint:6443 --token 6z9ttd.gi5caxzuargatfy9 --discovery-token-ca-cert-hash sha256:05c589ead7b690359fc1a6208be07390ce40894939c29d025e04477442bfc4d8 </span><br></pre></td></tr></table></figure><p>等待一段时间后,在主节点中查看所有结点是否都准备好了</p><p><img src="/2022/12/19/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s-2/../img/k8s-2assets/image-20221211164817076.png" alt="image-20221211164817076"></p><h2 id="安装dashboard"><a href="#安装dashboard" class="headerlink" title="安装dashboard"></a>安装dashboard</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.6.0/aio/deploy/recommended.yaml</span><br><span class="line"># 可能会下载不下来,建议本地用梯子下载好后,传到虚拟机上</span><br></pre></td></tr></table></figure><p><img src="/2022/12/19/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s-2/../img/k8s-2assets/image-20221211172019706.png" alt="image-20221211172019706"></p><p><img src="/2022/12/19/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s-2/../img/k8s-2assets/image-20221213092810050.png" alt="image-20221213092810050"></p><p>需要等到kubernetes-dashboard的所有pod都在running后才能访问哦,有可能会出现镜像拉取失败</p><p>通过端口访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">kubectl edit svc kubernetes-dashboard -n kubernetes-dashboard</span><br><span class="line">#上面命令会打开一个文件,我们需要修改一些配置</span><br><span class="line"># 输入 /type 搜索到目标位置</span><br><span class="line"></span><br><span class="line">#   type: ClusterIP   将这个东西变成</span><br><span class="line">#   type: NodePort   </span><br><span class="line">#  要注意yaml的语法哦,空格</span><br><span class="line"># 然后保存退出</span><br><span class="line"></span><br><span class="line"># 看dashboard 运行在哪个端口</span><br><span class="line">kubectl get svc -A |grep kubernetes-dashboard </span><br></pre></td></tr></table></figure><blockquote><p>如果在Google浏览器里面输入 <a href="https://ip:端口显示不安全,而且不让进去的话,就在键盘直接输入">https://ip:端口显示不安全,而且不让进去的话,就在键盘直接输入</a> thisisunsafe 然后就可以进去了</p></blockquote><p><img src="/2022/12/19/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s-2/../img/k8s-2assets/image-20221211171537087.png" alt="image-20221211171537087"></p><h4 id="创建账户"><a href="#创建账户" class="headerlink" title="创建账户"></a>创建账户</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;ServiceAccount.yaml&lt;&lt;EOF</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: admin-user</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: admin-user</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: admin-user</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line">EOF</span><br><span class="line">kubectl apply -f ServiceAccount.yaml</span><br></pre></td></tr></table></figure><h4 id="获取token"><a href="#获取token" class="headerlink" title="获取token"></a>获取token</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n kubernetes-dashboard create token admin-user</span><br></pre></td></tr></table></figure><h1 id="k8s-资源对象"><a href="#k8s-资源对象" class="headerlink" title="k8s 资源对象"></a>k8s 资源对象</h1><h2 id="资源的创建方式"><a href="#资源的创建方式" class="headerlink" title="资源的创建方式"></a>资源的创建方式</h2><ol><li>通过命令行的方式</li><li>通过yaml的方式</li></ol><h2 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h2><p>名称空间,用来隔离集群资源,默认只隔离资源,不隔离网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get ns   #用来查看名称空间</span><br></pre></td></tr></table></figure><p>我们以后创建的资源不指定名称空间,默认在default的名称空间</p><p>命令行创建</p><ul><li>kubectl create ns hello  创建名称空间</li><li>kubectl delete ns hello 删除名称空间</li></ul><p>通过配置文件也可以</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hello</span></span><br></pre></td></tr></table></figure><ul><li>创建 kubectl apply  -f hello.yaml</li><li>删除 kubectl delete -f hello.yaml</li></ul><h2 id="pod"><a href="#pod" class="headerlink" title="pod"></a>pod</h2><p>运行中的一组容器,pod是k8s中应用的最小单位</p><p>容器被封装在pod中,pod可以有一个或者多个容器,k8s不是直接操作容器,而是直接操作pod</p><p>创建一个pod</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl run mynginx --image=nginx</span><br></pre></td></tr></table></figure><h2 id="deployment"><a href="#deployment" class="headerlink" title="deployment"></a>deployment</h2><p>这个资源对象可以控制pod,使pod可以拥有多副本,扩缩容,自愈,故障转移,版本回退,滚动更新</p><h3 id="多副本"><a href="#多副本" class="headerlink" title="多副本"></a>多副本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create deploy my-dep --image=nginx --replicas=3  # 创建三个pod资源对象,每个pod里面有个nginx容器</span><br></pre></td></tr></table></figure><h3 id="扩缩容"><a href="#扩缩容" class="headerlink" title="扩缩容"></a>扩缩容</h3><p>我们可以使用scale 或者修改配置文件的方式实现更改pod的个数</p><h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><p>使用scale这个子命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale --replicas=5 deploy/my-dep</span><br></pre></td></tr></table></figure><p><img src="/2022/12/19/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s-2/../img/k8s-2assets/image-20221212192828197.png" alt="image-20221212192828197"></p><h4 id="缩容"><a href="#缩容" class="headerlink" title="缩容"></a>缩容</h4><p>修改配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl edit deploy/my-dep</span><br></pre></td></tr></table></figure><p><img src="/2022/12/19/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s-2/../img/k8s-2assets/image-20221212193043993.png" alt="image-20221212193043993"></p><p>修改为3然后保存退出</p><p><img src="/2022/12/19/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s-2/../img/k8s-2assets/image-20221212193113259.png" alt="image-20221212193113259"></p><h3 id="自愈-故障转移"><a href="#自愈-故障转移" class="headerlink" title="自愈,故障转移"></a>自愈,故障转移</h3><p>我们可以通过删除pod,停止虚拟机的方法验证</p><h4 id="验证自愈"><a href="#验证自愈" class="headerlink" title="验证自愈"></a>验证自愈</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete pod -n default my-dep-754679dc46-vbhfs</span><br></pre></td></tr></table></figure><p><img src="/2022/12/19/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s-2/../img/k8s-2assets/image-20221212210011591.png" alt="image-20221212210011591"></p><p>我们会发现k8s又帮我们重新起了一个pod</p><p><img src="/2022/12/19/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s-2/../img/k8s-2assets/image-20221212210054145.png" alt="image-20221212210054145"></p><h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><p>我们可以通过停掉一个虚拟机假装它崩了,关掉之后,k8s不会立即就重新开启新的pod,而是要等一段时间后才会</p><p><img src="/2022/12/19/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s-2/../img/k8s-2assets/image-20221212210340587.png" alt="image-20221212210340587"></p><p><img src="/2022/12/19/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s-2/../img/k8s-2assets/image-20221212210431228.png" alt="image-20221212210431228"></p><p>过了一段时间后</p><p><img src="/2022/12/19/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s-2/../img/k8s-2assets/image-20221212210958170.png" alt="image-20221212210958170"></p><h4 id="滚动更新"><a href="#滚动更新" class="headerlink" title="滚动更新"></a>滚动更新</h4><p>我们可以更新镜像的方式看到这个过程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式一</span></span><br><span class="line">kubectl set image deployment/my-dep nginx=nginx:1.16.1 --record</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式二 通过配置文件修改镜像名字</span></span><br><span class="line">kubectl edit deployment/my-dep</span><br></pre></td></tr></table></figure><p><img src="/2022/12/19/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s-2/../img/k8s-2assets/image-20221212211705104.png" alt="image-20221212211705104"></p><p>我们发现是先启动一个新的pod然后再杀死老的pod</p><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>有时候新版本可能出现问题了,我们需要回退到原来的版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看历史版本</span></span><br><span class="line">kubectl rollout history deployment/my-dep</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看某个历史版本信息</span></span><br><span class="line">kubectl rollout history deployment/my-dep --revision=2</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">回滚到上一次版本</span></span><br><span class="line">kubectl rollout undo deployment/my-dep</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">回滚到指定版本</span></span><br><span class="line">kubectl rollout undo deployment/my-dep --to-revision=2 </span><br></pre></td></tr></table></figure><h2 id="service"><a href="#service" class="headerlink" title="service"></a>service</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>service是k8s中一个很重要的资源对象,首先,因为pod存在重新调度的问题,pod的ip地址在k8s中是不固定的,因此需要一个代理来确保使用pod的应用不需要知道pod的真实ip地址,只需要知道service的ip地址和端口号,另外一个原因就是当创建了多个pod副本的时候,service能够实现负载均衡</p><blockquote><p>service主要由一个ip地址和一个标签选择器 组成,它的ip是不会变化的,ip跟它的生命周期一样</p></blockquote><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl expose deploy/mydep --port=8080 --target-port=80</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--port 是service资源对象的内部暴露端口,80是pod的端口</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看 创建的service的ip</span></span><br><span class="line"> kubectl get service</span><br></pre></td></tr></table></figure><p><img src="/2022/12/19/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s-2/../img/k8s-2assets/image-20221219135427478.png" alt="image-20221219135427478"></p><blockquote><p>我们可以在yaml文件中配置service的ip,指定暴露端口,和service的名字,暴露类型,也可以通过命令行使用kubectl指定</p><p>–cluster-ip 指定 service的ip  –name 指定service的名字 –type 指定暴露类型</p></blockquote><p>创建service对象后,k8s还会创建一个名字和service的名字相同的endpoints对象,该对象保存了所有标签符合要求的pod的ip和端口</p><p><img src="/2022/12/19/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s-2/../img/k8s-2assets/image-20221219135448838.png" alt="image-20221219135448838"></p><p>可以通过describe 查看更详细内容</p><p><img src="/2022/12/19/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s-2/../img/k8s-2assets/image-20221219135510416.png" alt="image-20221219135510416"></p><p>目前还只能集群内部访问这个ip,还能够使用域名的方式+端口访问(这个只能在pod内部访问)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用ip+端口</span></span><br><span class="line">curl 10.1.200.145:8080</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用域名  name.namespace.<span class="string">&quot;svc&quot;</span>(必须在pod内部)</span></span><br><span class="line">curl mydep.default.svc</span><br></pre></td></tr></table></figure><p>由于默认使用的是 ClusterIp的方式暴露,因此只能集群内部访问,我们要使用NodePort的方式暴露端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删掉原先的svc</span></span><br><span class="line">kubectl delete svc mydep</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用NodePort方式暴露</span></span><br><span class="line">kubectl expose deploy/mydep --port=8080 --target-port=80 --type=NodePort</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看对外暴露的端口</span></span><br><span class="line">kubectl get svc</span><br></pre></td></tr></table></figure><p><img src="/2022/12/19/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s-2/../img/k8s-2assets/image-20221219135934185.png" alt="image-20221219135934185"></p><p>8080是对内部开放的端口,30645是对外部的端口</p><p>我们可以使用任意一个结点的ip+这个端口访问内部的nginx</p><blockquote><p>NodePort 方式暴露的端口在30000-32767之间</p></blockquote><h3 id="服务自发现机制"><a href="#服务自发现机制" class="headerlink" title="服务自发现机制"></a>服务自发现机制</h3><p>当我们新建立好一个service的资源对象的时候,会将这个pod的ip和端口等信息注入到所有的pod中,这样所有的pod都能访问这个资源,这个就是k8s的服务自发现机制</p><p>两种支持的service发现机制: 环境变量注入和DNS</p><h4 id="环境变量注入方式"><a href="#环境变量注入方式" class="headerlink" title="环境变量注入方式"></a>环境变量注入方式</h4><p>kubelet在创建pod时会自动添加所有可用的service环境变量到该pod中去,因此pod就能访问service,但是这样有个缺点就是,得先创建service,再创建pod,已经创建的pod无法访问后面创建的service</p><h4 id="DNS方式"><a href="#DNS方式" class="headerlink" title="DNS方式"></a>DNS方式</h4><p>可以通过为k8s集群增加DNS服务器组件,每增加一个service,在DNS服务器中,在其他pod中访问它的域名就能通过DNS服务器得到它的域名,然后配合指定的端口,就能访问到service这个资源对象了</p><p>这个方法也有它的缺点:</p><ul><li>由于缓存的问题,如果service在这中间出现了故障,那么pod里面缓存的ip就不准确</li><li>每个pod频繁请求DNS,也会给系统带来比较大的负荷</li></ul><h3 id="service的工作原理"><a href="#service的工作原理" class="headerlink" title="service的工作原理"></a>service的工作原理</h3><p>k8s集群中的结点都运行着kube-proxy,它是实现service的主要组件,它有两种工作模式</p><h4 id="userspace"><a href="#userspace" class="headerlink" title="userspace"></a>userspace</h4><p>每建立一个service,kube-proxy就会在宿主机上监听一个端口,与这个service对应起来,当收到serviceip+端口的流量时,通过定制好的iptabels将流量重定向到这个端口,然后kube-proxy将流量代理到指定的pod里面</p><h4 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h4><p>这个模式下,kube-proxy只负责建立iptables的路由规则,其余工作由iptabels的内核完成</p><blockquote><p>k8s的service的设计原则:任何一个结点上的kube-proxy都能够正确的将流量导向任何一个被service代理的pod,而这个kube-proxy不需要和被代理的pod在同一个宿主机</p></blockquote><h1 id="k8s网络网络原理"><a href="#k8s网络网络原理" class="headerlink" title="k8s网络网络原理"></a>k8s网络网络原理</h1><blockquote><p>在k8s集群的节点中使用docker ps，总是会发现一堆名为pause的容器，就是这个原因，pause是为多个业务容器提供共享的ns的</p></blockquote><h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><h2 id="删除资源对象"><a href="#删除资源对象" class="headerlink" title="删除资源对象"></a>删除资源对象</h2><h3 id="删除单个pod"><a href="#删除单个pod" class="headerlink" title="删除单个pod"></a>删除单个pod</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete pods -n namespace podname</span><br></pre></td></tr></table></figure><h3 id="删除deployment"><a href="#删除deployment" class="headerlink" title="删除deployment"></a>删除deployment</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="删除service"><a href="#删除service" class="headerlink" title="删除service"></a>删除service</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="删除单个工作结点"><a href="#删除单个工作结点" class="headerlink" title="删除单个工作结点"></a>删除单个工作结点</h2><p>master 结点上执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">让资源对象不会往这个结点上调度</span></span><br><span class="line">kubectl cordon nodename</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在master结点上执行,驱逐一个结点,最好在这这个命令之前把在这个结点上的pod删掉</span></span><br><span class="line">kubectl drain nodename</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除节点</span></span><br><span class="line">kubectl delete node nodename</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果没有删掉结点上的pod,其实这个时候结点上的pod在其他地方还能访问到,那些规则还存在,等过一段时间后,k8s发现这个结点删除了,会让这些pod转移到其他机器上</span></span><br></pre></td></tr></table></figure><p>node结点上执行(为了下次加入集群方便,不报错)(这个时候所有的iptables的规则,以及虚拟网卡,还都存在,我们必须手动清除)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">清除旧的信息</span></span><br><span class="line">kubeadm reset -f</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">能重启一下最好</span></span><br></pre></td></tr></table></figure><h2 id="删除整个集群"><a href="#删除整个集群" class="headerlink" title="删除整个集群"></a>删除整个集群</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除所有结点</span></span><br><span class="line">kubectl delete node --all</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">清理主节点</span></span><br><span class="line">kubeadm reset -f</span><br><span class="line">rm -fr ~/.kube/  /etc/kubernetes/*  /var/lib/etcd/*</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">清理工作结点</span></span><br><span class="line">kubeadm reset -f</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启一下,或者手动删除iptables规则和网卡</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果不想使用了,可以把服务也停了</span></span><br><span class="line">systemctl enable kubelet --now</span><br></pre></td></tr></table></figure><blockquote><p>删除定义好的那些规则(这个是全部删除)</p><p>iptables -F &amp;&amp; iptables -t nat -F &amp;&amp; iptables -t mangle -F &amp;&amp; iptables -X</p></blockquote><h1 id="额外补充"><a href="#额外补充" class="headerlink" title="额外补充"></a>额外补充</h1><h3 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kubectl</span> </span><br><span class="line">source &lt;(kubectl completion bash)</span><br><span class="line">kubectl completion bash &gt;/etc/bash_completion.d/kubectl</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">source</span> &lt;(helm completion bash)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">helm completion bash &gt;/etc/bash_completion.d/helm</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">crictl (containered)</span></span><br><span class="line">source &lt;(crictl completion bash)</span><br><span class="line">crictl completion bash &gt;/etc/bash_completion.d/crictl</span><br></pre></td></tr></table></figure><h3 id="不会写yaml配置文件怎么办"><a href="#不会写yaml配置文件怎么办" class="headerlink" title="不会写yaml配置文件怎么办"></a>不会写yaml配置文件怎么办</h3><p>我们只要记得kubectl的命令可以,可以用这个命令来生成yaml文件(不过会有冗余内容哦</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个depolyment资源对象的yaml</span></span><br><span class="line">kubectl create deploy mydep --image=nginx --replicas 5  -o yaml --dry-run=client &gt; depoly.yaml</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个service 的 yaml</span></span><br><span class="line">kubectl expose deploy mydep --port=8080 --target-port=80 --type=NodePort -o yaml --dry-run=client &gt; depoly.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果当前资源对象已经存在(这种方式产生的冗余东西会更多)</span></span><br><span class="line">kubectl get deploy mydep -o wide &gt; depoly.yaml  </span><br><span class="line">kubectl get svc mydep -o wide &gt; depoly.yaml</span><br></pre></td></tr></table></figure><h3 id="pod创建流程"><a href="#pod创建流程" class="headerlink" title="pod创建流程"></a>pod创建流程</h3><p>kubectl 一次pod创建流程中,各个组件干的活:</p><p>kubectl 将命令解析成生成创建pod的参数,通过apiserver提供的接口传递过去</p><p>apiserver 收到后,先进行上下文和pod元数据验证两者的namespace是否匹配,不匹配则创建失败,成功则将一些系统元数据(创建时间,uid)注入到pod中,然后检测元数据中系统必须项是否存在,如果为空则抛出异常,终止创建.如果一切顺利,在etcd中持久化pod信息,然后将创建pod的工作交给kube-scheduler和kubelet</p><p>kube-scheduler 根据待调度的pod以及可用的工作结点根据算法选取一个最优的绑定策略,然后告诉apiserve选取哪个结点部署pod,apiserve收到后发送请求给结点上的kubelet</p><p>kubelet 根据要求只会容器运行时创建容器就可以了</p><h1 id="遇到的坑和解决办法"><a href="#遇到的坑和解决办法" class="headerlink" title="遇到的坑和解决办法"></a>遇到的坑和解决办法</h1><p>有时候虚拟机重启后,网络插件创建的虚拟网卡就没有了,那么有时候这个pod就访问不了了,我们需要重新部署网络插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># master 结点执行 , 删除网络插件</span><br><span class="line">kubectl delete -f kube-flannel.yml</span><br><span class="line"># 删除网卡(所有结点执行)</span><br><span class="line">sudo ifconfig cni0 down</span><br><span class="line">sudo ip link delete cni0</span><br><span class="line">sudo ifconfig flannel.1 down</span><br><span class="line">sudo ip link delete flannel.1</span><br><span class="line">sudo rm -rf /var/lib/cni/flannel/*</span><br><span class="line">sudo rm -rf /var/lib/cni/networks/cbr0/*</span><br><span class="line">sudo rm -rf /var/lib/cni/cache/*</span><br><span class="line">sudo rm -f /etc/cni/net.d/*</span><br><span class="line">sudo systemctl restart kubelet</span><br><span class="line">sudo systemctl restart containerd</span><br><span class="line">sudo chmod a+w /var/run/containerd/containerd.sock</span><br><span class="line"></span><br><span class="line">#再次master结点部署网络插件</span><br><span class="line">kubectl apply -f kube-flannel.yml</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/12/18/408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-temp/"/>
      <url>/2022/12/18/408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-temp/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个是跟哔哩哔哩<a href="https://www.bilibili.com/video/BV1c4411d7jb?p=5&vd_source=25bfa760964880528c6259566561afed">湖科大教书匠</a>的视频做的笔记,以及自己的思考与总结</p><h2 id="什么是计算机网络"><a href="#什么是计算机网络" class="headerlink" title="什么是计算机网络"></a>什么是计算机网络</h2><p>计算机网络是由通信介质将地理位置不同的且相互独立的计算机连接起来，实现数据通信与资源共享。</p><p>个人觉得,计算机网络就是<strong>实现如何将数据可靠,快速</strong>的从一个设备传输到另一个设备</p><h3 id="专用术语"><a href="#专用术语" class="headerlink" title="专用术语"></a>专用术语</h3><h4 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h4><p>实体是指任何可发送或接受信息的硬件或者软件</p><p>对等实体是指位于同一个层次的实体</p><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>协议是控制两个对等实体进行<strong>逻辑通信</strong>的规则的集合</p><p>三个要素:</p><ul><li><strong>语法</strong>:定义交换信息的格式(头部)</li><li><strong>语义</strong>:通信双方需要完成的操作(报文)</li><li><strong>同步</strong>:定义收发双方的时序关系(tcp建立连接的过程)</li></ul><h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><p>在协议的控制下,两个对等实体间的逻辑通信使得本层能够向上一层提供服务</p><p>协议是水平的,服务是垂直的</p><p>每层之间的数据类型:传输层的报文,网络层的分组,数据链路层的帧,物理层的比特流</p><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p><img src="/2022/12/18/408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-temp/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221218140005626.png" alt="image-20221218140005626"></p><p><img src="/2022/12/18/408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-temp/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221218171039441.png" alt="image-20221218171039441"></p><p><img src="/2022/12/18/408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-temp/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221218171100169.png" alt="image-20221218171100169"></p><p>体系结构的作用:</p><ul><li>分层</li><li>每一层必须要完成的功能</li><li>每一层使用的协议(TCP&#x2F;IP体系结构)</li></ul><h3 id="分层的必要性"><a href="#分层的必要性" class="headerlink" title="分层的必要性"></a>分层的必要性</h3><p>计算机网络是个非常复杂的系统,分层可以将庞大而复杂的问题,转化为若干个较小的局部问题,而这些较小的局部问题比较容易研究和处理</p><p><strong>两个设备之间需要考虑的问题(物理层的问题)</strong>:</p><ul><li>采用什么传输介质</li><li>使用什么样的物理接口</li><li>使用怎么样的信号表示比特0和1</li></ul><p>这个就交给物理层去解决(传输介质严格来说不属于物理层)</p><p><strong>在一个网络上,需要考虑的问题(数据链路层的问题)</strong>:</p><ul><li>如何标识网络中的各个主机(如何得知数据发给谁,主机如何判断是不是发给我的),可以采用mac地址</li><li>解决上面的问题后,如何从信号所表示的比特流中区分地址和数据</li><li>如何解决线路的冲突的问题(线路争用)(<strong>总线型链路,现在已经淘汰了,采用交换机来替代</strong>)</li></ul><p><strong>在多个网络上,需要考虑的问题(网络层的问题)</strong>:</p><ul><li>如何标识网络以及网络中的各个主机</li><li>路由器如何转发分组,如何进行路由选择</li></ul><p><strong>在不同的主机上,需要考虑的问题(传输层的问题)</strong>:</p><ul><li>如何解决进程之间的网络通信问题</li><li>出现传输错误时,如何处理</li></ul><h2 id="因特网"><a href="#因特网" class="headerlink" title="因特网"></a>因特网</h2><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p><strong>网络</strong>是由若干个结点以及连接这个结点的链路构成(这个一般指的是本地通过交换机连接起来的结点)</p><p><strong>互联网</strong>是由多个网络通过路由器连接起来的,构成一个覆盖范围更大的网络 (网络的网络)</p><p><strong>因特网</strong>是世界上最大的互联网</p><p><strong>internet</strong> 是一个通用名词,泛指多个计算机网络互连而成,网络之间的通信协议可以任意</p><p><strong>Internet</strong> 是一个专有名词,特指因特网,采用TCP&#x2F;IP 协议簇作为通信规则,前身是ARPANET</p><h3 id="因特网发展阶段"><a href="#因特网发展阶段" class="headerlink" title="因特网发展阶段"></a>因特网发展阶段</h3><p>1969 第一个分组交换网<strong>ARPANET</strong></p><p>70年代中期,研究多种网络之间的互连</p><p>1983年,TCP&#x2F;IP协议成为ARPANET的标准协议,这个也是因特网的诞生时间</p><p>1983年,NSF 围绕六个大型计算机中心建设NSFNET(主干网,地区网,校园网),三级结构</p><p>1990年 ARPANET 任务完成,正式关闭</p><p>1991年 美国政府将因特网主干网交给私人公司经营</p><p>1993年 NSFNET 逐渐被若干个商用主干网替代,政府机构不在负责运营,让各种因特网服务提供商ISP 来运营</p><p>1994年 万维网www技术促使因特网迅猛发展</p><p>1995年 NSFNET 停止运作,因特网彻底商业化</p><h3 id="因特网的标准化工作"><a href="#因特网的标准化工作" class="headerlink" title="因特网的标准化工作"></a>因特网的标准化工作</h3><p>因特网的标准化工作对因特网的发展起到了非常重要的作用</p><p>因特网在制定其标准上的一个很大的特点是面向公众</p><ul><li>因特网的所有RFC 技术文档都可以从因特网上免费下载</li><li>任何人都可以随时发电子邮件发表对某个文档的建议和意见</li></ul><h3 id="因特网的组成"><a href="#因特网的组成" class="headerlink" title="因特网的组成"></a>因特网的组成</h3><p>边缘部分: 由所有连接在因特网上的主机组成</p><p>核心部分: 由大量网络和连接这些网络的路由器组成 ,为边缘部分提供连通性和交换服务</p><h2 id="交换方式"><a href="#交换方式" class="headerlink" title="交换方式"></a>交换方式</h2><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p>电路交换机接通电话线的方式称为电路交换</p><p>电路的三个步骤:</p><ul><li>建立物理连接(分配通信资源)</li><li>通话(一直占用通信资源)</li><li>释放物理连接(归还资源)</li></ul><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>发送方构造报文成分组,发送分组</p><p>路由器 缓存分组,转发分组 (存储转发)</p><p>接收方 接收分组,还原分组成报文</p><p>分组交换有两种方式:<strong>数据报和虚电路</strong></p><p>虚电路是一种逻辑电路,就是每一次分组都和上一次分组的路径一样,这样到达接收端的顺序是一样的,不会失序,也不会重复分组</p><h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3><p><strong>不限制数据报大小</strong>,也是存储转发,跟分组交换差不多,分组交换就是多次的固定长度的报文交换,因为分组就是报文分割而成,<strong>现在报文交换基本被分组交换取代</strong></p><img src="/2022/12/18/408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-temp/../img/计算机网络-tempassets/image-20221217210801358.png" alt="image-20221217210801358"><p>三个交换方式对比:</p><table><thead><tr><th align="center">交换方式</th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">电路交换</td><td align="center">1.通信时延小(数据直达),2.有序传输,3.没有冲突(不争用物理线道),4.适用范围广(适用模拟信号和电路信号),5.实时性强,6.控制简单</td><td align="center">1.建立连接时间长,2.线路独占,使用效率低,3.灵活性差(只要线路坏了,就要重新建立连接),4.难以规格化</td></tr><tr><td align="center">报文交换</td><td align="center">1.无需建立连接,2.动态分配线路(选择合适的线路),3.提高线路可靠性(出现故障,重新选择路线),4提高线路利用率(不固定占用线路,只有发送的时候占用),5.提供多目标服务(一个结点可以发往多个目的地址)</td><td align="center">1.引起了转发时延(需要存储转发),2.需要较大的存储缓存空间(不限制报文大小),3.需要额外的信息量(报文头部)</td></tr><tr><td align="center">分组交换</td><td align="center">1.无需建立连接,2.线路利用率高,3.简化了存储管理(相对报文而言,分组的大小固定),4.加速传输(后一个分组的存储与前一个分组转发可以同时进行),5.减少出错概率和重发数据量(分组比报文小,出错概率会低一些,即使出错了,重发的数据量就会变少,只需要重传分组)</td><td align="center">1.引起转发时延(存储转发),2.需要额外的信息量(分组头部),3.对于数据报服务,存在失序,丢失,重复分组的问题,还原原始报文比较麻烦,对于虚电路服务,存在呼叫建立,数据传输,虚电路释放的三个过程</td></tr></tbody></table><img src="/2022/12/18/408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-temp/../img/计算机网络-tempassets/image-20221217215149123.png" alt="image-20221217215149123"><h2 id="计算机网络性能指标"><a href="#计算机网络性能指标" class="headerlink" title="计算机网络性能指标"></a>计算机网络性能指标</h2><h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><p>单位时间内能传输的比特数量</p><p>速率中的单位k代表10^3,M代表10^6,G代表10^9</p><p><img src="/2022/12/18/408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-temp/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221218161558853.png" alt="image-20221218161558853"></p><p>这道题应该这么算:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100*2^20*8/100*10^6 = 2^23/10^6 = 8.388608s</span><br><span class="line">我们其实也可以直接约掉M,这样就只有8s 其实也差别不大</span><br></pre></td></tr></table></figure><h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p>在模拟信号系统中,它表示信号所包含的各种不同频率成分所占据的频率范围 ,单位:Hz</p><p>在计算机网络中,用来表示网络的<strong>通信线路</strong>所能传输数据的能力,带宽是一个线路的最高速率</p><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p>表示单位时间内,通过某个网络,信道,接口的数据量</p><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p>表示一个分组到达目的主机需要的时间,从主机到发送地址,一般需要经历以下几个时延</p><p>发送时延(由网卡的发送速率,信道带宽,接口速率决定,取其中的最小值),分组长度(b)&#x2F;发送速率(b&#x2F;s)</p><p>传播时延 信道长度(m)&#x2F;电磁波传播速率(m&#x2F;s)</p><p>常用传输媒体的电磁波传播速率</p><ul><li>自由空间: 3*10^8 m&#x2F;s</li><li>铜线: 2.3*10^8 m&#x2F;s</li><li>光纤: 2.0*10^8 m&#x2F;s</li></ul><p>处理时延(多个路由器要处理) 这个很难通过计算公式计算,(包括排队时延和处理时延)</p><p><img src="/2022/12/18/408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-temp/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221218164009177.png" alt="image-20221218164009177"></p><p>我们单纯的认为发送时延占主导还是传播时延占主导,得具体情况具体分析</p><blockquote><p>增加数据量只增加发送时延,不影响传播时延,传播时延永远是<strong>最后一个比特的信号发送完</strong>到<strong>所有比特信号到目的地址</strong>的间隔</p></blockquote><p><img src="/2022/12/18/408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-temp/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221218174727515.png" alt="image-20221218174727515"></p><p>时延就是最后一个比特到终点的时间,甭管你多少个分组,在多段链路上(按顺序来发送),计算公式就是:  n代表分组数量,m代表链路数量</p><p><strong>单个分组发送时延*N(相当于发送最后一个报文的时延)</strong>+<strong>发送时延*m-1(最后一个分组的后续结点总发送时延)</strong>+<strong>每段链路的传播时延*m(最后一个分组的传播时延)</strong></p><h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><p>时延带宽积 &#x3D; 传播时延 * 带宽, 意思就是,当发送的第一个比特到达目的地后,发送端就发送了时延带宽积个比特的数据了</p><h3 id="往返时间-RTT"><a href="#往返时间-RTT" class="headerlink" title="往返时间(RTT)"></a>往返时间(RTT)</h3><p>我们有时候需要知道双向交互一次需要的时间,因此RTT也是一个重要的性能指标</p><h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><p>信道利用率: 表示某个信道有百分之几的时间是被利用的</p><p>网络利用率: 表示全网络的信道利用率的加权平均</p><p>信道利用率不是越高越好,根据排队论,当某个信道的利用率增大时,排队的分组也会越多,引起的时延也会迅速增加</p><p><img src="/2022/12/18/408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-temp/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221218170051379.png" alt="image-20221218170051379"></p><h3 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h3><p>即分组丢失率,指在一定时间范围内,传输过程中丢失分组数量与总分组数量的比率</p><p>丢包率分为接口丢包率,结点丢包率,链路丢包率,路径丢包率,网络丢包率</p><p>分组丢失主要两种情况:</p><ul><li>分组在传输过程中出现误码</li><li>分组到达队里已满的分组交换机(路由器)时就会被丢弃</li></ul><p>丢包率能够反映网络的拥塞情况</p><p><img src="/2022/12/18/408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-temp/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221218170508256.png" alt="image-20221218170508256"></p><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>物理层考虑的是<strong>怎样才能在连接各种计算机的传输媒体上传输比特流</strong></p><p>物理层为数据链路层屏蔽了各种传输媒体的差异,是的数据链路层只需要考虑如何完成本层协议和服务,而不必考虑网络的具体传输媒体是什么</p><p><img src="/2022/12/18/408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-temp/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221218195803348.png" alt="image-20221218195803348"></p><h3 id="传输媒体"><a href="#传输媒体" class="headerlink" title="传输媒体"></a>传输媒体</h3><p>导引型(有硬件传输): 双绞线,同轴电缆,光纤,电力线</p><p>非导引型(自由空间): 微波通信(2~40GHz)</p><h3 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h3><p>串行传输,并行传输</p><p>同步传输:字节紧凑传输,需要双方时钟同步(外同步:增加一条时钟信号线,内容部,将同步信号编码到发送数据中一起传输)</p><p>异步传输: 字节之间可以不用紧凑传输,字节内需要同步</p><p>单向通信(单工): 广播</p><p>双向交替通信(半双工):对讲机</p><p>双向同时通信(全双工): 电话</p><h3 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h3><p>数据是运送消息的实体</p><p>码元:构成信号的一段波形</p><p>不归零编码(不采用): 一个码元正电平代表1,负电平代表0,额外还需要一个同步信号同步接收码元,不然怎么区分多个相同的码元</p><p>归零编码: 这个其实就是将同步信号写在了数据里面,正电平代表1,负电平代表0,0电平代表码元结束,缺点是编码效率低,相当于传输一个比特就得多搞一个比特</p><p>曼彻斯特编码: 跳变就表示数据,负跳变代表1,正跳变代表0,跳变是在中间位置,所以对方主机能够知道一个一个码元的时间是多少</p><p>差分曼彻斯特编码:如果在最初信号的时候，即第一个信号时：如果中间位电平从低到高，则表示0；如果中间位电平从高到低，则表示1；否则就看当前码元开始的位置与上一次码元的结束部分电压是否相同,相同则表示0,不同则表示1</p><p><img src="/2022/12/18/408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-temp/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221218212001631.png" alt="image-20221218212001631"></p><p>就是通过中间跳变来告诉对方主机,我的一个码元时间周期是多长</p><p>模拟信号:</p><p>通过模拟信号,可以产生很多种码元,这样的话,一个码元就可以表示多个比特</p><h3 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h3><p>影响失真的因素有: 码元传输速率,信号传输距离,噪声干扰,传输媒体质量</p><p><img src="/2022/12/18/408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-temp/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221218213752561.png" alt="image-20221218213752561"></p><p><img src="/2022/12/18/408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-temp/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221218215857564.png" alt="image-20221218215857564"></p><p><img src="/2022/12/18/408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-temp/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tempassets/image-20221218220759980.png" alt="image-20221218220759980"></p><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h4 id="协议-1"><a href="#协议-1" class="headerlink" title="协议"></a>协议</h4><h5 id="ppp"><a href="#ppp" class="headerlink" title="ppp"></a>ppp</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">解决帧的区分的问题,物理层可看不懂哪里是一帧一帧,它只知道这是个比特流,所以我们用协议规定,哪里是一帧</span><br></pre></td></tr></table></figure><h5 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过ip找到mac地址</span><br></pre></td></tr></table></figure><p>交换机,会记录每个物理地址对应的接口,每一个主动发起数据的接口对应的物理地址才会被记录在表中,如果找不到目的物理地址,则会全端口转发</p><p>为了增加网络的可靠性,一般会使用冗余链路,但是冗余链路具有环状,会导致广播风暴,交换机的帧交换表震荡,这个时候可以使用生成树协议,交换机自动关闭某些端口,形成树状结构,这样就没有环路,当某一条链路不能够用的时候,又将重新计算,生成一个新的树状结构</p><p>因特网网络层用的就是数据报的方式</p><p>A类网络 拥有网段 126 个  每个网段可分配主机数量2^24 - 2 &#x3D; 16777214</p><p>B类网络 拥有网段 16384 个 每个网段可分配主机数量2^16 -2 &#x3D; 65534   </p><p>C类网络 拥有网段 2097152 个  每个网段可分配主机数量 2^8 -2 &#x3D; 254</p><p>D类网络 是广播地址 不区分网络号与主机号  以 1110 开头的都是 </p><h3 id="局域网ip"><a href="#局域网ip" class="headerlink" title="局域网ip"></a>局域网ip</h3><table><thead><tr><th align="center">网络类别</th><th align="center">IP 地址范围</th><th align="center">网络数</th><th align="center">可分配ip个数</th></tr></thead><tbody><tr><td align="center">A 类网</td><td align="center">10.0.0.0~10.255.255.255</td><td align="center">1</td><td align="center">2^24</td></tr><tr><td align="center">B 类网</td><td align="center">172.16.0.0~172.31.255.255</td><td align="center">16</td><td align="center">16*2^16</td></tr><tr><td align="center">C 类网</td><td align="center">192.168.0.0~192.168.255.255</td><td align="center">255</td><td align="center">255*2^8</td></tr></tbody></table><p>判断一个ip地址与自己是不是在同一网络下,只需要将ip与子网掩码做与运算,看得到的ip是否相同就行</p><p>路由器也成为默认网关</p><p>传输层的端口,是逻辑端口,只是为了区分服务而存在的…….</p><p>几个概念:</p><p>​发送窗口:</p><p>​拥塞窗口:</p><p>​慢开始门限值:</p><p>tcp:</p><ul><li><p>滑动窗口: 发送端一开始发送几个连续的tcp报文,接收端每接收一个报文时,会向客户端发送确认报文,以及窗口大小,然后发送端根据窗口大小,跳整自己的发送窗口大小,如果接收端接收窗口为0,则停止发送,过一段时间后,会发送询问窗口大小的报文,如果还是0则重复这个操作,否则就发送tcp报文</p></li><li><p>拥塞控制算法:  </p><p>慢开始算法: 每次拥塞窗口的值,都变成原来的两倍</p><p>拥塞避免算法: 每次拥塞窗口的值,只加一 </p><p>快重传: 1.接收方接收到tcp报文时,立即发送确认报文  2. 接收方接收到失序的报文时,就要说明自己接收到了报文,要说明重复确认,以前的报文没收到. 3 接收方接收到了三次确认报文后,就要重发以前的报文,而不是等到重传时间到了再重传</p></li></ul><p>流量控制,拥塞控制,超时重传,(通过滑动窗口实现可靠传输)</p><p>三次握手的过程:   客户端主动发起请求  <strong>设置一个同步位 syn &#x3D; 1(表示要建立连接),然后给定一个随机值seq&#x3D;x</strong> 发送给服务器端,服务器接收到后 响应 同步为 <strong>syn &#x3D; 1,ACK &#x3D; 1 表明接收到了数据 然后也给定一个随机值 seq&#x3D;y,并且还设置ack&#x3D;x+1(接收序号数+1)</strong>,然后客户端再次发送数据过来,<strong>ACK&#x3D;1,seq&#x3D;x+1(发送序号数+1),ack &#x3D; y+1 (序号数加+1)</strong>  (第三次握手并不是多余的,如果因为网络原因,第一次发送的请求数据报在网络中滞留,然后客户端又发起超时重传,然后服务器端开始与客户端正式开始三次握手,建立连接后,并且传输完数据,然后断开连接,这个时候 那个网络中滞留的数据包可能又到了,这个时候服务器端以为客户端又来了,如果我们使用两次握手,那么会直接进入连接,而客户端并没有连接,这个时候会浪费服务器资源)</p><p>四次挥手: 客户端主动发起断开连接 <strong>数据包内容为 FIN &#x3D; 1(表明结束),ACK&#x3D;1(表明收到上一个报文),seq&#x3D;u(已发送的序号数+1),ack&#x3D;v(已接收序号数+1)</strong>,服务器端收到后回传数据报内容  <strong>seq&#x3D;v(已经发送的字节数+1 ,与客户端发来的ack一致),ack&#x3D;u+1(因为已经多接受了客户端的上一个报文,所以是u+1)</strong>,这个时候,客户端向服务器端的发送的通道连接断开了,因为客户端已经没有数据要发了,但是服务器端可能还有数据要发给客户端,客户端还是要接收,并且回复确认, 服务器发送断开连接  <strong>FIN&#x3D;1,ACK&#x3D;1(表明这是断开连接报文),seq &#x3D; w(这个中间,服务器可能又发了很多数据),ack&#x3D;u+1(接收到客户端发送报文序号数)</strong>,客户端收到后,还需要发送确认报文(如果你不确认,那么服务器以为你没收到,会一直发送重传报文,等超过重传次数后,便会断开连接)  <strong>ACK&#x3D;1 (确认收到),seq&#x3D;u+1(已发送的序号数),ack&#x3D;w+1(已经接受序号数+1)</strong>,至此服务器端断开连接,进入关闭状态,<strong>但是客户端还需要有个等待时间段(如果客户端的最后一个报文服务器端没有收到,那么服务器端会以为客户端没有收到,会发送超时重传,如果客户端直接关闭了,那么服务器就会一直重传到次数结束)</strong></p><p>c&#x2F;s : 客户端与服务器端   客户发起请求服务,服务器为其提供服务</p><p>p2p: 没有客户端与服务器端一说,每个计算机既是请求者,也是服务者</p><p>DHCP:</p><p>客户端广播发起申请ip的请求,源ip为0.0.0.0,目的地址为255.255.255.255:68,dhcp监听68才能处理这个请求,然后分配ip,通过广播的方式</p><h2 id="额外补充"><a href="#额外补充" class="headerlink" title="额外补充"></a>额外补充</h2><h2 id="自我思考"><a href="#自我思考" class="headerlink" title="自我思考"></a>自我思考</h2>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解kubernetes（k8s）网络原理之二-service原理</title>
      <link href="/2022/12/17/k8s%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E5%8E%9F%E7%90%862/"/>
      <url>/2022/12/17/k8s%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E5%8E%9F%E7%90%862/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>此文章转载于<a href="https://cloud.tencent.com/developer/inventory/21543/article/1869600,%E6%88%91%E8%A7%89%E5%BE%97%E5%86%99%E5%BE%97%E9%9D%9E%E5%B8%B8%E5%A5%BD,%E6%80%95%E4%BB%96%E5%93%AA%E5%A4%A9%E4%B8%8D%E8%A7%81%E4%BA%86,%E5%B0%B1%E8%AE%B0%E5%BD%95%E4%B8%8B%E6%9D%A5%E4%BA%86">https://cloud.tencent.com/developer/inventory/21543/article/1869600,我觉得写得非常好,怕他哪天不见了,就记录下来了</a></p></blockquote><p>上一篇文章中我们介绍了pod与主机互通及pod访问外网的原理，在这一章我们将介绍pod与pod的相互访问以及外部服务访问pod的方式，由此引出k8s的service的几种类型、使用场景和相关的实现原理。</p><blockquote><p>本文将继续沿用上一章的习惯，用linux network namespace（下面简称ns）来代表pod，注意我们说的pod就特指是hostNetwork为false的pod</p></blockquote><p>我们将在一个节点模拟创建几个pod,用iptables的方式模拟实现clusterIP和nodeport的方式暴露到节点外。</p><p>开始之前，我们还是先上关于阅读本章内容需要掌握的linux网络知识。</p><h2 id="netfilter"><a href="#netfilter" class="headerlink" title="netfilter"></a>netfilter</h2><p>linux收发包流程是一个贼复杂的过程，为了让用户可以在收发包的过程中对数据包进行修改或过滤，linux从2.4版本开始引入了netfilter子系统，在收发包的数据路径中的关键节点上提供扩展（hook）点，这些扩展点上可以编写扩展函数对数据包进行过滤和修改，扩展点一共有五个点，主要有：</p><ul><li><code>NF_INET_PRE_ROUTING（PREROUTING）</code>，数据包刚到达时会经过这个点，通常用来完成DNAT的功能。</li><li><code>NF_INET_LOCAL_IN（INPUT）</code>，数据包要进入本机的传输层时会经过这个点，通常用来完成防火墙入站检测。</li><li><code>NF_INET_FORWARD（FORWARD）</code>，数据包要通过本机转发时会经过这个点，通常用来完成防火墙转发过滤。</li><li><code>NF_INET_LOCAL_OUT（OUTPUT）</code>，从本机的数据包要出去的时候会经过这个点，通常用来做DNAT和防火墙出站检测。</li><li><code>NF_INET_POST_ROUTING（POSTROUTING）</code>，数据包离开本机前会经过这个点，通常用来做SNAT。</li></ul><p><img src="/2022/12/17/k8s%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E5%8E%9F%E7%90%862/../img/%E5%8E%9F%E7%90%86%E4%BA%8Cassets/1620.jpeg" alt="img"></p><p>图一：netfilter</p><p>为什么要了解这个netfilter呢？因为k8s的serviceIP实现（无论是iptables和ipvs）、NetworkPolicy的实现都与这个netfilter的流程息息相关，对于netfilter需要get到几个关键的流程：</p><ul><li>主机的应用程序接收外部的数据包会经过的点：PREROUTING -&gt; INPUT</li></ul><p><img src="/2022/12/17/k8s%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E5%8E%9F%E7%90%862/../img/%E5%8E%9F%E7%90%86%E4%BA%8Cassets/1620-16712855729001.jpeg" alt="img"></p><p>图二：主机应用程序接收数据包流程</p><ul><li>主机的应用程序发送数据包到外部会经过的点：OUTPUT -&gt; POSTROUTING</li></ul><p><img src="/2022/12/17/k8s%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E5%8E%9F%E7%90%862/../img/%E5%8E%9F%E7%90%86%E4%BA%8Cassets/1620-16712855729002.jpeg" alt="img"></p><p>图三：主机应用程序发送数据包流程</p><ul><li>主机上的pod发送的数据包去外部或去主机的另一个pod：PREROUTING -&gt; FORWARD -&gt; POSTROUTING</li></ul><p><img src="/2022/12/17/k8s%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E5%8E%9F%E7%90%862/../img/%E5%8E%9F%E7%90%86%E4%BA%8Cassets/1620-16712855729003.jpeg" alt="img"></p><p>图四：主机上的pod发送数据去外部或主机的另一个pod的流程</p><blockquote><p>主机上运行的pod虽然也是主机上的一个进程，但pod发送数据包出去的流程却和主机的其它进程不一样，这个点刚开始笔者也曾经困惑过，因为pod在新的ns中，所以它的发包流程是和主机收到另一台主机的数据然后转发的流程一样的；</p></blockquote><ul><li>另外注意图中的IPIsLocal点，会判断数据包的目标IP是否为本机IP，如果是，则往INPUT点走；当IP不是本机IP，就会看net.ipv4.ip_forward是否为1,是则继续走朝FORWARD走，为0则丢弃，所以要设置为1才能为主机上的pod提供流量转发功能；</li></ul><p>掌握这几个流程对于我们后面使用iptables及理解k8s的service的实现很有帮助，下面的内容我们会多次用到这几个流程。</p><p>虽然linux为我们预留了5个扩展点，但编写扩展函数的难度贼大，需要了解很多上下文，随便一个错误就会让主机蓝屏死机什么的，贼刺激，所以我们要找个更容易使用的工具，iptables就是这个工具，它在netfilter子系统的扩展点上已经实现了对数据包的匹配和修改，然后提供命令行让用户可以轻松地制定规则，我们只需要告诉它怎么匹配和把包修改成什么就行了，有了iptables，数据包的拦截与修改就变得容易了。</p><h2 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h2><p>大多数linux发行版都默认集成了iptables，先通过一个简单的iptables命令来了解一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A <span class="variable constant_">INPUT</span> -t filter -s <span class="number">192.168</span><span class="number">.1</span><span class="number">.10</span> -j <span class="variable constant_">DROP</span></span><br></pre></td></tr></table></figure><p>复制</p><p>上面的命令是一条防火墙入站规则，意思是指不允许来源为192.168.1.10的IP访问本机的服务；</p><p>我们来详细解释下上面的命令，iptables是命令的固定前缀</p><ul><li><pre><code>-A<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   是指后面追加一条规则，其它：</span><br><span class="line"></span><br><span class="line">  - -I是前面插入规则，优先级更高</span><br><span class="line">  - `-D`是删除规则</span><br><span class="line">  - `-N`是新增加链</span><br><span class="line">  - `-F`清除链上的所有规则或所有链</span><br><span class="line">  - `-X`删除一条用户自定义链</span><br><span class="line">  - `-P`更改链的默认策略</span><br><span class="line">  - `-L`展示指定的链上的规则</span><br><span class="line"></span><br><span class="line">- `INPUT`是iptables链的名称，指示当前规则工作在哪个netfilter的扩展点，iptables有五条固定的链，与netfilter子系统的扩展点一一对应，分别是：INPUT、OUTPUT、PREROUTING、FORWARD、POSTROUTING；根据上面对netfilter的扩展点的功能解释，防火墙规则一般只工作在INPUT/OUTPUT/FORWARD三个扩展点，而我们是要限制访问本机运行的服务，而INPUT点专门负责入站检测规则，所以选择了INPUT点；所以说我们要先了解netfilter子系统的五个点才能更好地使用iptables；</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  -t</span><br></pre></td></tr></table></figure>指定当前命令操作所属的表，主要有：- filter表，主要用于拦截或放行，不修改包；如果不指定，则默认为filter表- nat表，主要用于修改IP包的源/目标地址- mangle表，主要用于给数据包打标记- raw表，没用过不知道干什么的哈哈- security表，没用过</code></pre></li><li><p>&#96;&#96;&#96;<br>-s</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">是数据包的匹配规则，配置规则可以一个或多个，多个是与的效果，这里</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>-s</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  是匹配来源IP的意思，还有其它：</span><br><span class="line"></span><br><span class="line">  - `-d`是匹配目标IP</span><br><span class="line">  - `--sport`是匹配来源端口</span><br><span class="line">  - `--dport`是匹配目标端口</span><br><span class="line">  - `-p tcp`是匹配协议类型</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  -j DROP</span><br></pre></td></tr></table></figure><p>是执行的动作，这里是跳转到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP</span><br></pre></td></tr></table></figure><p>链，iptables有几个预定义的链：</p><ul><li><code>DROP</code>丢弃进入该链的包</li><li><code>ACCEPT</code>接受进入该链的包</li><li><code>RETURN</code>返回上一级链</li><li><code>SNAT</code>源地址转换，要指定转换后的源地址，下面会有示例</li><li><code>DNAT</code>目标地址转换，要指定转换后目标地址</li><li><code>MASQUERADE</code>对进入该链的包进行源地址转换，与SNAT类似，但不用指定具体的转换后的源地址，会自动应用发送网卡的地址作为源地址，通常都用这条链完成SNAT</li></ul></li></ul><p>再来看几个iptables的命令：</p><ul><li>把本机应用发往10.96.0.100的数据包的目标地址换成10.244.3.10上，注意是要影响本机应用，所以用的是OUTPUT链（注意图3），clusterIP主要就是使用下面的这条规则完成：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A <span class="variable constant_">OUTPUT</span> -t nat -d <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span> -j <span class="variable constant_">DNAT</span> --to-distination <span class="number">10.244</span><span class="number">.3</span><span class="number">.10</span></span><br></pre></td></tr></table></figure><p>复制</p><ul><li>上面的规则只对本机的应用程序发送的流量有影响，对于本机的pod发出的流量没有影响，如果要影响本机的pod，还要再加一条，规则都一样，就是工作在PREROUTING链（注意图4）：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A <span class="variable constant_">PREROUTING</span> -t nat -d <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span> -j <span class="variable constant_">DNAT</span> --to-distination <span class="number">10.244</span><span class="number">.3</span><span class="number">.10</span></span><br></pre></td></tr></table></figure><p>复制</p><ul><li>对本机发送的数据包中来源IP为172.20.1.10的数据包进行源地址伪装，注意修改源地址只有一个点可以用，就是POSTROUTING，下面的规则就是配置pod上外网时使用的：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A <span class="variable constant_">POSTROUTING</span> -t nat -s <span class="number">172.20</span><span class="number">.1</span><span class="number">.10</span> -j <span class="variable constant_">MASQUERADE</span></span><br></pre></td></tr></table></figure><p>复制</p><ul><li>允许来源IP为192.168.6.166并访问本机的TCP80端口：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A <span class="variable constant_">INPUT</span> -t filter -s <span class="number">192.168</span><span class="number">.8</span><span class="number">.166</span> -p tcp --dport <span class="number">80</span> -j <span class="variable constant_">ACCEPT</span></span><br></pre></td></tr></table></figure><p>复制</p><p>为了使数据包能够尽量正常地处理与转发，iptables上的规则创建会有一些限制，例如我们不能在POSTROUTING链上创建DNAT的规则，因为在POSTROUTING之前，数据包要进行路由判决，内核会根据当前的目的地选择一个最合适的出口，而POSTROUTING链的规则是在路由判决后发生，在这里再修改数据包的目的地，会造成数据包不可到达的后果，所以当我们用iptables执行如下命令时：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iptables -A <span class="variable constant_">POSTROUTING</span> -t nat -d <span class="number">192.168</span><span class="number">.8</span><span class="number">.163</span> -j <span class="variable constant_">DNAT</span> --to-distination <span class="number">192.168</span><span class="number">.8</span><span class="number">.162</span></span><br><span class="line"></span><br><span class="line"><span class="attr">iptables</span>:<span class="title class_">Invalid</span> argument. <span class="title class_">Run</span> <span class="string">`dmesg`</span> <span class="keyword">for</span> more information.</span><br><span class="line"></span><br><span class="line">##执行dmesg命令会看到iptables提示：<span class="variable constant_">DNAT</span>模块只能在<span class="variable constant_">PREROUTING</span>或<span class="variable constant_">OUTPUT</span>链中使用</span><br><span class="line">##<span class="attr">x_tables</span>:<span class="attr">iptables</span>:<span class="variable constant_">DNAT</span> <span class="attr">target</span>:used <span class="keyword">from</span> hooks <span class="variable constant_">POSTROUTING</span>,but only usable <span class="keyword">from</span> <span class="variable constant_">PREROUTING</span>/<span class="variable constant_">OUTPUT</span></span><br></pre></td></tr></table></figure><p>复制</p><p>简单了解iptables后，我们再来看看为什么k8s会设计service这个东西。</p><h2 id="为什么k8s会设计service"><a href="#为什么k8s会设计service" class="headerlink" title="为什么k8s会设计service"></a>为什么k8s会设计service</h2><p>主要是因为下面两个原因：</p><ul><li>pod的特性是快速创建快速销毁，所以pod的IP是不固定的，要让调用方有个固定依赖，所以需要一个VIP出来代表一个服务</li></ul><blockquote><p>pod的IP为什么不固定？一般的cni给pod分配IP时都是一个集群节点占用一个24位子网（就是NODE-CIDR，通常我们会在安装k8s集群时指定一个POD-CIDR，例如：10.244.0.0&#x2F;16，然后k8s会给每一个集群节点分配一个24位的子网，例如：10.244.2.0&#x2F;24，然后所有10.244.2开头的POD都是在这个节点上运行的），podIP固定就意味着pod必须在一个固定的k8s集群节点，如果那个节点挂了，那pod就永远起不来了，这与k8s的设计相悖，k8s是要应用不要依赖具体的硬件资源； 当然也不是说pod的IP就一定不能固定，这要看具体的cni而言，比如flannel就是上面说的那种情况，但也有能实现的，比如我们自研的mustang，就实现了有状态应用的固定IP，一个POD多网卡等（广告一波）</p></blockquote><ul><li>一般来说为了追求应用的高可用，一个应用会部署多个pod，这时需要一个VIP充当多个pod的流量<a href="https://cloud.tencent.com/product/clb?from=10680">负载均衡</a>器</li></ul><h2 id="service的几种类型分别有什么使用场景"><a href="#service的几种类型分别有什么使用场景" class="headerlink" title="service的几种类型分别有什么使用场景"></a>service的几种类型分别有什么使用场景</h2><ul><li><em><strong>clusterIP</strong></em>：只能在集群的节点和pod中访问，解决的就是集群内应用间的相互访问的问题；</li><li><em><strong>nodeport</strong></em>：通过节点的地址和端口把pod暴露到集群外，让集群外的应用能访问集群内的应用，设置服务类型为nodeport时，是在clusterIP的基础上再给节点开个端口转发（是特定节点还是每一个节点要看externalTrafficPolicy的值，Cluster是每一个节点都开，Local是只在pod运行的节点开），所以nodeport的服务也会有一个clusterIP</li><li><em><strong>loadBalancer</strong></em>：因为使用nodeport方式时，免不了要在应用的调用方写死一个集群节点的IP，这并非高可用的方式，所以又有了使用第三方<a href="https://cloud.tencent.com/product/clb?from=10680">负载均衡器</a>的方式，转发到多个节点的nodeport，这种类型通常需要用户扩展个控制器与云平台或所属IDC机房的负载均衡器打通才能生效，普通安装的k8s集群一般类型为loadBalancer的服务都是pending状态；loadBalancer是在nodeport的基础之上再创建个lb，所以也是会先分配一个clusterIP，再创建节点的端口转发。</li><li><em><strong>headless</strong></em>：应用内多个副本彼此间互相访问，比如要部署到mysql的主从，从的副本想要找主的副本；</li><li><em><strong>externalName</strong></em>：其实只是相当于dns的cname记录</li></ul><p>了解这些以后，我们试着用iptables模拟一个k8s的service吧，我们会在一个节点创建两个pod，分别叫pod-a、pod-b，然后学iptables模拟一个VIP，这个VIP会把流量转给pod-b，最后试着在节点和pod-a中使用这个VIP访问pod-b，最后再试试在pod-b中用VIP访问自身会是什么情况，以此来解释hairpin flow的场景</p><h2 id="先在主机创建两个pod"><a href="#先在主机创建两个pod" class="headerlink" title="先在主机创建两个pod"></a>先在主机创建两个pod</h2><p>在我们测试的主机上创建两个pod，pod与主机连接的配置过程我们上一章已经介绍过，这里我们就直接上命令，不再一一解释：</p><ol><li>创建pod-a（10.244.1.10）</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ip netns add pod-a</span><br><span class="line">ip link add eth0 type veth peer name veth-pod-a  </span><br><span class="line">ip link set eth0 netns pod-a  </span><br><span class="line">ip link set veth-pod-a up </span><br><span class="line">ip netns exec pod-a ip addr add <span class="number">10.244</span><span class="number">.1</span><span class="number">.10</span>/<span class="number">24</span> dev eth0 </span><br><span class="line">ip netns exec pod-a ip link set eth0 up </span><br><span class="line"></span><br><span class="line">ip netns exec pod-a ip route add <span class="keyword">default</span> via <span class="number">169.254</span><span class="number">.10</span><span class="number">.24</span> dev eth0 onlink</span><br><span class="line">echo <span class="number">1</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/conf/veth-pod-a/proxy_arp</span><br><span class="line">ip route add <span class="number">10.244</span><span class="number">.1</span><span class="number">.10</span> dev veth-pod-a</span><br></pre></td></tr></table></figure><p>复制</p><ol><li>创建pod-b（10.244.1.11）</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ip netns add pod-b</span><br><span class="line">ip link add eth0 type veth peer name veth-pod-b  </span><br><span class="line">ip link set eth0 netns pod-b  </span><br><span class="line">ip link set veth-pod-b up </span><br><span class="line">ip netns exec pod-b ip addr add <span class="number">10.244</span><span class="number">.1</span><span class="number">.11</span>/<span class="number">24</span> dev eth0 </span><br><span class="line">ip netns exec pod-b ip link set eth0 up </span><br><span class="line"></span><br><span class="line">ip netns exec pod-b ip route add <span class="keyword">default</span> via <span class="number">169.254</span><span class="number">.10</span><span class="number">.24</span> dev eth0 onlink</span><br><span class="line">echo <span class="number">1</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/conf/veth-pod-b/proxy_arp</span><br><span class="line">ip route add <span class="number">10.244</span><span class="number">.1</span><span class="number">.11</span> dev veth-pod-b</span><br></pre></td></tr></table></figure><p>复制</p><p>为了确保两个pod能ping通，还需要：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">1</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/ip_forward</span><br><span class="line">iptables -I <span class="variable constant_">FORWARD</span> -s <span class="number">10.244</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">16</span> -d <span class="number">10.244</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">16</span> -j <span class="variable constant_">ACCEPT</span> </span><br></pre></td></tr></table></figure><p>复制</p><p>如无意外，应该可以在pod-a中ping通pod-b了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec pod-a ping -c <span class="number">5</span> <span class="number">10.244</span><span class="number">.1</span><span class="number">.11</span></span><br><span class="line"></span><br><span class="line"><span class="variable constant_">PING</span> <span class="number">10.244</span><span class="number">.1</span><span class="number">.11</span> (<span class="number">10.244</span><span class="number">.1</span><span class="number">.11</span>) <span class="number">56</span>(<span class="number">84</span>) bytes <span class="keyword">of</span> data.</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">10.244</span><span class="number">.1</span><span class="number">.11</span>: icmp_seq=<span class="number">1</span> ttl=<span class="number">63</span> time=<span class="number">0.090</span> ms</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">10.244</span><span class="number">.1</span><span class="number">.11</span>: icmp_seq=<span class="number">2</span> ttl=<span class="number">63</span> time=<span class="number">0.081</span> ms</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">10.244</span><span class="number">.1</span><span class="number">.11</span>: icmp_seq=<span class="number">3</span> ttl=<span class="number">63</span> time=<span class="number">0.062</span> ms</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">10.244</span><span class="number">.1</span><span class="number">.11</span>: icmp_seq=<span class="number">4</span> ttl=<span class="number">63</span> time=<span class="number">0.062</span> ms</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">10.244</span><span class="number">.1</span><span class="number">.11</span>: icmp_seq=<span class="number">5</span> ttl=<span class="number">63</span> time=<span class="number">0.054</span> ms</span><br><span class="line">--- <span class="number">10.244</span><span class="number">.1</span><span class="number">.11</span> ping statistics ---</span><br><span class="line"><span class="number">5</span> packets transmitted, <span class="number">5</span> received, <span class="number">0</span>% packet loss, time 136ms</span><br><span class="line">rtt min/avg/max/mdev = <span class="number">0.054</span>/<span class="number">0.069</span>/<span class="number">0.090</span>/<span class="number">0.017</span> ms</span><br></pre></td></tr></table></figure><p>复制</p><p>我们用iptables搞起来！</p><h2 id="用iptables模拟实现k8s服务"><a href="#用iptables模拟实现k8s服务" class="headerlink" title="用iptables模拟实现k8s服务"></a>用iptables模拟实现k8s服务</h2><h3 id="模拟cluterIP"><a href="#模拟cluterIP" class="headerlink" title="模拟cluterIP"></a>模拟cluterIP</h3><p>用iptables模拟VIP：10.96.0.100，并把流量转到pod-b，命令如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A <span class="variable constant_">PREROUTING</span> -t nat -d <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span> -j <span class="variable constant_">DNAT</span> --to-destination <span class="number">10.244</span><span class="number">.1</span><span class="number">.11</span></span><br></pre></td></tr></table></figure><p>复制</p><p>好了，可以跑去pod-a中试试用clusterIP去ping一下pod-b了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec pod-a ping -c <span class="number">5</span> <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span></span><br><span class="line"></span><br><span class="line"><span class="variable constant_">PING</span> <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span> (<span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span>) <span class="number">56</span>(<span class="number">84</span>) bytes <span class="keyword">of</span> data.</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span>: icmp_seq=<span class="number">1</span> ttl=<span class="number">63</span> time=<span class="number">0.112</span> ms</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span>: icmp_seq=<span class="number">2</span> ttl=<span class="number">63</span> time=<span class="number">0.084</span> ms</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span>: icmp_seq=<span class="number">3</span> ttl=<span class="number">63</span> time=<span class="number">0.064</span> ms</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span>: icmp_seq=<span class="number">4</span> ttl=<span class="number">63</span> time=<span class="number">0.084</span> ms</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span>: icmp_seq=<span class="number">5</span> ttl=<span class="number">63</span> time=<span class="number">0.054</span> ms</span><br><span class="line">--- <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span> ping statistics ---</span><br><span class="line"><span class="number">5</span> packets transmitted, <span class="number">5</span> received, <span class="number">0</span>% packet loss, time 135ms</span><br><span class="line">rtt min/avg/max/mdev = <span class="number">0.054</span>/<span class="number">0.079</span>/<span class="number">0.112</span>/<span class="number">0.022</span> ms</span><br></pre></td></tr></table></figure><p>复制</p><blockquote><p>咦？在iptables模式下，clusterIP都是ping不通的啊？其实只是kube-proxy在实现时只根据ip+端口+协议精确匹配才转发，这才导致clusterIP不能ping，我们上面只是IP匹配，所以icmp协议也会正常转，当然也就可以ping得通了。</p></blockquote><p>这个时候在测试主机上用clusterIP能ping通pod-b吗？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ping -c <span class="number">5</span> <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span></span><br><span class="line"></span><br><span class="line"><span class="variable constant_">PING</span> <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span> (<span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span>) <span class="number">56</span>(<span class="number">84</span>) bytes <span class="keyword">of</span> data.</span><br><span class="line">--- <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span> ping statistics ---</span><br><span class="line"><span class="number">5</span> packets transmitted, <span class="number">0</span> received, <span class="number">100</span>% packet loss, time 133ms</span><br></pre></td></tr></table></figure><p>复制</p><p>答案是不行？为什么呢？回忆一下上面提过的netfilter流程，本机应用程序的包出去时只比过OUTPUT和POSTROUTING（注意图2），而我们刚刚的命令只在PREROUTING上生效，为了测试主机也能访问clusterIP，还要再增加一条规则：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A <span class="variable constant_">OUTPUT</span> -t nat -d <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span> -j <span class="variable constant_">DNAT</span> --to-destination <span class="number">10.244</span><span class="number">.1</span><span class="number">.11</span></span><br></pre></td></tr></table></figure><p>复制</p><p>然后在测试主机上也可以ping通了</p><h3 id="hairpin-flow"><a href="#hairpin-flow" class="headerlink" title="hairpin flow"></a>hairpin flow</h3><p>如果在pod-b中用clusterIP去ping它自己呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec pod-b ping -c <span class="number">5</span> <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span></span><br><span class="line"></span><br><span class="line"><span class="variable constant_">PING</span> <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span> (<span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span>) <span class="number">56</span>(<span class="number">84</span>) bytes <span class="keyword">of</span> data.</span><br><span class="line">--- <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span> ping statistics ---</span><br><span class="line"><span class="number">5</span> packets transmitted, <span class="number">0</span> received, <span class="number">100</span>% packet loss, time 129ms</span><br></pre></td></tr></table></figure><p>复制</p><p>不通，因为从pod-b出来的数据包，经过目标地址转换后，又回到了pod-b，这时来源IP也是pod-b，pod-b的的eth0网卡一般会有一个开关：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec pod-b bash ## 进入pod-b的ns中运行bash</span><br><span class="line">sysctl net.<span class="property">ipv4</span>.<span class="property">conf</span>.<span class="property">eth0</span>.<span class="property">accept_local</span>  ## 显示的结果是：net.<span class="property">ipv4</span>.<span class="property">conf</span>.<span class="property">eth0</span>.<span class="property">accept_local</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>复制</p><p>这个开关指示是否允许eth0网卡接收源IP为本机IP的数据包，默认是不允许，于是内核协议栈会把这个包丢掉，所以就不通了；</p><p>为了能ping通，我们需要让进入pod-b的数据包的源IP转换成非pod-b的IP，就是说我们要在netfilter流程中对数据包做一次源地址转换，iptables中能做SNAT的点只有一个，就是POSTROUTING，于是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A <span class="variable constant_">POSTROUTING</span> -t nat -d <span class="number">10.244</span><span class="number">.1</span><span class="number">.11</span> -s <span class="number">10.244</span><span class="number">.1</span><span class="number">.11</span> -j <span class="variable constant_">MASQUERADE</span></span><br></pre></td></tr></table></figure><p>复制</p><p>经过上面的命令配置后，在pod-b中也能用vip ping自身了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec pod-b ping -c <span class="number">5</span> <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span></span><br><span class="line"></span><br><span class="line"><span class="variable constant_">PING</span> <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span> (<span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span>) <span class="number">56</span>(<span class="number">84</span>) bytes <span class="keyword">of</span> data.</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span>: icmp_seq=<span class="number">1</span> ttl=<span class="number">63</span> time=<span class="number">0.059</span> ms</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span>: icmp_seq=<span class="number">2</span> ttl=<span class="number">63</span> time=<span class="number">0.081</span> ms</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span>: icmp_seq=<span class="number">3</span> ttl=<span class="number">63</span> time=<span class="number">0.068</span> ms</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span>: icmp_seq=<span class="number">4</span> ttl=<span class="number">63</span> time=<span class="number">0.082</span> ms</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span>: icmp_seq=<span class="number">5</span> ttl=<span class="number">63</span> time=<span class="number">0.065</span> ms</span><br><span class="line">--- <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span> ping statistics ---</span><br><span class="line"><span class="number">5</span> packets transmitted, <span class="number">5</span> received, <span class="number">0</span>% packet loss, time 82ms</span><br><span class="line">rtt min/avg/max/mdev = <span class="number">0.059</span>/<span class="number">0.071</span>/<span class="number">0.082</span>/<span class="number">0.009</span> ms</span><br></pre></td></tr></table></figure><p>复制</p><p><em><strong>这就是我们说的hairpin flow的场景：pod通过clusterIP访问自已</strong></em></p><h3 id="k8s中kube-proxy中如何用iptables处理hairpin-flow场景？"><a href="#k8s中kube-proxy中如何用iptables处理hairpin-flow场景？" class="headerlink" title="k8s中kube-proxy中如何用iptables处理hairpin flow场景？"></a>k8s中kube-proxy中如何用iptables处理hairpin flow场景？</h3><p>在使用iptables实现service的k8s集群的节点上，截取一段iptables规则：（用iptables-save命令，为了显示简洁均把注释省略，链的名称也简化为-1后缀了）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-A <span class="variable constant_">PREROUTING</span>  -j <span class="variable constant_">KUBE</span>-<span class="variable constant_">SERVICES</span>  ##基操，就像上面例子一样，接管从pod过来的流量</span><br><span class="line">-A <span class="variable constant_">OUTPUT</span>  -j <span class="variable constant_">KUBE</span>-<span class="variable constant_">SERVICES</span>      ##基操，就像上面例子一样，接管从主机应用出来的流量</span><br><span class="line"></span><br><span class="line">-A <span class="variable constant_">KUBE</span>-<span class="variable constant_">SERVICES</span> -d <span class="number">10.96</span><span class="number">.252</span><span class="number">.6</span>/<span class="number">32</span> -p tcp -m tcp --dport <span class="number">80</span> -j <span class="variable constant_">KUBE</span>-<span class="variable constant_">SVC</span>-<span class="number">1</span>  ##这是基操，每个服务都有一条这样的规则</span><br><span class="line"></span><br><span class="line">-A <span class="variable constant_">KUBE</span>-<span class="variable constant_">SVC</span>-<span class="number">1</span>  -j <span class="variable constant_">KUBE</span>-<span class="variable constant_">SEP</span>-<span class="number">1</span> ##这条链一开始看着感觉很多余，为什么不直接<span class="variable constant_">DNAT</span>呢？</span><br><span class="line"></span><br><span class="line">-A <span class="variable constant_">KUBE</span>-<span class="variable constant_">SEP</span>-<span class="number">1</span> -s <span class="number">10.90</span><span class="number">.2</span><span class="number">.233</span>/<span class="number">32</span>  -j <span class="variable constant_">KUBE</span>-<span class="variable constant_">MARK</span>-<span class="variable constant_">MASQ</span> ##把来源为自身的做了标记</span><br><span class="line">-A <span class="variable constant_">KUBE</span>-<span class="variable constant_">SEP</span>-<span class="number">1</span> -p tcp  -m tcp -j <span class="variable constant_">DNAT</span> --to-destination <span class="number">10.90</span><span class="number">.2</span><span class="number">.233</span>:<span class="number">80</span> ##这也是基操</span><br></pre></td></tr></table></figure><p>复制</p><p>上面显示的规则中第4条，为什么不直接转给最后一条，而是在中间加一个来源地址为自身时跳到<code>KUBE-MARK-MASQ</code>？</p><p>来看看<code>KUBE-MARK-MASQ</code>是干什么的？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A <span class="variable constant_">KUBE</span>-<span class="variable constant_">MARK</span>-<span class="variable constant_">MASQ</span> -j <span class="variable constant_">MARK</span> --set-xmark <span class="number">0x4000</span>/<span class="number">0x4000</span></span><br></pre></td></tr></table></figure><p>复制</p><p>先是标记了一下，然后在POSTROUTING的点进行了源地址转换：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A <span class="variable constant_">KUBE</span>-<span class="variable constant_">POSTROUTING</span> -m mark --mark <span class="number">0x4000</span>/<span class="number">0x4000</span> -j <span class="variable constant_">MASQUERADE</span></span><br></pre></td></tr></table></figure><p>复制</p><p>在PREROUTING点中先标记一下，这是hairpin场景的流量（因为PREROUTING中还不能做SNAT，所以只能先记下），然后在POSTROUTING点中再对标记过的流量进行SNAT，这一系列的操作其实就是为了实现上面的hairpin的场景</p><h3 id="模拟NodePort"><a href="#模拟NodePort" class="headerlink" title="模拟NodePort"></a>模拟NodePort</h3><p>因为是具体到IP+端口了，所以也只能转到IP+端口，所以不能用ping来验证了，下面模拟把访问主机的tcp33888端口的流量都转给pod-b的80端口：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A <span class="variable constant_">OUTPUT</span> -t nat -m addrtype --dst-type <span class="variable constant_">LOCAL</span> -m tcp -p tcp --dport <span class="number">33888</span> -j <span class="variable constant_">DNAT</span> --to-destination <span class="number">10.244</span><span class="number">.1</span><span class="number">.11</span>:<span class="number">80</span></span><br><span class="line">iptables -A <span class="variable constant_">PREROUTING</span> -t nat -m addrtype --dst-type <span class="variable constant_">LOCAL</span> -m tcp -p tcp --dport <span class="number">33888</span> -j <span class="variable constant_">DNAT</span> --to-destination <span class="number">10.244</span><span class="number">.1</span><span class="number">.11</span>:<span class="number">80</span></span><br></pre></td></tr></table></figure><p>复制</p><blockquote><p>上面因为我们要接管两个点的流量，所以配置两条规则，实际的k8s的kube-proxy在实现时会设计更加合理的链来避免规则大量重复定义，上面只是为了演示效果</p></blockquote><p><code>-m addrtype --dst-type LOCAL</code>的意思是匹配主机所有IP（笔者使用的主机用vbox虚拟的虚拟机，有两个IP，192.168.6.160和10.0.2.15）验证之前，先在pod-b启动一个socat服务监听80端口，这个服务会把把收到的内容原样返回</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec pod-b nohup socat <span class="title class_">TCP4</span>-<span class="attr">LISTEN</span>:<span class="number">80</span>,fork <span class="attr">exec</span>:cat <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;   </span><br></pre></td></tr></table></figure><p>复制</p><p>接着在主机上用nc访问：（笔者的主机IP为：192.168.6.160）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nc <span class="number">192.168</span><span class="number">.6</span><span class="number">.160</span> <span class="number">33888</span>   ## 或者 nc <span class="number">10.0</span><span class="number">.2</span><span class="number">.15</span> <span class="number">33888</span> 也是可以的</span><br><span class="line">hello ##这是我发送的内容</span><br><span class="line">hello ##这是服务返回的内容，符合预期</span><br></pre></td></tr></table></figure><p>复制</p><p>在pod-a中验证：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec pod-a nc <span class="number">10.0</span><span class="number">.2</span><span class="number">.15</span> <span class="number">33888</span></span><br><span class="line">hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>复制</p><blockquote><p>然后nodeport下的hairpin flow的处理方式和clusterIP是一样的，甚至其实是上到同一条链上去处理的</p></blockquote><h2 id="一些误解"><a href="#一些误解" class="headerlink" title="一些误解"></a>一些误解</h2><ol><li>相对于直接访问podIP，使用clusterIP来访问因为多一次转发，会慢一些；<ul><li>其实只是在发送的过程中修改了数据包的目标地址，两者走的转发路径是一模一样的，没有因为使用clusterIP而多一跳，当然因为要做nat会有一些些影响，但影响不大</li></ul></li><li>使用nodeport因为比clusterIP又多一次转发，所以更慢；<ul><li>没有，nodeport是一次直接就转成了podIP，并没有先转成clusterIP再转成podIP。</li></ul></li></ol><h2 id="为什么NetworkPolicy不用限制serviceIP却又能生效？"><a href="#为什么NetworkPolicy不用限制serviceIP却又能生效？" class="headerlink" title="为什么NetworkPolicy不用限制serviceIP却又能生效？"></a>为什么NetworkPolicy不用限制serviceIP却又能生效？</h2><p>我们用NetworkPolicy限制不允许pod-a使用pod-b的IP访问pod-b，但没有限制pod-a用clusterIP访问pod-b，怎么用clusterIP也访问不了pod-b呢？</p><p>因为：</p><ul><li>在pod中使用clusterIP访问另一个pod时，防火墙策略的应用是在所在主机的FORWARD点，而把clusterIP转成podIP是在之前的PREROUTING点就完成了</li><li>在主机中使用clusterIP访问一个pod时，防火墙策略的应用是在主机的OUTPUT点，而把clusterIP转成podIP也是在OUTPUT点，不过在防火墙策略之前</li></ul><p>*<strong>所以防火墙策略其实从来都不会遇到clusterIP，因为在到达防火墙策略前，clusterIP都已经被转成podIP了，所以我们的网络策略只需要专心限制podIP即可*</strong></p><h2 id="留两个问题"><a href="#留两个问题" class="headerlink" title="留两个问题"></a>留两个问题</h2><ol><li>使用ipvs模式时，k8s集群的每个节点会有一张叫kube-ipvs0的网卡，网卡下挂着所有的clusterIP，有什么作用？</li><li>下面这条iptables规则到底有什么作用？</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A <span class="variable constant_">KUBE</span>-<span class="variable constant_">FORWARD</span> -m conntrack --ctstate <span class="variable constant_">RELATED</span>,<span class="variable constant_">ESTABLISHED</span> -j <span class="variable constant_">ACCEPT</span></span><br></pre></td></tr></table></figure><p>复制</p><p>下一章我们会专门介绍跨节点pod通信的几种方式</p>]]></content>
      
      
      <categories>
          
          <category> k8s网络原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> k8s网络原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解kubernetes（k8s）网络原理之三-跨主机pod连接</title>
      <link href="/2022/12/17/k8s%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E5%8E%9F%E7%90%863/"/>
      <url>/2022/12/17/k8s%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E5%8E%9F%E7%90%863/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>此文章转载于<a href="https://cloud.tencent.com/developer/inventory/21543/article/1870244,%E6%88%91%E8%A7%89%E5%BE%97%E5%86%99%E5%BE%97%E9%9D%9E%E5%B8%B8%E5%A5%BD,%E6%80%95%E4%BB%96%E5%93%AA%E5%A4%A9%E4%B8%8D%E8%A7%81%E4%BA%86,%E5%B0%B1%E8%AE%B0%E5%BD%95%E4%B8%8B%E6%9D%A5%E4%BA%86">https://cloud.tencent.com/developer/inventory/21543/article/1870244,我觉得写得非常好,怕他哪天不见了,就记录下来了</a></p></blockquote><p>在之前的两篇文章中分别介绍了pod与主机连接并且上外网的原理及service的clusterIP和nodeport的实现原理，对于组织pod的网络这件事来说，还有最后一环需要打通，就是分布在不同集群节点的pod之间如何相互通信，本章我们来解决这最后一环的问题</p><blockquote><p>在这里我们继续用linux network namespace(ns)代表pod</p></blockquote><p>我们将用下面三种方式实现跨主机的pod通信：</p><ol><li>主机路由</li><li>ip tunnel</li><li>vxlan</li></ol><p>我准备了两台节点：</p><ul><li>host1（ip:10.57.4.20）</li><li>host2（ip:10.57.4.21）</li></ul><p>先在两台节点中分别创建一个pod，并与节点能相互通信，创建pod并与节点通信的相关原理在第一章已经介绍过，这里不再一一解释，直接上命令：</p><ul><li>host1中创建pod-a（ip:192.168.10.10）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ip netns add pod-a</span><br><span class="line">ip link add eth0 type veth peer name veth-pod-a</span><br><span class="line">ip link set eth0 netns pod-a</span><br><span class="line">ip netns exec pod-a ip addr add <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span>/<span class="number">24</span> dev eth0</span><br><span class="line">ip netns exec pod-a ip link set eth0 up</span><br><span class="line">ip netns exec pod-a ip route add <span class="keyword">default</span> via <span class="number">169.254</span><span class="number">.10</span><span class="number">.24</span> dev eth0 onlink</span><br><span class="line">ip link set veth-pod-a up</span><br><span class="line">echo <span class="number">1</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/conf/veth-pod-a/proxy_arp</span><br><span class="line">echo <span class="number">1</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/ip_forward</span><br><span class="line">iptables -I <span class="variable constant_">FORWARD</span> -s <span class="number">192.168</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">16</span> -d <span class="number">192.168</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">16</span> -j <span class="variable constant_">ACCEPT</span></span><br><span class="line">ip route add <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span> dev veth-pod-a scope link</span><br></pre></td></tr></table></figure><p>复制</p><ul><li>host2上创建pod-b（ip:192.168.11.10）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ip netns add pod-b</span><br><span class="line">ip link add eth0 type veth peer name veth-pod-b</span><br><span class="line">ip link set eth0 netns pod-b</span><br><span class="line">ip netns exec pod-b ip addr add <span class="number">192.168</span><span class="number">.11</span><span class="number">.10</span>/<span class="number">24</span> dev eth0</span><br><span class="line">ip netns exec pod-b ip link set eth0 up</span><br><span class="line">ip netns exec pod-b ip route add <span class="keyword">default</span> via <span class="number">169.254</span><span class="number">.10</span><span class="number">.24</span> dev eth0 onlink</span><br><span class="line">ip link set veth-pod-b up</span><br><span class="line">echo <span class="number">1</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/conf/veth-pod-b/proxy_arp</span><br><span class="line">echo <span class="number">1</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/ip_forward</span><br><span class="line">iptables -I <span class="variable constant_">FORWARD</span> -s <span class="number">192.168</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">16</span> -d <span class="number">192.168</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">16</span> -j <span class="variable constant_">ACCEPT</span></span><br><span class="line">ip route add <span class="number">192.168</span><span class="number">.11</span><span class="number">.10</span> dev veth-pod-b scope link</span><br></pre></td></tr></table></figure><p>复制</p><p>如无意外，host1应该能ping通pod-a，host2也能ping通pod-b了，环境准备完成，下面我们介绍主机路由模式，这是flannel的host-gw模式的原理。</p><h2 id="主机路由"><a href="#主机路由" class="headerlink" title="主机路由"></a>主机路由</h2><p>其实每一台linux主机本身就是一台路由器，可以用ip route命令配置主机上的路由表，要让pod-a和pod-b相互通信，只需要在两台主机上加一条路由即可：</p><ul><li>host1:</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip route add <span class="number">192.168</span><span class="number">.11</span><span class="number">.0</span>/<span class="number">24</span> via <span class="number">10.57</span><span class="number">.4</span><span class="number">.21</span> dev eth0 onlink </span><br><span class="line">##这个eth0是host1连接host2的网卡，要根据你的测试节点的情况调整</span><br></pre></td></tr></table></figure><p>复制</p><ul><li>host2:</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip route add <span class="number">192.168</span><span class="number">.10</span><span class="number">.0</span>/<span class="number">24</span> via <span class="number">10.57</span><span class="number">.4</span><span class="number">.20</span> dev eth0 onlink </span><br><span class="line">##这个eth0是host2连接host1的网卡，要根据你的测试节点的情况调整</span><br></pre></td></tr></table></figure><p>复制</p><blockquote><p>注意上面我们加的路由是针对24位网络地址相同的子网段的，一般来说k8s集群的每个节点会独占一个24位的网络地址的子网段，所以每增加一个集群节点，其它节点加一条路由就可以了，但如果不是这样设计，像之前提过的pod要固定IP，又想要能在整个集群的任意节点运行，这个主机路由条目就会比较多，因为每条路由都是针对单个pod的</p></blockquote><p>此时在pod-a中去ping pod-b应该是通了的，假设在pod-b的8080端口运行着一个http服务，在pod-a中请求这个服务，在主机路由的模式下，host1发往host2的数据包是长这样的：</p><p><img src="/2022/12/17/k8s%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E5%8E%9F%E7%90%863/../img/%E5%8E%9F%E7%90%86%E4%B8%89assets/1620.jpeg" alt="img"></p><p>图一：主机路由</p><p>注意图中的源IP和目标IP是<a href="https://cloud.tencent.com/product/tke?from=10680">容器</a>的，但MAC地址却是主机的，我们在第一章中提到的linux网络知识的发送包的第5点说起过，数据包发送过程中，除非经过NAT，否则IP不会变化，始终标明通信双方，但MAC地址是每一段都会变化，数据包从pod-a到pod-b一共会经历三段：</p><ol><li>从pod-a发往host1时，源mac是pod-a的eth0网卡的mac，而目标mac是pod-a的默认网关（169.254.10.24）的mac，因为主机的veth-pod-a开启了arp代答，所以目标mac其实是主机上veth-pod-a的mac地址。</li><li>从host1去往host2的过程中，所以源MAC是host1的eth0网卡的mac，目标MAC是host2的eth0网卡的mac。</li><li>从host2发往pod-b，源mac是host2上veth-pod-b网卡的mac，目标mac是pod-b的eth0网卡mac</li></ol><p>这是跨节点容器通信方式中最简单高效的方式，没有封包拆包带来的额外消耗，但这种方式的使用场景有一些限制：</p><ul><li>集群节点必须在相同网段，因为主机路由的下一跳必须是二层可达的地址，如果在不同网段也想要使用非overlay的方式，那就需要把上面的路由信息同步到节点所在机房的路由器了，这就是calico BGP的方式  </li><li>云平台的虚拟机一般有源&#x2F;目地址检查，流量从虚拟机出来时，如果源IP或源MAC与虚拟机不符，则丢包；我们使用主机路由时，源MAC是虚拟机的，但源IP是pod的，所以就被丢包了；实在是想要在云平台使用主机路由的话：<ul><li>关闭“源&#x2F;目地址检查”（华为云），VPC路由表要加路由（阿里云、腾讯云）</li><li>ECS所属的安全组策略中要放开pod的网段</li></ul></li></ul><blockquote><p>云平台的虚拟机为什么要做源&#x2F;目地址检查呢？因为要防止IP spoofing</p></blockquote><p>因为以上限制，host-gw通常在idc机房且节点数不多都在同一子网的情况下使用，或者与别的模式混合使用，比如flannel的DirectRouting开启时，相同网段的用host-gw，跨网段用vxlan；</p><p>有没有节点跨网段也能使用的模式呢？接下来介绍的ip tunnel（就是常说的ipip模式）就是了。</p><h2 id="ip-tunnel（ipip）"><a href="#ip-tunnel（ipip）" class="headerlink" title="ip tunnel（ipip）"></a>ip tunnel（ipip）</h2><p>ipip模式并不是像主机路由那样，修改数据包的mac地址，而是在原ip包的前面再加一层ip包，然后链路层是以外层ip包的目标地址封装以太网帧头，而原来的那层ip包更像是被当成了外层包的数据，完成这个封包过程的是linux 虚拟网络设备tunnel网卡，它的工作原理是用节点路由表中匹配原ip包的路由信息中的下一跳地址为外层IP包的目标地址，以本节点的IP地址为源地址，再加一层IP包头，所以使用ip tunnel的模式下，我们需要做两件事情：</p><ul><li>在各个主机上建立一个one-to-many的ip tunnel，（所谓的one-to-many，就是创建ip tunnel设备时，不指定remote address，这样一个节点只需要一张tunnel网卡）</li><li>维护节点的路由信息，目标地址为集群的每一个的node-cidr，下一跳为node-cidr所在节点的IP，跟上面的主机路由很像，只不过出口网卡就不再是eth0了，而是新建的ip tunnel设备；</li></ul><p>我们接着上面的环境继续操作：</p><ul><li>首先删除上面使用主机路由时在两台主机上增加的路由条目</li></ul><p>host1:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route del <span class="number">192.168</span><span class="number">.11</span><span class="number">.0</span>/<span class="number">24</span> via <span class="number">10.57</span><span class="number">.4</span><span class="number">.21</span> dev eth0 onlink</span><br></pre></td></tr></table></figure><p>复制</p><p>host2:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route del <span class="number">192.168</span><span class="number">.10</span><span class="number">.0</span>/<span class="number">24</span> via <span class="number">10.57</span><span class="number">.4</span><span class="number">.20</span> dev eth0 onlink</span><br></pre></td></tr></table></figure><p>复制</p><ul><li>然后在两台主机上分别创建ip tunnel设备</li></ul><p>host1:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ip tunnel add mustang.<span class="property">tun0</span> mode ipip local <span class="number">10.57</span><span class="number">.4</span><span class="number">.20</span> ttl <span class="number">64</span></span><br><span class="line">ip link set mustang.<span class="property">tun0</span> mtu <span class="number">1480</span> ##因为多一层<span class="variable constant_">IP</span>头，占了<span class="number">20</span>个字节，所以<span class="variable constant_">MTU</span>也要相应地调整</span><br><span class="line">ip link set mustang.<span class="property">tun0</span> up</span><br><span class="line">ip route add <span class="number">192.168</span><span class="number">.11</span><span class="number">.0</span>/<span class="number">24</span> via <span class="number">10.57</span><span class="number">.4</span><span class="number">.21</span> dev mustang.<span class="property">tun0</span> onlink</span><br><span class="line">ip addr add <span class="number">192.168</span><span class="number">.10</span><span class="number">.1</span>/<span class="number">32</span> dev mustang.<span class="property">tun0</span> ## 这个地址是给主机请求跨节点的pod时使用的</span><br></pre></td></tr></table></figure><p>复制</p><p>host2:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ip tunnel add mustang.<span class="property">tun0</span> mode ipip local <span class="number">10.57</span><span class="number">.4</span><span class="number">.21</span> ttl <span class="number">64</span></span><br><span class="line">ip link set mustang.<span class="property">tun0</span> mtu <span class="number">1480</span></span><br><span class="line">ip link set mustang.<span class="property">tun0</span> up</span><br><span class="line">ip route add <span class="number">192.168</span><span class="number">.10</span><span class="number">.0</span>/<span class="number">24</span> via <span class="number">10.57</span><span class="number">.4</span><span class="number">.20</span> dev mustang.<span class="property">tun0</span> onlink</span><br><span class="line">ip addr add <span class="number">192.168</span><span class="number">.11</span><span class="number">.1</span>/<span class="number">32</span> dev mustang.<span class="property">tun0</span></span><br></pre></td></tr></table></figure><p>复制</p><p>这时候两个pod应该已经可以相互ping通了，还是假设pod-a请求pod-b的http服务，此时host1发往host2的数据包是长这样的：</p><p><img src="/2022/12/17/k8s%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E5%8E%9F%E7%90%863/../img/%E5%8E%9F%E7%90%86%E4%B8%89assets/1620-167128567598312.jpeg" alt="img"></p><p>图二：ipip</p><p>因为主机协议栈工作时是由下往上识别每一层包，所以ipip包对于主机协议栈而言，与正常主机间通信的包并没有什么不同，帧头中的源&#x2F;目标mac是主机的，ip包头中源&#x2F;目标ip也是节点的，这让节点所处的物理网络也感觉这是正常的节点流量，所以 这个模式相对于主机路由来说对环境的适应性更广，起码跨网段的节点也是可以通的，但是在云平台上使用这种模式还是要注意下，留意图二中外层IP包中的传输层协议号是不一样的（是IPPROTO_IPIP），正常的IP包头，这应该是TCP&#x2F;UDP&#x2F;ICMP，这样有可能也会被云平台的安全组策略拦截掉，在linux内核源码中可以看到：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//include/uapi/linux/in.h</span></span><br><span class="line"></span><br><span class="line">enum &#123;</span><br><span class="line">...</span><br><span class="line">  <span class="variable constant_">IPPROTO_ICMP</span> = <span class="number">1</span>,<span class="comment">/* Internet Control Message Protocol*/</span></span><br><span class="line">#define <span class="variable constant_">IPPROTO_ICMP</span><span class="variable constant_">IPPROTO_ICMP</span></span><br><span class="line"></span><br><span class="line">  <span class="variable constant_">IPPROTO_IPIP</span> = <span class="number">4</span>,<span class="comment">/* IPIP tunnels (older KA9Q tunnels use 94) */</span></span><br><span class="line">#define <span class="variable constant_">IPPROTO_IPIP</span><span class="variable constant_">IPPROTO_IPIP</span></span><br><span class="line"></span><br><span class="line">  <span class="variable constant_">IPPROTO_TCP</span> = <span class="number">6</span>,<span class="comment">/* Transmission Control Protocol*/</span></span><br><span class="line">#define <span class="variable constant_">IPPROTO_TCP</span><span class="variable constant_">IPPROTO_TCP</span></span><br><span class="line"></span><br><span class="line">  <span class="variable constant_">IPPROTO_UDP</span> = <span class="number">17</span>,<span class="comment">/* User Datagram Protocol*/</span></span><br><span class="line">#define <span class="variable constant_">IPPROTO_UDP</span><span class="variable constant_">IPPROTO_UDP</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>复制</p><p>一般而言我们在云平台安全组设置规则时，传输层协议都只有三个可选项，就是：TCP、UDP、ICMP（没有IPIP），所以最好是在云平台上把安全组内的主机间的所有协议都放开，会不会真的被拦截掉要看具体云平台，华为云是会限制的；</p><blockquote><p>笔者曾经试过在华为云上使用ipip模式，总会出现pod-a ping不通ping-b，卡着的时候，在pod-b上ping pod-a，然后两边就同时通了，这是典型的有状态防火墙的现象； 之后我们把集群节点都加入一个安全组，在安全组的规则配置中，把组内所有节点的所有端口所有协议都放开后，问题消失，说明默认对IPIP协议是没有放开的</p></blockquote><p>在host1中执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec pod-a ping -c <span class="number">5</span> <span class="number">192.168</span><span class="number">.11</span><span class="number">.10</span> </span><br></pre></td></tr></table></figure><p>复制</p><p>在host2的eth0用tcpdump打印一下流量，就能看到有两层ip头：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -n -i eth0|grep <span class="number">192.168</span><span class="number">.11</span><span class="number">.10</span></span><br><span class="line"></span><br><span class="line"><span class="attr">tcpdump</span>: verbose output suppressed, use -v or -vv <span class="keyword">for</span> full protocol decode</span><br><span class="line">listening on eth0, link-type <span class="title class_">EN10MB</span> (<span class="title class_">Ethernet</span>), capture size <span class="number">262144</span> bytes</span><br><span class="line"><span class="number">18</span>:<span class="number">03</span>:<span class="number">35.048106</span> <span class="variable constant_">IP</span> <span class="number">10.57</span><span class="number">.4</span><span class="number">.20</span> &gt; <span class="number">10.57</span><span class="number">.4</span><span class="number">.21</span>: <span class="variable constant_">IP</span> <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span> &gt; <span class="number">192.168</span><span class="number">.11</span><span class="number">.10</span>: <span class="variable constant_">ICMP</span> echo request, id <span class="number">3205</span>, seq <span class="number">1</span>, length <span class="number">64</span> (ipip-proto-<span class="number">4</span>)</span><br><span class="line"><span class="number">18</span>:<span class="number">03</span>:<span class="number">35.049483</span> <span class="variable constant_">IP</span> <span class="number">10.57</span><span class="number">.4</span><span class="number">.21</span> &gt; <span class="number">10.57</span><span class="number">.4</span><span class="number">.20</span>: <span class="variable constant_">IP</span> <span class="number">192.168</span><span class="number">.11</span><span class="number">.10</span> &gt; <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span>: <span class="variable constant_">ICMP</span> echo reply, id <span class="number">3205</span>, seq <span class="number">1</span>, length <span class="number">64</span> (ipip-proto-<span class="number">4</span>)</span><br><span class="line"><span class="number">18</span>:<span class="number">03</span>:<span class="number">36.049147</span> <span class="variable constant_">IP</span> <span class="number">10.57</span><span class="number">.4</span><span class="number">.20</span> &gt; <span class="number">10.57</span><span class="number">.4</span><span class="number">.21</span>: <span class="variable constant_">IP</span> <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span> &gt; <span class="number">192.168</span><span class="number">.11</span><span class="number">.10</span>: <span class="variable constant_">ICMP</span> echo request, id <span class="number">3205</span>, seq <span class="number">2</span>, length <span class="number">64</span> (ipip-proto-<span class="number">4</span>)</span><br><span class="line"><span class="number">18</span>:<span class="number">03</span>:<span class="number">36.049245</span> <span class="variable constant_">IP</span> <span class="number">10.57</span><span class="number">.4</span><span class="number">.21</span> &gt; <span class="number">10.57</span><span class="number">.4</span><span class="number">.20</span>: <span class="variable constant_">IP</span> <span class="number">192.168</span><span class="number">.11</span><span class="number">.10</span> &gt; <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span>: <span class="variable constant_">ICMP</span> echo reply, id <span class="number">3205</span>, seq <span class="number">2</span>, length <span class="number">64</span> (ipip-proto-<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>复制</p><p>calico的ipip模式就是这种，ip tunnel解决了主机路由不能在跨网段中使用的问题，在idc机房部署k8s集群的场景下，会拿host-gw和ipip两种模式混合使用，节点在相同网段则用host-gw，不同网段则用ipip，思路和flannel的directrouting差不多，只不过ipip比vxlan性能要好一些；</p><p>ip tunnel仍然有一些小小的限制，像上面说的云平台安全组对协议限制的问题，下面再介绍一种终极解决方案，只要节点网络是通的，容器就能通，完全没有限制，这就是vxlan模式；</p><h2 id="vxlan"><a href="#vxlan" class="headerlink" title="vxlan"></a>vxlan</h2><p>主机路由是按普通路由器的工作原理，每一跳修改MAC地址；ipip模式是给需要转发的数据包前面加一层IP包；而vxlan模式则是把pod的数据帧（注意这里是帧，就是包含二层帧头）封装在主机的UDP包的payload中，数据包封装的工作由linux虚拟网络设备vxlan完成，vxlan设备可以用下面的命令创建：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ip link add vxlan0 type vxlan id <span class="number">100</span> dstport <span class="number">4789</span> local <span class="number">10.57</span><span class="number">.4</span><span class="number">.20</span> dev eth0</span><br><span class="line">##设备名为vxlan0</span><br><span class="line">##vxlan id 为 <span class="number">100</span></span><br><span class="line">##dstport指示使用哪个udp端口</span><br><span class="line">##eth0指示封装好vxlan包后通过哪个主机网卡发送</span><br></pre></td></tr></table></figure><p>复制</p><p>vxlan设备在封包时是根据目标MAC地址来决定外层包的目标IP，所以需要主机提供目标MAC地址与所属节点IP的映射关系，这些映射关系存在主机的fdb表（forwarding database）中，fdb记录可以用下面的命令查看：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bridge fdb show|grep vxlan0</span><br><span class="line"></span><br><span class="line">8<span class="attr">a</span>:<span class="attr">e7</span>:<span class="attr">df</span>:<span class="attr">c0</span>:<span class="number">84</span>:<span class="number">07</span> dev vxlan0 dst <span class="number">10.57</span><span class="number">.4</span><span class="number">.21</span> self permanent</span><br></pre></td></tr></table></figure><p>复制</p><p>上面的记录的意思是说去往MAC地址为<code>8a:e7:df:c0:84:07</code>的pod在节点IP为<code>10.57.4.21</code>的节点上，fdb的信息可以手工维护，也可以让vxlan设备自动学习；</p><ul><li>手工添加一条fdb记录的命令如下：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bridge fdb append 8<span class="attr">a</span>:<span class="attr">e7</span>:<span class="attr">df</span>:<span class="attr">c0</span>:<span class="number">84</span>:<span class="number">07</span> dev vxlan0 dst <span class="number">10.57</span><span class="number">.4</span><span class="number">.21</span> self permanent</span><br></pre></td></tr></table></figure><p>复制</p><ul><li>如果需要让vxlan设备去学习fdb记录，可以创建vxlan设备时设置多播地址，并开启learning选项：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip link add vxlan0 type vxlan id <span class="number">100</span> dstport <span class="number">4789</span> group <span class="number">239.1</span><span class="number">.1</span><span class="number">.1</span> dev eth0 learning</span><br></pre></td></tr></table></figure><p>复制</p><p>所有集群的节点都加入这个多播组，这样就能自动学习fdb记录了，当然这需要底层网络支持多播；</p><ul><li>也可以通过增加全0的fdb记录来告诉vxlan设备遇到不知道下一跳的MAC应该向哪些节点广播：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bridge fdb append  <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> dev vxlan0 dst <span class="number">10.57</span><span class="number">.4</span><span class="number">.21</span> self permanent</span><br></pre></td></tr></table></figure><p>复制</p><p>我们接着上面的环境继续往下做，先把mustang.tun0删除，在两个节点上执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip link del mustang.<span class="property">tun0</span></span><br></pre></td></tr></table></figure><p>复制</p><p>然后</p><p>host1：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ip link add vxlan0 type vxlan id <span class="number">100</span> dstport <span class="number">4789</span> local <span class="number">10.57</span><span class="number">.4</span><span class="number">.20</span> dev eth0 learning  ## 这个eth0要根据你自己测试节点的网卡调整</span><br><span class="line">ip addr add <span class="number">192.168</span><span class="number">.10</span><span class="number">.1</span>/<span class="number">32</span> dev vxlan0</span><br><span class="line">ip link set vxlan0 up</span><br><span class="line">ip route add <span class="number">192.168</span><span class="number">.11</span><span class="number">.0</span>/<span class="number">24</span> via <span class="number">192.168</span><span class="number">.11</span><span class="number">.1</span> dev vxlan0 onlink</span><br><span class="line">bridge fdb append  <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> dev vxlan0 dst <span class="number">10.57</span><span class="number">.4</span><span class="number">.21</span> self permanent</span><br></pre></td></tr></table></figure><p>复制</p><p>host2：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ip link add vxlan0 type vxlan id <span class="number">100</span> dstport <span class="number">4789</span> local <span class="number">10.57</span><span class="number">.4</span><span class="number">.21</span> dev eth0 learning  ## 这个eth0要根据你自己测试节点的网卡调整</span><br><span class="line">ip addr add <span class="number">192.168</span><span class="number">.11</span><span class="number">.1</span>/<span class="number">32</span> dev vxlan0</span><br><span class="line">ip link set vxlan0 up</span><br><span class="line">ip route add <span class="number">192.168</span><span class="number">.10</span><span class="number">.0</span>/<span class="number">24</span> via <span class="number">192.168</span><span class="number">.10</span><span class="number">.1</span> dev vxlan0 onlink</span><br><span class="line">bridge fdb append  <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> dev vxlan0 dst <span class="number">10.57</span><span class="number">.4</span><span class="number">.20</span> self permanent</span><br></pre></td></tr></table></figure><p>复制</p><p>这时候两台主机的pod应该可以相互ping通了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec pod-b ping -c <span class="number">5</span> <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span></span><br><span class="line"><span class="variable constant_">PING</span> <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span> (<span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span>) <span class="number">56</span>(<span class="number">84</span>) bytes <span class="keyword">of</span> data.</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span>: icmp_seq=<span class="number">1</span> ttl=<span class="number">62</span> time=<span class="number">0.375</span> ms</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span>: icmp_seq=<span class="number">2</span> ttl=<span class="number">62</span> time=<span class="number">0.497</span> ms</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span>: icmp_seq=<span class="number">3</span> ttl=<span class="number">62</span> time=<span class="number">0.502</span> ms</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span>: icmp_seq=<span class="number">4</span> ttl=<span class="number">62</span> time=<span class="number">0.386</span> ms</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span>: icmp_seq=<span class="number">5</span> ttl=<span class="number">62</span> time=<span class="number">0.390</span> ms</span><br><span class="line">--- <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span> ping statistics ---</span><br><span class="line"><span class="number">5</span> packets transmitted, <span class="number">5</span> received, <span class="number">0</span>% packet loss, time 4000ms</span><br><span class="line">rtt min/avg/max/mdev = <span class="number">0.375</span>/<span class="number">0.430</span>/<span class="number">0.502</span>/<span class="number">0.056</span> ms</span><br></pre></td></tr></table></figure><p>复制</p><p>此时pod-a请求pod-b的http服务，数据包从host-1发往host-2时是长这样的：</p><p><img src="/2022/12/17/k8s%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E5%8E%9F%E7%90%863/../img/%E5%8E%9F%E7%90%86%E4%B8%89assets/1620-167128567598313.jpeg" alt="img"></p><p>图三：vxlan</p><p>可以看到，vxlan包是把整个pod-a发往pod-b最原始的帧都装进了一个udp数据包的payload中，整个流程简述如下：</p><ul><li>1､ pod-a数据包到达host-1，源ip为pod-a，目标ip为pod-b，源mac为pod-a，目标mac为host-1中的veth-pod-a</li><li>2､ 主机因为开启了转发，所以查找路由表中去往pod-b的下一跳，查到匹配的路由信息如下：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168</span><span class="number">.11</span><span class="number">.0</span>/<span class="number">24</span> via <span class="number">192.168</span><span class="number">.11</span><span class="number">.1</span> dev vxlan0 onlink  ## 这是我们在上面的host1执行的命令中的第四条命令添加的</span><br></pre></td></tr></table></figure><p>复制</p><ul><li>3､ 于是主机把数据包给了vxlan0，并且下一跳为192.168.11.1，此时vxlan0需要得到192.168.11.1的mac地址，但主机的邻居表中不存在，于是vxlan0发起arp广播去询问，vxlan0的广播范围是由我们配置的，这个范围就是我们给他加的全0 fdb记录标识的dstIP，就是上面命令中的：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bridge fdb append  <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> dev vxlan0 dst <span class="number">10.57</span><span class="number">.4</span><span class="number">.21</span> self permanent</span><br></pre></td></tr></table></figure><p>复制</p><p>​    所以，这里找到的目标只有一个，就是10.57.4.21，然后vxlan就借助host1的eth0发起了这个广播，只不过eth0发起的不是广播，而是有明确目标IP的udp数据包，如果上面我们是配置了多个全0的fdb记录，这里eth0就会发起多播。</p><ul><li>4､ 192.168.11.1这个地址是我们配置在host2上的vxlan0的网卡地址，于是host2会响应arp请求，host1的vxlan设备得到192.168.11.1的mac地址后，vxlan会从主机的fdb表中查找该mac的下一跳的主机号，发现找不到，于是又发起学习，问谁拥有这个mac，host-2再次应答，于是vxlan0就拥有了封包需要的全部信息，于是把包封装成图三的样子，扔给了host1的eth0网卡；</li><li>5､ host2收到这个包后，因为是一个普通的udp包，于是一直上送到传输层，传输层对于这个端口会有个特殊处理，这个特殊处理会把udp包里payload的信息抠出来扔给协议栈，重新走一遍收包流程。（vxlan的原理后面有机会专门写一篇文章）</li></ul><blockquote><p>像这种vxlan学习fdb的方式难免会在主机网络间产生广播风暴，所以flannel的vxlan模式下，是关闭了vxlan设备的learning机制，然后用控制器维护fdb记录和邻居表记录的</p></blockquote><p>可以看到这个过程中两次都需要用到全0的fdb记录，我们也可以在host1上查看vxlan0学习到的fdb记录和邻居表信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bridge fdb|grep vxlan0</span><br><span class="line"></span><br><span class="line"><span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> dev vxlan0 dst <span class="number">10.57</span><span class="number">.4</span><span class="number">.21</span> self permanent ## 这是我们手工添加的</span><br><span class="line">6<span class="attr">e</span>:<span class="number">39</span>:<span class="number">38</span>:<span class="number">33</span>:7<span class="attr">c</span>:<span class="number">24</span> dev vxlan0 dst <span class="number">10.57</span><span class="number">.4</span><span class="number">.21</span> self   ## 这是vxlan0自动学习的，6<span class="attr">e</span>:<span class="number">39</span>:<span class="number">38</span>:<span class="number">33</span>:7<span class="attr">c</span>:<span class="number">24</span> 正是host2中vxlan0的地址</span><br></pre></td></tr></table></figure><p>复制</p><p>邻居表记录：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip n</span><br><span class="line"></span><br><span class="line"><span class="number">192.168</span><span class="number">.11</span><span class="number">.1</span> dev vxlan0 lladdr 6<span class="attr">e</span>:<span class="number">39</span>:<span class="number">38</span>:<span class="number">33</span>:7<span class="attr">c</span>:<span class="number">24</span> <span class="variable constant_">STALE</span></span><br></pre></td></tr></table></figure><p>复制</p><p>在pod-b中ping pod-a的时候，在host1打开网卡监听，拦截的数据如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -n -i eth0 src <span class="number">10.57</span><span class="number">.4</span><span class="number">.21</span></span><br><span class="line"></span><br><span class="line"><span class="attr">tcpdump</span>: verbose output suppressed, use -v or -vv <span class="keyword">for</span> full protocol decode</span><br><span class="line">listening on eth0, link-type <span class="title class_">EN10MB</span> (<span class="title class_">Ethernet</span>), capture size <span class="number">262144</span> bytes</span><br><span class="line"><span class="number">10</span>:<span class="number">21</span>:<span class="number">01</span><span class="number">.050849</span> <span class="variable constant_">IP</span> <span class="number">10.57</span><span class="number">.4</span><span class="number">.21</span><span class="number">.55255</span> &gt; <span class="number">10.57</span><span class="number">.4</span><span class="number">.20</span>.<span class="property">otv</span>: <span class="variable constant_">OTV</span>, flags [I] (<span class="number">0x08</span>), overlay <span class="number">0</span>, instance <span class="number">1</span></span><br><span class="line"><span class="variable constant_">IP</span> <span class="number">192.168</span><span class="number">.11</span><span class="number">.10</span> &gt; <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span>: <span class="variable constant_">ICMP</span> echo request, id <span class="number">26972</span>, seq <span class="number">15</span>, length <span class="number">64</span></span><br><span class="line"><span class="number">10</span>:<span class="number">21</span>:<span class="number">02</span><span class="number">.051894</span> <span class="variable constant_">IP</span> <span class="number">10.57</span><span class="number">.4</span><span class="number">.21</span><span class="number">.55255</span> &gt; <span class="number">10.57</span><span class="number">.4</span><span class="number">.20</span>.<span class="property">otv</span>: <span class="variable constant_">OTV</span>, flags [I] (<span class="number">0x08</span>), overlay <span class="number">0</span>, instance <span class="number">1</span></span><br><span class="line"><span class="variable constant_">IP</span> <span class="number">192.168</span><span class="number">.11</span><span class="number">.10</span> &gt; <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span>: <span class="variable constant_">ICMP</span> echo request, id <span class="number">26972</span>, seq <span class="number">16</span>, length <span class="number">64</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>复制</p><p>可以看到也是两层包头，外层包头显示这是otv（overlay transport virtualization）包，对于otv，用一句话解释：</p><p>*<strong>OTV is a “MAC in IP” technique to extend Layer 2 domains over any transport*</strong></p><p>从上面的过程可以看出来，vxlan模式依赖udp协议和默认的4789端口，所以在云平台的ECS上使用vxlan模式，还是需要在安全组上把udp 4789端口放开</p><blockquote><p>什么终极解决方案，弄了半天也是要设置安全组的哈哈哈！！</p></blockquote><h2 id="一些误解"><a href="#一些误解" class="headerlink" title="一些误解"></a>一些误解</h2><ol><li>是不是用了ipip&#x2F;vxlan模式，网络策略就不起效了？</li></ol><p>不是的，不管是ipip还是vxlan模式下，主机协议栈把外层包头摘掉后，会把原始数据包重新扔回协议栈，重走一遍netfilter的几个点，所以针对podIP的防火墙策略依旧会生效的；</p><h2 id="对比几种常用的cni"><a href="#对比几种常用的cni" class="headerlink" title="对比几种常用的cni"></a>对比几种常用的cni</h2><ul><li>flannel<ul><li>vxlan模式兼容性强，但速度差一点</li><li>host-gw模式：只有二层直联的环境才能用，节点不能在多个子网，速度最快</li><li>不支持network policy</li></ul></li><li>calico<ul><li>bgp在idc机房较合适，云平台不支持</li><li>ipip模式，兼容性强，速度比vxlan好，最推荐</li><li>支持network policy</li></ul></li><li>cilium<ul><li>性能好，也支持network policy，但对linux内核有要求（推荐是4.18以上）</li><li>对于<a href="https://cloud.tencent.com/solution/operation?from=10680">运维</a>来说比较有难度，因为一切都是新的，没有iptables&#x2F;ipvs，以前的排错经验用不上</li></ul></li></ul><h2 id="解答上一篇问题"><a href="#解答上一篇问题" class="headerlink" title="解答上一篇问题"></a>解答上一篇问题</h2><ul><li>使用ipvs模式时，k8s集群的每个节点会有一张叫kube-ipvs0的网卡，网卡下挂着所有的clusterIP，有什么作用？</li></ul><p>看回上一篇文章的图一，ipvs工作在netfilter扩展点中的LOCAL_IN点（也就是INPUT点），之前的内容中提过，流量在经过IPIsLocal时，会判断目标IP是否为本机地址，如果是则会走INPUT点，否则走FORWATD；为了让ipvs能操作流量，必须先让流量先到达INPUT点，于是就把所有clusterIP都挂在kube-ipvs0上，所有访问clusterIP的流量到达IPIsLocal点时，主机协议栈都会认为这是去往本机的流量，转到INPUT点去；</p><ul><li>下面这条iptables规则到底有什么作用？</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A <span class="variable constant_">KUBE</span>-<span class="variable constant_">FORWARD</span> -m conntrack --ctstate <span class="variable constant_">RELATED</span>,<span class="variable constant_">ESTABLISHED</span> -j <span class="variable constant_">ACCEPT</span></span><br></pre></td></tr></table></figure><p>复制</p><p>首先要了解，现在的防火墙技术都是基于连接状态的基础之上的，就是常说的有状态的防火墙；</p><p>拿上面的pod-a和pod-b来举例，假设我们不允许pod-a访问pod-b，于是在host1上创建一条这样的iptables规则：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A <span class="variable constant_">FORWARD</span> -t filter -s <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span> -d <span class="number">192.168</span><span class="number">.11</span><span class="number">.10</span> -j <span class="variable constant_">DROP</span></span><br></pre></td></tr></table></figure><p>复制</p><p>好了，这时候pod-a中去ping pod-b已经不通了，但是，pod-b中去ping pod-a也不通了，因为pod-a回pod-b的包也命中了上面那条策略；</p><p>当我们说：*<strong>不允许pod-a访问pod-b，只是说不允许pod-a主动访问pod-b，但是允许pod-a被动访问pod-b*</strong></p><p>这个听着有点绕，类似你跟你的二逼朋友说：平时没事别主动给老子打电话，但老子打你电话你要接！</p><p>好了，问题来了，怎么标识这是主动和流量还是被动的流量呢？这个问题linux内核协议栈已经帮我们解决好了，linux内核协议栈会悄悄维护连接的状态：</p><ul><li>当pod-a向pod-b主动发送数据包时，到达pod-b时，连接状态为NEW；</li><li>当pod-b主动向pod-a发送数据包，pod-a回给pod-b的数据包到达pod-b时，连接状态为ESTABLISHED；</li></ul><p>于是我们只要优先放过所有的连接状态为ESTABLISHED的包就可以了，问题中的命令的作用正是这个：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A <span class="variable constant_">KUBE</span>-<span class="variable constant_">FORWARD</span> -m conntrack --ctstate <span class="variable constant_">RELATED</span>,<span class="variable constant_">ESTABLISHED</span> -j <span class="variable constant_">ACCEPT</span></span><br></pre></td></tr></table></figure><p>复制</p><p><code>-m conntrack</code>是说使用连接追踪模块标识的数据包状态，<code>--ctstate</code>是connection track state（连接追踪状态）的简称，状态值有：NEW&#x2F;ESTABLISHED&#x2F;INVALID&#x2F;RELATED等，各种状态的解释自行google；</p><p>上面这条规则的优先级一般都是最高的，如果放在其它限制规则的后面就没有意义了，不单是容器平台的防火墙策略，大多数云平台网络中ACL、安全组的策略也是这种玩法；</p><p>下一章我们来介绍pod的流量控制。</p><p>（上面的三张图，其中一张图中的有个细节是错误的，你看出来了吗？）</p>]]></content>
      
      
      <categories>
          
          <category> k8s网络原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> k8s网络原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解kubernetes（k8s）网络原理之一-pod连接主机</title>
      <link href="/2022/12/17/k8s%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E5%8E%9F%E7%90%861/"/>
      <url>/2022/12/17/k8s%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E5%8E%9F%E7%90%861/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>此文章转载于<a href="https://cloud.tencent.com/developer/inventory/21543/article/1869534,%E6%88%91%E8%A7%89%E5%BE%97%E5%86%99%E5%BE%97%E9%9D%9E%E5%B8%B8%E5%A5%BD,%E6%80%95%E4%BB%96%E5%93%AA%E5%A4%A9%E4%B8%8D%E8%A7%81%E4%BA%86,%E5%B0%B1%E8%AE%B0%E5%BD%95%E4%B8%8B%E6%9D%A5%E4%BA%86">https://cloud.tencent.com/developer/inventory/21543/article/1869534,我觉得写得非常好,怕他哪天不见了,就记录下来了</a></p></blockquote><p>对于刚接触k8s的人来说，最令人懵逼的应该就是k8s的网络了，如何访问部署在k8s的应用，service的几种类型有什么区别，各有什么使用场景，服务的<a href="https://cloud.tencent.com/product/clb?from=10680">负载均衡</a>是如何实现的，与haproxy&#x2F;nginx转发有什么区别，网络策略为什么不用限制serviceIP等等</p><p>本文将站在一个初学者的角度，采用一边讲解一边实践的方式把k8s的网络相关的原理慢慢剖析清楚，并且用普通的linux命令把pod&#x2F;serviceIP&#x2F;nodePort等场景都模拟出来；</p><p>本文比较适合刚接触k8s，对docker有一些了解，有一定计算机基础的童鞋，在浏览本文时，各位童鞋可以准备个centos7.6的环境，安装docker和iproute2工具包，一边看一边操作，加深理解。</p><p>OK，走起！</p><h2 id="一些关于linux网络的知识"><a href="#一些关于linux网络的知识" class="headerlink" title="一些关于linux网络的知识"></a>一些关于linux网络的知识</h2><p>在开始之前，有一些关于linux网络的知识你需要先知道，就像做数学题之前，先得理解公式一样。</p><h3 id="每当linux需要向外发送一个数据包时，总是会执行以下步骤："><a href="#每当linux需要向外发送一个数据包时，总是会执行以下步骤：" class="headerlink" title="每当linux需要向外发送一个数据包时，总是会执行以下步骤："></a>每当linux需要向外发送一个数据包时，总是会执行以下步骤：</h3><ol><li>查找到该数据包的目的地的路由信息，如果是直连路由（不知道什么是直连路由？没关系，后面会解释），则在邻居表中查找该目的地的MAC地址</li><li>如果非直连路由，则在邻居表中找下一跳的MAC地址</li><li>如果找不到对应的路由，则报“network is unreachable”</li><li>如果在邻居表中没有查找到相应的MAC信息，则向外发送ARP请求询问</li><li>发送出去的数据帧，源MAC地址为发送网卡的MAC地址，目标MAC则是下一跳的MAC，只要不经过NAT，那么源目地IP是全程不会变化的，而MAC地址则每一跳都会变化</li></ol><h3 id="每当linux收到一个数据帧时，总会执行以下步骤："><a href="#每当linux收到一个数据帧时，总会执行以下步骤：" class="headerlink" title="每当linux收到一个数据帧时，总会执行以下步骤："></a>每当linux收到一个数据帧时，总会执行以下步骤：</h3><ol><li>如果数据帧目标MAC地址不是收包网卡的MAC，也不是ff:ff:ff:ff:ff:ff（ARP广播），且网卡未开启混杂模式，则拒绝收包；</li><li>如果数据帧目标MAC为ff:ff:ff:ff:ff:ff，则进入arp请求处理流程；</li><li>如果数据帧目标MAC地址是收包网卡的MAC，且是IP包，则：<ul><li>目标IP地址在本机，则上送到上一层协议继续处理；</li><li>目标IP地址不在本机，则看net.ipv4.ip_forward是否为1，如果为1，则查找目标IP的路由信息，进行转发；</li><li>目标IP地址不在本机，且net.ipv4.ip_forward为0，则丢弃</li></ul></li></ol><h3 id="一些常用的命令"><a href="#一些常用的命令" class="headerlink" title="一些常用的命令"></a>一些常用的命令</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ip link ##查看网卡信息</span><br><span class="line">ip addr ##查看网卡<span class="variable constant_">IP</span>地址</span><br><span class="line">ip route ##查看路由信息</span><br><span class="line">ip neigh ##查看邻居表信息</span><br><span class="line"></span><br><span class="line">##上面的命令均可简化，就是第二个单词的首字母，</span><br><span class="line">##例如ip link可以简化为ip l，ip addr可以简化为ip a，以此类推……</span><br><span class="line"></span><br><span class="line">iptables-save ##查看所有iptables规则</span><br></pre></td></tr></table></figure><p>复制</p><p><strong>然后，我们就正式开始了，因为k8s的网络主要都是要解决怎么访问pod和pod怎么访问外面的问题，所以先来了解一下什么是pod</strong></p><h2 id="pod是什么"><a href="#pod是什么" class="headerlink" title="pod是什么"></a>pod是什么</h2><p>现在的<a href="https://cloud.tencent.com/product/cvm?from=10680">服务器</a>一般配置都比较高，64核256G的配置，如果一台服务器只用来跑一个java程序，显然就太浪费了，如果想资源利用率高一些，可以用qemu-kvm或vmware等软件进行虚拟化，让多个java进程分别运行在虚拟机里，这样可以相互不受影响；</p><p>但虚拟化难免会带来一些资源损耗，而且要先拉起一台虚拟机再在里面启动一个java进程也会比直接在裸金属服务上启动一个java进程要耗费更多的时间，只是从运行几个java进程的角度来说，虚拟化并非资源利用的最优解；</p><p>如果不用虚拟化，直接同时在裸金属服务上运行多个java进程，就要解决各个进程CPU内存资源占用、端口冲突、文件系统冲突等几个问题，否则就会出现：</p><ul><li>一个进程消耗了大量的内存和CPU，而另一个更重要的进程却得不到资源；</li><li>80端口只有一个，进程A用了，进程B就用不了</li><li>多个进程同时操作相同的目录或读写相同的文件，造成异常</li></ul><p>因为需要让多个进程都能高效地相互不受影响地运行，所以<a href="https://cloud.tencent.com/product/tke?from=10680">容器</a>技术出现了，其中又以docker最为流行，容器解决了多进程间的环境隔离：</p><ul><li>资源隔离，使用linux control group（简称：cgroup）解决各进程cpu和内存、io的资源分配问题</li><li>网络隔离，使用linux network namespace（<em><strong>下面开始简称：ns</strong></em>）使各个进程运行在独立的网络命名空间，使各类网络资源相互隔离（网卡、端口、防火墙规则、路由规则等）</li><li>文件系统隔离，使用union fs，例如：overlay2&#x2F;aufs等，让各个进程运行在独立的根文件系统中</li></ul><p><strong>而所谓的pod，就是共享一个ns的多个容器</strong></p><p>但是，什么叫“共享一个ns的多个容器”？</p><p>每当我们用docker运行一个容器，默认情况下，会给这个新的容器创建一个独立的ns，多个容器间相互访问只能使用对方IP地址</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name=pause busybox</span><br><span class="line">docker run --name=nginx -d nginx</span><br></pre></td></tr></table></figure><p>复制</p><p>此时要在pause中访问nginx，先查找一下nginx容器的IP地址：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker inspect nginx|grep <span class="title class_">IPAddress</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;IPAddress&quot;</span>: <span class="string">&quot;172.17.0.8&quot;</span>,</span><br></pre></td></tr></table></figure><p>复制</p><p>然后在pause容器中用刚查到的IP访问：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it pause curl <span class="number">172.17</span><span class="number">.0</span><span class="number">.8</span></span><br><span class="line"></span><br><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Welcome to nginx!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">....</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>复制</p><p>但其实是可以让nginx容器加入pause容器的ns，用下面的命令可以模拟：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name=pause busybox</span><br><span class="line">docker run --name=nginx --network=<span class="attr">container</span>:pause -d nginx</span><br></pre></td></tr></table></figure><p>复制</p><p>此时pause容器和nginx容器在相同的ns中，相互间就可以用localhost访问对方了，可以用下面的命令验证：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it pause curl localhost</span><br><span class="line"></span><br><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Welcome to nginx!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">....</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>复制</p><p>pause容器和nginx容器就是“共享一个ns的两个容器”，所以，pause容器和nginx容器加起来，就是k8s的pod</p><blockquote><p>在k8s集群的节点中使用docker ps，总是会发现一堆名为pause的容器，就是这个原因，pause是为多个业务容器提供共享的ns的</p></blockquote><p>可以用下面的命令进入之前用docker创建的pause容器的ns</p><p>先获取pause容器的pid</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker inspect pause|grep <span class="title class_">Pid</span></span><br><span class="line"></span><br><span class="line">            <span class="string">&quot;Pid&quot;</span>: <span class="number">3083138</span>,</span><br></pre></td></tr></table></figure><p>复制</p><p>用<code>nsenter</code>命令进入指定pid的ns</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nsenter --net=<span class="regexp">/proc/</span><span class="number">3083138</span>/ns/net</span><br></pre></td></tr></table></figure><p>复制</p><p>此时我们已经在pause容器的ns中了，可以查看该ns的网卡，路由表，邻居表等信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ip addr show </span><br><span class="line"></span><br><span class="line"><span class="number">1</span>: <span class="attr">lo</span>: &lt;<span class="variable constant_">LOOPBACK</span>,<span class="variable constant_">UP</span>,<span class="variable constant_">LOWER_UP</span>&gt; mtu <span class="number">65536</span> qdisc noqueue state <span class="variable constant_">UNKNOWN</span> group <span class="keyword">default</span> qlen <span class="number">1000</span></span><br><span class="line">    link/loopback <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> brd <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">    inet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>/<span class="number">8</span> scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="number">605</span>: eth0@<span class="attr">if606</span>: &lt;<span class="variable constant_">BROADCAST</span>,<span class="variable constant_">MULTICAST</span>,<span class="variable constant_">UP</span>,<span class="variable constant_">LOWER_UP</span>&gt; mtu <span class="number">1500</span> qdisc noqueue state <span class="variable constant_">UP</span> group <span class="keyword">default</span></span><br><span class="line">    link/ether <span class="number">02</span>:<span class="number">42</span>:<span class="attr">ac</span>:<span class="number">11</span>:<span class="number">00</span>:<span class="number">02</span> brd <span class="attr">ff</span>:<span class="attr">ff</span>:<span class="attr">ff</span>:<span class="attr">ff</span>:<span class="attr">ff</span>:ff link-netnsid <span class="number">0</span></span><br><span class="line">    inet <span class="number">172.17</span><span class="number">.0</span><span class="number">.7</span>/<span class="number">16</span> brd <span class="number">172.17</span><span class="number">.255</span><span class="number">.255</span> scope <span class="variable language_">global</span> eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p>复制</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ip route</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span> via <span class="number">172.17</span><span class="number">.0</span><span class="number">.1</span> dev eth0</span><br><span class="line"><span class="number">172.17</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">16</span> dev eth0 proto kernel scope link src <span class="number">172.17</span><span class="number">.0</span><span class="number">.2</span></span><br></pre></td></tr></table></figure><p>复制</p><p>从网络的角度看，<em><strong>一个pod就是一个独立的ns，解决了ns的网络进出问题，就解决了pod的网络问题</strong></em>，所以下面的讨论就都以ns为主，不再频繁创建docker容器，后面的描述不管是pod还是ns，请统一理解为ns就好</p><h2 id="认识ns"><a href="#认识ns" class="headerlink" title="认识ns"></a>认识ns</h2><p>对于一台linux主机来说，影响网络方面的配置主要有以下几个：</p><ul><li>网卡：启动时初始化，后期可以添加虚拟设备；</li><li>端口：1到65535，所有进程共用</li><li>iptables规则：配置进出主机的防火墙策略和NAT规则</li><li>路由表：到目标地址的路由信息</li><li>邻居表：与主机在同个二层网络（什么是同个二层网络？大概可以理解为在一台交换机上，彼此之间通过ARP找到对方的）的其它主机的MAC地址与IP地址的映射关系</li></ul><p>对于每一个ns来说，这几个配置都是独立的，所以从网络的角度来说，当你创建一个新的ns，其实就相当于拥有了一台新的主机</p><p>用下面的命令创建新的ns</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip netns add ns1 ##创建ns</span><br></pre></td></tr></table></figure><p>复制</p><p>然后我们可以用<code>ip netns exec ns1</code>为前缀来执行命令，这样显示的结果就都是ns1的网络相关配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec ns1 ip link show</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>: <span class="attr">lo</span>: &lt;<span class="variable constant_">LOOPBACK</span>&gt; mtu <span class="number">65536</span> qdisc noop state <span class="variable constant_">DOWN</span> mode <span class="variable constant_">DEFAULT</span> group <span class="keyword">default</span> qlen <span class="number">1000</span></span><br><span class="line">    link/loopback <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> brd <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br></pre></td></tr></table></figure><p>复制</p><p>可以看到，我们用ip命令创建的ns除了一张lo网卡外，其它都是空白，这样一来她里面运行的程序访问不了外面，外面也找不到她，需要我们一点点地去组织，这就是k8s的cni要做的事情</p><blockquote><p>上面我们用docker启动的容器中，网卡，IP，路由都是docker网络管理（cnm）给组织好的，从单节点的网络管理来看，cni和cnm做的事情还是挺像的</p></blockquote><p>下面我们就一步步来完成k8s的cni做的事情，第一步是让主机和pod能相互访问</p><h2 id="主机与pod相互访问"><a href="#主机与pod相互访问" class="headerlink" title="主机与pod相互访问"></a>主机与pod相互访问</h2><p>首先给ns1增加一张与主机连接的网卡，这里会用到linux虚拟网络设备veth网卡对，对于veth，基本上可以理解为两张网卡中间连着线，一端发送会触发另一端接收，用下面的命令创建：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ip link add ns1-eth0 type veth peer name veth-ns1  ## 增加一对veth网卡，名为ns1-eth0和veth-ns1</span><br><span class="line">ip link set ns1-eth0 netns ns1  ## 其中一端挪到刚才创建的ns1中，另一端留在主机端，这样主机和ns就连接起来了</span><br><span class="line">ip link set veth-ns1 up ##启动主机端的网卡veth-ns1</span><br><span class="line">ip netns exec ns1 ip addr add <span class="number">172.20</span><span class="number">.1</span><span class="number">.10</span>/<span class="number">24</span> dev ns1-eth0  ##此时ns1-eth0已经在ns1中了，所以要进去ns1中去执行命令设置网卡<span class="variable constant_">IP</span></span><br><span class="line">ip netns exec ns1 ip link set ns1-eth0 up ##启动ns1端的网卡ns1-eth0</span><br></pre></td></tr></table></figure><p>复制</p><p>笔者使用的主机的IP是192.168.6.160，此时尝试从ns1中ping主机，能通了吗？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec ns1 ping <span class="number">192.168</span><span class="number">.6</span><span class="number">.160</span></span><br><span class="line"></span><br><span class="line"><span class="attr">connect</span>: <span class="title class_">Network</span> is unreachable</span><br></pre></td></tr></table></figure><p>复制</p><p>ping不通主机，此时的情况就是上面提到的linux知识点中关于发送数据包的第3点，因为没有到目的地的路由，ns1不知如何去192.168.6.160，在这里我们要给ns1增加一条默认路由，所有没有显式声明路由的数据包都会走默认网关：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec ns1 ip route add <span class="keyword">default</span> via <span class="number">172.20</span><span class="number">.1</span><span class="number">.1</span> dev ns1-eth0 </span><br></pre></td></tr></table></figure><p>复制</p><p>去看一下ns1中的路由表，已经有两条路由信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec ns1 ip route</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span> via <span class="number">172.20</span><span class="number">.1</span><span class="number">.1</span> dev ns1-eth0  ##这是一条非直连路由，意思是默认流量走ns1-eth0网卡，下一跳为<span class="number">172.20</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line"><span class="number">172.20</span><span class="number">.1</span><span class="number">.0</span>/<span class="number">24</span> dev ns1-eth0 proto kernel scope link src <span class="number">172.20</span><span class="number">.1</span><span class="number">.10</span>  ## 这是一条直连路由，没有via的就是直连路由，这是我们给网卡设置<span class="variable constant_">IP</span>时系统自动增加的</span><br></pre></td></tr></table></figure><p>复制</p><p>此时能通了吗？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec ns1 ping <span class="number">192.168</span><span class="number">.6</span><span class="number">.160</span></span><br><span class="line"> </span><br><span class="line"><span class="variable constant_">PING</span> <span class="number">192.168</span><span class="number">.6</span><span class="number">.160</span> (<span class="number">192.168</span><span class="number">.6</span><span class="number">.160</span>) <span class="number">56</span>(<span class="number">84</span>) bytes <span class="keyword">of</span> data.</span><br></pre></td></tr></table></figure><p>复制</p><p>还是不行，定在那里半天没反应，又卡在哪了呢？还是linux知识点中关于发送数据包的第2点，如果是非直连路由，会先去拿下一跳的MAC地址，下一跳是172.20.1.1，能获取到它的MAC地址吗？用下面的命令查一下邻居表：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec ns1 ip neigh</span><br><span class="line"><span class="number">172.20</span><span class="number">.1</span><span class="number">.1</span> dev ns1-eth0  <span class="variable constant_">FAILED</span></span><br></pre></td></tr></table></figure><p>复制</p><p>很明显，获取不到，因为网关IP地址确实是个不存在的地址，但其实这个地址不需要是个存在的地址（所以你会看到在calico中，容器的默认网关是个168.254开头的地址），因为这个地址其实是用不到的，网关的IP是不会出现在pod发送的数据包中的，真正需要用到的是网关的mac地址，我们的目的是要得到主机端veth-ns1的mac地址，有两个方法：</p><ul><li>设置对端的网卡的arp代答，ns1-eth0的对端是主机上的veth-ns1网卡</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">1</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/conf/veth-ns1/proxy_arp </span><br></pre></td></tr></table></figure><p>复制</p><blockquote><p>这样就开启了veth-ns1的arp代答，只要收到arp请求，不管目标IP是什么，veth-ns1网卡都会把自己MAC地址回复回去</p></blockquote><ul><li>把网关地址设置在对端的网卡上</li></ul><p>在这里我们用第一种方式，设置后再查一下邻居表：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec ns1 ip neigh</span><br><span class="line"> </span><br><span class="line"><span class="number">172.20</span><span class="number">.1</span><span class="number">.1</span> dev ns1-eth0 lladdr <span class="attr">b6</span>:<span class="number">58</span>:7<span class="attr">b</span>:0<span class="attr">e</span>:<span class="number">35</span>:b3 <span class="variable constant_">REACHABLE</span></span><br></pre></td></tr></table></figure><p>复制</p><p>可以看到，已经拿到网关的MAC地址了，这个地址也确实就是主机端veth-ns1的地址：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> ip link show veth-ns1</span><br><span class="line"><span class="number">607</span>: veth-ns1@<span class="attr">if608</span>: &lt;<span class="variable constant_">BROADCAST</span>,<span class="variable constant_">MULTICAST</span>,<span class="variable constant_">UP</span>,<span class="variable constant_">LOWER_UP</span>&gt; mtu <span class="number">1500</span> qdisc noqueue state <span class="variable constant_">UP</span> mode <span class="variable constant_">DEFAULT</span> group <span class="keyword">default</span> qlen <span class="number">1000</span></span><br><span class="line">    link/ether <span class="attr">b6</span>:<span class="number">58</span>:7<span class="attr">b</span>:0<span class="attr">e</span>:<span class="number">35</span>:b3 brd <span class="attr">ff</span>:<span class="attr">ff</span>:<span class="attr">ff</span>:<span class="attr">ff</span>:<span class="attr">ff</span>:ff link-netns ns1</span><br></pre></td></tr></table></figure><p>复制</p><p>这下总该行了吧？兴高采烈地ping一下，发现依旧不行</p><p>oh shit!!</p><p>什么垃圾！！</p><p>入门到放弃！！！</p><p>先别急着崩溃，主机委屈说：数据包我收到了，只是我不知道怎么回给你，因为我这里没有到172.20.1.10的路由，所以我就把回包给了我的默认网关……</p><p>坚持住，只需最后一步，在主机上添加到pod的直联路由</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route add <span class="number">172.20</span><span class="number">.1</span><span class="number">.10</span> dev veth-ns1  ## 这也是一条直连路由，注意是添加主机的路由，所以不用ip netns exec ns1开头了</span><br></pre></td></tr></table></figure><p>复制</p><p>此时从ns1中ping主机：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec ns1 ping -c <span class="number">5</span> <span class="number">192.168</span><span class="number">.6</span><span class="number">.160</span></span><br><span class="line"></span><br><span class="line"><span class="variable constant_">PING</span> <span class="number">192.168</span><span class="number">.6</span><span class="number">.160</span> (<span class="number">192.168</span><span class="number">.6</span><span class="number">.160</span>) <span class="number">56</span>(<span class="number">84</span>) bytes <span class="keyword">of</span> data.</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">192.168</span><span class="number">.6</span><span class="number">.160</span>: icmp_seq=<span class="number">1</span> ttl=<span class="number">64</span> time=<span class="number">0.025</span> ms</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">192.168</span><span class="number">.6</span><span class="number">.160</span>: icmp_seq=<span class="number">2</span> ttl=<span class="number">64</span> time=<span class="number">0.017</span> ms</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">192.168</span><span class="number">.6</span><span class="number">.160</span>: icmp_seq=<span class="number">3</span> ttl=<span class="number">64</span> time=<span class="number">0.015</span> ms</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">192.168</span><span class="number">.6</span><span class="number">.160</span>: icmp_seq=<span class="number">4</span> ttl=<span class="number">64</span> time=<span class="number">0.017</span> ms</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">192.168</span><span class="number">.6</span><span class="number">.160</span>: icmp_seq=<span class="number">5</span> ttl=<span class="number">64</span> time=<span class="number">0.017</span> ms</span><br><span class="line">--- <span class="number">192.168</span><span class="number">.6</span><span class="number">.160</span> ping statistics ---</span><br><span class="line"><span class="number">5</span> packets transmitted, <span class="number">5</span> received, <span class="number">0</span>% packet loss, time 135ms</span><br><span class="line">rtt min/avg/max/mdev = <span class="number">0.015</span>/<span class="number">0.018</span>/<span class="number">0.025</span>/<span class="number">0.004</span> ms</span><br></pre></td></tr></table></figure><p>复制</p><p>从主机ping ns1</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ping -c <span class="number">5</span> <span class="number">172.20</span><span class="number">.1</span><span class="number">.10</span></span><br><span class="line"></span><br><span class="line"><span class="variable constant_">PING</span> <span class="number">172.20</span><span class="number">.1</span><span class="number">.10</span> (<span class="number">172.20</span><span class="number">.1</span><span class="number">.10</span>) <span class="number">56</span>(<span class="number">84</span>) bytes <span class="keyword">of</span> data.</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">172.20</span><span class="number">.1</span><span class="number">.10</span>: icmp_seq=<span class="number">1</span> ttl=<span class="number">64</span> time=<span class="number">0.026</span> ms</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">172.20</span><span class="number">.1</span><span class="number">.10</span>: icmp_seq=<span class="number">2</span> ttl=<span class="number">64</span> time=<span class="number">0.015</span> ms</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">172.20</span><span class="number">.1</span><span class="number">.10</span>: icmp_seq=<span class="number">3</span> ttl=<span class="number">64</span> time=<span class="number">0.016</span> ms</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">172.20</span><span class="number">.1</span><span class="number">.10</span>: icmp_seq=<span class="number">4</span> ttl=<span class="number">64</span> time=<span class="number">0.015</span> ms</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">172.20</span><span class="number">.1</span><span class="number">.10</span>: icmp_seq=<span class="number">5</span> ttl=<span class="number">64</span> time=<span class="number">0.016</span> ms</span><br><span class="line">--- <span class="number">172.20</span><span class="number">.1</span><span class="number">.10</span> ping statistics ---</span><br><span class="line"><span class="number">5</span> packets transmitted, <span class="number">5</span> received, <span class="number">0</span>% packet loss, time 138ms</span><br><span class="line">rtt min/avg/max/mdev = <span class="number">0.015</span>/<span class="number">0.017</span>/<span class="number">0.026</span>/<span class="number">0.006</span> ms</span><br></pre></td></tr></table></figure><p>复制</p><p>OK，成功完成第一步，pod与主机互通，此时在pod里能访问百度吗？</p><p>答案是不行，172.20.1.10这个地址是我们随便模拟出来的，除了当前这台主机谁也不认识，所以如果他要访问外网，需要做源地址转换，这个场景跟我们办公室的PC上外网原理是一样的，当你用办公室内网的电脑去访问百度时，数据包到达百度的服务器上时源地址肯定不是你电脑的内网网卡地址，而是你的办公网络出外网的出口IP加一个随机端口，这个源地址转换是你的办公室网络出口路由器自动帮你完成的，我们在主机上也要配置针对刚才创建的pod的源地址转换规则</p><h2 id="pod访问外网"><a href="#pod访问外网" class="headerlink" title="pod访问外网"></a>pod访问外网</h2><ul><li>首先第一步要打开本机的ip转发功能</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">1</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure><p>复制</p><ul><li>然后是设置snat规则</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A <span class="variable constant_">POSTROUTING</span> -t nat -s <span class="number">172.20</span><span class="number">.1</span><span class="number">.10</span> -j <span class="variable constant_">MASQUERADE</span></span><br></pre></td></tr></table></figure><p>复制</p><p>此时再试一下已经可以ping通百度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec ns1 ping -c <span class="number">5</span> www.<span class="property">baidu</span>.<span class="property">com</span></span><br><span class="line"></span><br><span class="line"><span class="variable constant_">PING</span> www.<span class="property">a</span>.<span class="property">shifen</span>.<span class="property">com</span> (<span class="number">14.215</span><span class="number">.177</span><span class="number">.38</span>) <span class="number">56</span>(<span class="number">84</span>) bytes <span class="keyword">of</span> data.</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">14.215</span><span class="number">.177</span><span class="number">.38</span> (<span class="number">14.215</span><span class="number">.177</span><span class="number">.38</span>): icmp\_seq=<span class="number">1</span> ttl=<span class="number">54</span> time=<span class="number">9.47</span> ms</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">14.215</span><span class="number">.177</span><span class="number">.38</span> (<span class="number">14.215</span><span class="number">.177</span><span class="number">.38</span>): icmp\_seq=<span class="number">2</span> ttl=<span class="number">54</span> time=<span class="number">9.42</span> ms</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">14.215</span><span class="number">.177</span><span class="number">.38</span> (<span class="number">14.215</span><span class="number">.177</span><span class="number">.38</span>): icmp\_seq=<span class="number">3</span> ttl=<span class="number">54</span> time=<span class="number">9.42</span> ms</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">14.215</span><span class="number">.177</span><span class="number">.38</span> (<span class="number">14.215</span><span class="number">.177</span><span class="number">.38</span>): icmp\_seq=<span class="number">4</span> ttl=<span class="number">54</span> time=<span class="number">9.33</span> ms</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">14.215</span><span class="number">.177</span><span class="number">.38</span> (<span class="number">14.215</span><span class="number">.177</span><span class="number">.38</span>): icmp\_seq=<span class="number">5</span> ttl=<span class="number">54</span> time=<span class="number">9.58</span> ms</span><br><span class="line">--- www.<span class="property">a</span>.<span class="property">shifen</span>.<span class="property">com</span> ping statistics ---</span><br><span class="line"><span class="number">5</span> packets transmitted, <span class="number">5</span> received, <span class="number">0</span>% packet loss, time 9ms</span><br><span class="line">rtt min/avg/max/mdev = <span class="number">9.332</span>/<span class="number">9.443</span>/<span class="number">9.582</span>/<span class="number">0.102</span> ms</span><br></pre></td></tr></table></figure><p>复制</p><p>至于上面的iptables规则和为何要开启转发，下一章解释serviceIP时再详细介绍。</p>]]></content>
      
      
      <categories>
          
          <category> k8s网络原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> k8s网络原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解kubernetes（k8s）网络原理之四-pod流量控制</title>
      <link href="/2022/12/17/k8s%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E5%8E%9F%E7%90%864/"/>
      <url>/2022/12/17/k8s%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E5%8E%9F%E7%90%864/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>此文章转载于<a href="https://cloud.tencent.com/developer/inventory/21543/article/1871327,%E6%88%91%E8%A7%89%E5%BE%97%E5%86%99%E5%BE%97%E9%9D%9E%E5%B8%B8%E5%A5%BD,%E6%80%95%E4%BB%96%E5%93%AA%E5%A4%A9%E4%B8%8D%E8%A7%81%E4%BA%86,%E5%B0%B1%E8%AE%B0%E5%BD%95%E4%B8%8B%E6%9D%A5%E4%BA%86">https://cloud.tencent.com/developer/inventory/21543/article/1871327,我觉得写得非常好,怕他哪天不见了,就记录下来了</a></p></blockquote><p>在前面的几篇文章中，我们解决了pod连接主机、pod连接外网、pod与相同节点或不同节点的pod连接、用clusterIP和nodeport的方式访问pod等几个问题，可以说，对于组织pod的网络的每一环都已经完成了。</p><p>和CPU、内存这类资源一样，我们肯定希望网络资源对于每个pod来说也是平均分配的，起码能做到每个pod的数据包发送与接收的速度都能控制在一定的范围内，节点的带宽不能被某个pod耗光而影响其它的pod，所以这一章我们来讨论如何控制pod的进出流量速率。</p><p>首先我们来看看这回linux给我们准备了哪些工具；</p><h2 id="TC（traffic-control）"><a href="#TC（traffic-control）" class="headerlink" title="TC（traffic control）"></a>TC（traffic control）</h2><p>linux自带流量控制框架，这个框架允许用户在数据发送前配置数据包排队规则qdisc（queueing discipline），对流量进行限制或整形，linux的tc只控制发送速率不控制接收速率，当然要控制接收速率也是有办法实现的。</p><p>对于限制网卡的发送速率，一般有两种方式：</p><ol><li>第一种是对整个网卡的发送速率进行简单粗暴的限制，例如eth0网卡的发送速率限制100mbit；</li><li>第二种是对网卡发出的流量先进行分类，再分别对每一分类的的速率单独限制，例如访问mysql的流量限制80mbit，访问http服务的流量限制20mbit；</li></ol><p>对于第一种方式，我们选择无类别队列，对于第二种方式，我们选择可分类队列。</p><h3 id="无类别队列"><a href="#无类别队列" class="headerlink" title="无类别队列"></a>无类别队列</h3><p>主要有： </p><ul><li>pfifo&#x2F;bfifo（First In First Out）：先进先出队列，只需设置队列的长度，pfifo是以数据包的个数为单位，bfifo是以字节数为单位；</li><li>pfifo_fast：数据包是按照TOS被分配多三个波段里，band0优先级最高，band1次之，band2最低，按优先级从高到低发送，在每个波段里面，使用先进先出规则；</li><li>tbf（Token Bucket Filter）：针对数据字节数进行限制，适合于把流速降低到某个值，但允许短暂突发流量超过设定值，我们限制pod的发送速率主要就用这个队列；</li><li>red（Random Early Detection）：当带宽的占用接近于规定的带宽时，系统会随机地丢弃一些数据包</li><li>sfq（Stochastic Fairness Queueing）：它按照会话为流量进行排序，然后循环发送每个会话的数据包。</li><li>FQ (Fair Queue)：公平队列</li></ul><p>在这里我们只介绍下如何创建tbf队列，因为后面主要是使用这个队列来限制pod的发送速率，下面的命令可以控制eth0的发送速率为100mbit：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tc qdisc add dev eth0 root tbf rate 100mbit burst 100mbit limit 100mbit</span><br><span class="line"></span><br><span class="line">## rate：传输速率</span><br><span class="line">## burst：桶的大小</span><br><span class="line">## limit：确定最多有多少数据（byte）在队列中等待令牌</span><br></pre></td></tr></table></figure><p>复制</p><blockquote><p>流量控制单位kbps：千字节／秒 mbps：兆字节／秒 kbit：KBits／秒 mbit：MBits／秒 bps：字节数／秒（如果不带单位，则默认单位是这个）</p></blockquote><h4 id="可分类队列"><a href="#可分类队列" class="headerlink" title="可分类队列"></a>可分类队列</h4><p>不同于无分类队列，可分类队列使用时步骤稍微复杂些，产要分三步：</p><ol><li>给网卡创建一个队列</li><li>创建队列的分类，在各个分类里可以设置不同的流量策略</li><li>创建分类规则，把流量导到第二步创建的分类</li></ol><p>可分类队列主要有：</p><ul><li>cbq(class based queueing:基于类别排队)：没用过，自行google</li><li>htb(hierarchy token bucket:层级令牌桶)：看下面的示例</li></ul><p>示例配置：访问mysql的速率限制80mbit，访问http服务的速率限制20mbit</p><ul><li>创建htb队列：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tc qdisc add dev eth0 root handle <span class="number">1</span>: htb <span class="keyword">default</span> <span class="number">11</span> ##使用htb队列，默认流量去分类<span class="number">11</span></span><br></pre></td></tr></table></figure><p>复制</p><ul><li>创建队列分类：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tc <span class="keyword">class</span> <span class="title class_">add</span> dev eth0 parent <span class="number">1</span>: classid <span class="number">1</span>:<span class="number">11</span> htb rate 80mbit ceil 80mbit  ## 创建分类<span class="number">11</span>，速率限制80mbit</span><br><span class="line">tc <span class="keyword">class</span> <span class="title class_">add</span> dev eth0 parent <span class="number">1</span>: classid <span class="number">1</span>:<span class="number">12</span> htb rate 20mbit ceil 20mbit  ## 创建分类<span class="number">12</span>，速率限制20mbit</span><br></pre></td></tr></table></figure><p>复制</p><ul><li>引导流量到分类：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tc filter add dev eth0 protocol ip parent <span class="number">1</span>:<span class="number">0</span> prio <span class="number">1</span> u32 match ip dport <span class="number">3306</span> <span class="number">0xffff</span> flowid <span class="number">1</span>:<span class="number">11</span>  ## 所有访问<span class="number">3306</span>端口的流量导到分类<span class="number">11</span>中</span><br><span class="line">tc filter add dev eth0 protocol ip parent <span class="number">1</span>:<span class="number">0</span> prio <span class="number">1</span> u32 match ip dport <span class="number">80</span> <span class="number">0xffff</span> flowid <span class="number">1</span>:<span class="number">12</span>  ## 所有访问<span class="number">80</span>端口的流量导到分类<span class="number">12</span>中</span><br></pre></td></tr></table></figure><p>复制</p><p>也可以通过来源IP+目标端口来引导流量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tc filter add dev eth0 protocol ip parent <span class="number">1</span>:<span class="number">0</span> prio <span class="number">1</span> u32 match ip src <span class="number">192.168</span><span class="number">.6</span><span class="number">.160</span> match ip dport <span class="number">23</span> oxffff flowid <span class="number">1</span>:<span class="number">11</span></span><br></pre></td></tr></table></figure><p>复制</p><p>也可以通过数据标记来引导流量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -t mangle -A <span class="variable constant_">POSTROUTING</span> -d <span class="number">10.244</span><span class="number">.1</span><span class="number">.10</span> -j <span class="variable constant_">MARK</span> –set-mark <span class="number">100</span> ## 用iptables给数据打标记</span><br><span class="line">tc filter add dev eth0 protocol ip parent <span class="number">1</span>:<span class="number">0</span> prio <span class="number">2</span> handle <span class="number">100</span> fw flowid <span class="number">1</span>:<span class="number">11</span>  ## 标记了<span class="number">100</span>的数据包引导到分类<span class="number">11</span>中</span><br></pre></td></tr></table></figure><p>复制</p><h2 id="pod的流量限制"><a href="#pod的流量限制" class="headerlink" title="pod的流量限制"></a>pod的流量限制</h2><p>首先还是在测试的主机上创建一个pod：(笔者的测试主机IP为192.168.6.160)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ip netns add pod-a</span><br><span class="line">ip link add eth0 type veth peer name veth-pod-a</span><br><span class="line">ip link set eth0 netns pod-a</span><br><span class="line">ip netns exec pod-a ip addr add <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span>/<span class="number">24</span> dev eth0</span><br><span class="line">ip netns exec pod-a ip link set eth0 up</span><br><span class="line">ip netns exec pod-a ip route add <span class="keyword">default</span> via <span class="number">169.254</span><span class="number">.10</span><span class="number">.24</span> dev eth0 onlink</span><br><span class="line">ip link set veth-pod-a up</span><br><span class="line">echo <span class="number">1</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/conf/veth-pod-a/proxy_arp</span><br><span class="line">echo <span class="number">1</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/ip_forward</span><br><span class="line">iptables -I <span class="variable constant_">FORWARD</span> -s <span class="number">192.168</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">16</span> -d <span class="number">192.168</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">16</span> -j <span class="variable constant_">ACCEPT</span></span><br><span class="line">ip route add <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span> dev veth-pod-a scope link</span><br></pre></td></tr></table></figure><p>复制</p><p>然后在主机上安装iperf3：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install iperf3</span><br></pre></td></tr></table></figure><p>复制</p><p>在pod-a中启动服务端：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec pod-a iperf3 -s</span><br></pre></td></tr></table></figure><p>复制</p><p>再开一个终端，测试一下限速前的速度：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -c <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span> -i <span class="number">1</span> -t <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Connecting</span> to host <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span>, port <span class="number">5201</span></span><br><span class="line">[  <span class="number">5</span>] local <span class="number">192.168</span><span class="number">.6</span><span class="number">.160</span> port <span class="number">50768</span> connected to <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span> port <span class="number">5201</span></span><br><span class="line">[ <span class="variable constant_">ID</span>] <span class="title class_">Interval</span>           <span class="title class_">Transfer</span>     <span class="title class_">Bitrate</span>         <span class="title class_">Retr</span>  <span class="title class_">Cwnd</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">1.00</span>   sec  <span class="number">8.19</span> <span class="title class_">GBytes</span>  <span class="number">70.3</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.35</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">1.00</span>-<span class="number">2.00</span>   sec  <span class="number">8.27</span> <span class="title class_">GBytes</span>  <span class="number">71.0</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.35</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">2.00</span>-<span class="number">3.00</span>   sec  <span class="number">8.18</span> <span class="title class_">GBytes</span>  <span class="number">70.3</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.35</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">3.00</span>-<span class="number">4.00</span>   sec  <span class="number">8.36</span> <span class="title class_">GBytes</span>  <span class="number">71.8</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.35</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">4.00</span>-<span class="number">5.00</span>   sec  <span class="number">8.46</span> <span class="title class_">GBytes</span>  <span class="number">72.7</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.35</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">5.00</span>-<span class="number">6.00</span>   sec  <span class="number">8.40</span> <span class="title class_">GBytes</span>  <span class="number">72.2</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.35</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">6.00</span>-<span class="number">7.00</span>   sec  <span class="number">8.50</span> <span class="title class_">GBytes</span>  <span class="number">73.1</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.42</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">7.00</span>-<span class="number">8.00</span>   sec  <span class="number">8.25</span> <span class="title class_">GBytes</span>  <span class="number">70.8</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.57</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">8.00</span>-<span class="number">9.00</span>   sec  <span class="number">8.53</span> <span class="title class_">GBytes</span>  <span class="number">73.2</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.57</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">9.00</span>-<span class="number">10.00</span>  sec  <span class="number">8.45</span> <span class="title class_">GBytes</span>  <span class="number">72.6</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.57</span> <span class="title class_">MBytes</span></span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">[ <span class="variable constant_">ID</span>] <span class="title class_">Interval</span>           <span class="title class_">Transfer</span>     <span class="title class_">Bitrate</span>         <span class="title class_">Retr</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">10.00</span>  sec  <span class="number">83.6</span> <span class="title class_">GBytes</span>  <span class="number">71.8</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>             sender</span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">10.04</span>  sec  <span class="number">83.6</span> <span class="title class_">GBytes</span>  <span class="number">71.5</span> <span class="title class_">Gbits</span>/sec                  receiver</span><br><span class="line">iperf <span class="title class_">Done</span>.</span><br></pre></td></tr></table></figure><p>复制</p><p>可以看到，限制前的速度为71G&#x2F;秒；</p><p>因为pod使用的是veth网卡对，所以我们可以通过主机端的网卡，达到控制pod流量的目的；</p><h3 id="控制pod的接收速率"><a href="#控制pod的接收速率" class="headerlink" title="控制pod的接收速率"></a>控制pod的接收速率</h3><p>我们控制主机网卡<code>veth-pod-a</code>的发送速率，就相当于是控制pod的接收速率，我们限制pod的接收速率为100mbit：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tc qdisc add dev veth-pod-a root tbf rate 100mbit burst 100mbit limit 100mbit</span><br></pre></td></tr></table></figure><p>复制</p><p>此时再测：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -c <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span> -i <span class="number">1</span> -t <span class="number">10</span></span><br><span class="line"> </span><br><span class="line"><span class="title class_">Connecting</span> to host <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span>, port <span class="number">5201</span></span><br><span class="line">[  <span class="number">5</span>] local <span class="number">192.168</span><span class="number">.6</span><span class="number">.160</span> port <span class="number">50626</span> connected to <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span> port <span class="number">5201</span></span><br><span class="line">[ <span class="variable constant_">ID</span>] <span class="title class_">Interval</span>           <span class="title class_">Transfer</span>     <span class="title class_">Bitrate</span>         <span class="title class_">Retr</span>  <span class="title class_">Cwnd</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">1.00</span>   sec  <span class="number">24.9</span> <span class="title class_">MBytes</span>   <span class="number">209</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>    <span class="number">389</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">1.00</span>-<span class="number">2.00</span>   sec  <span class="number">11.6</span> <span class="title class_">MBytes</span>  <span class="number">97.5</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>    <span class="number">389</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">2.00</span>-<span class="number">3.00</span>   sec  <span class="number">11.6</span> <span class="title class_">MBytes</span>  <span class="number">97.5</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>    <span class="number">389</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">3.00</span>-<span class="number">4.00</span>   sec  <span class="number">11.7</span> <span class="title class_">MBytes</span>  <span class="number">98.0</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>    <span class="number">389</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">4.00</span>-<span class="number">5.00</span>   sec  <span class="number">10.8</span> <span class="title class_">MBytes</span>  <span class="number">90.2</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>    <span class="number">389</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">5.00</span>-<span class="number">6.00</span>   sec  <span class="number">11.7</span> <span class="title class_">MBytes</span>  <span class="number">98.0</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>    <span class="number">389</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">6.00</span>-<span class="number">7.00</span>   sec  <span class="number">11.6</span> <span class="title class_">MBytes</span>  <span class="number">97.5</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>    <span class="number">389</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">7.00</span>-<span class="number">8.00</span>   sec  <span class="number">11.0</span> <span class="title class_">MBytes</span>  <span class="number">92.3</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>    <span class="number">389</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">8.00</span>-<span class="number">9.00</span>   sec  <span class="number">11.6</span> <span class="title class_">MBytes</span>  <span class="number">97.5</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>    <span class="number">389</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">9.00</span>-<span class="number">10.00</span>  sec  <span class="number">11.6</span> <span class="title class_">MBytes</span>  <span class="number">97.5</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>    <span class="number">389</span> <span class="title class_">KBytes</span></span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">[ <span class="variable constant_">ID</span>] <span class="title class_">Interval</span>           <span class="title class_">Transfer</span>     <span class="title class_">Bitrate</span>         <span class="title class_">Retr</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">10.00</span>  sec   <span class="number">128</span> <span class="title class_">MBytes</span>   <span class="number">107</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>             sender</span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">10.05</span>  sec   <span class="number">126</span> <span class="title class_">MBytes</span>   <span class="number">105</span> <span class="title class_">Mbits</span>/sec                  receiver</span><br><span class="line">iperf <span class="title class_">Done</span>.</span><br></pre></td></tr></table></figure><p>复制</p><p>看到限速后的结果为105mbit&#x2F;秒左右，符合预期</p><p>删除接收限速：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tc qdisc del dev veth-pod-a root tbf rate 100mbit burst 100mbit limit 100mbit</span><br></pre></td></tr></table></figure><p>复制</p><h3 id="控制pod的发包速率"><a href="#控制pod的发包速率" class="headerlink" title="控制pod的发包速率"></a>控制pod的发包速率</h3><p>因为linux的tc框架控发不控收，所以我们不能像上面一样，通过控制主机端<code>veth-pod-a</code>网卡的接收速率来控制pod发送速率的目的，但也不是完全没有办法：</p><h4 id="在pod内直接限制发送速率"><a href="#在pod内直接限制发送速率" class="headerlink" title="在pod内直接限制发送速率"></a>在pod内直接限制发送速率</h4><p>虽然不能在主机端控制pod的发送，但是可以直接在<a href="https://cloud.tencent.com/product/tke?from=10680">容器</a>里控制，命令和上面的一样，只不过是在pod-a的ns中执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec pod-a tc qdisc add dev eth0 root tbf rate 100mbit burst 100mbit limit 100mbit</span><br></pre></td></tr></table></figure><p>复制</p><p>因为是测试从容器发送的速率，所以我们要把iperf3的服务端调整一下，服务端跑在主机上，然后再在容器中进行发送测试：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec pod-a iperf3 -c <span class="number">192.168</span><span class="number">.6</span><span class="number">.160</span> -i <span class="number">1</span> -t <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Connecting</span> to host <span class="number">192.168</span><span class="number">.6</span><span class="number">.160</span>, port <span class="number">5201</span></span><br><span class="line">[  <span class="number">5</span>] local <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span> port <span class="number">49224</span> connected to <span class="number">192.168</span><span class="number">.6</span><span class="number">.160</span> port <span class="number">5201</span></span><br><span class="line">[ <span class="variable constant_">ID</span>] <span class="title class_">Interval</span>           <span class="title class_">Transfer</span>     <span class="title class_">Bitrate</span>         <span class="title class_">Retr</span>  <span class="title class_">Cwnd</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">1.00</span>   sec  <span class="number">26.6</span> <span class="title class_">MBytes</span>   <span class="number">223</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>    <span class="number">641</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">1.00</span>-<span class="number">2.00</span>   sec  <span class="number">11.2</span> <span class="title class_">MBytes</span>  <span class="number">94.4</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>    <span class="number">641</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">2.00</span>-<span class="number">3.00</span>   sec  <span class="number">11.2</span> <span class="title class_">MBytes</span>  <span class="number">94.4</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>    <span class="number">641</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">3.00</span>-<span class="number">4.00</span>   sec  <span class="number">11.2</span> <span class="title class_">MBytes</span>  <span class="number">94.4</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>    <span class="number">641</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">4.00</span>-<span class="number">5.00</span>   sec  <span class="number">11.2</span> <span class="title class_">MBytes</span>  <span class="number">94.4</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>    <span class="number">641</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">5.00</span>-<span class="number">6.00</span>   sec  <span class="number">12.5</span> <span class="title class_">MBytes</span>   <span class="number">105</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>    <span class="number">641</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">6.00</span>-<span class="number">7.00</span>   sec  <span class="number">11.2</span> <span class="title class_">MBytes</span>  <span class="number">94.4</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>    <span class="number">641</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">7.00</span>-<span class="number">8.00</span>   sec  <span class="number">11.2</span> <span class="title class_">MBytes</span>  <span class="number">94.4</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>    <span class="number">641</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">8.00</span>-<span class="number">9.00</span>   sec  <span class="number">11.2</span> <span class="title class_">MBytes</span>  <span class="number">94.4</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>    <span class="number">641</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">9.00</span>-<span class="number">10.00</span>  sec  <span class="number">11.2</span> <span class="title class_">MBytes</span>  <span class="number">94.4</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>    <span class="number">641</span> <span class="title class_">KBytes</span></span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">[ <span class="variable constant_">ID</span>] <span class="title class_">Interval</span>           <span class="title class_">Transfer</span>     <span class="title class_">Bitrate</span>         <span class="title class_">Retr</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">10.00</span>  sec   <span class="number">129</span> <span class="title class_">MBytes</span>   <span class="number">108</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>             sender</span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">10.04</span>  sec   <span class="number">126</span> <span class="title class_">MBytes</span>   <span class="number">105</span> <span class="title class_">Mbits</span>/sec                  receiver</span><br><span class="line">iperf <span class="title class_">Done</span>.</span><br></pre></td></tr></table></figure><p>复制</p><p>结果是105mbit&#x2F;秒，也是符合预期</p><p>删除限制：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec pod-a tc qdisc del dev eth0 root tbf rate 100mbit burst 100mbit limit 100mbit</span><br></pre></td></tr></table></figure><p>复制</p><p>通常我们会把容器的命令执行权限开给业务方，这样他们就有可能在容器里把这个速率限制取消，有没有一种办法是在主机端限制pod的发送速率呢？有。</p><h4 id="在主机端用ifb网卡的方式限制收包速率"><a href="#在主机端用ifb网卡的方式限制收包速率" class="headerlink" title="在主机端用ifb网卡的方式限制收包速率"></a>在主机端用ifb网卡的方式限制收包速率</h4><p>ifb网卡也是linux虚拟网络设备，类似于tun&#x2F;tap&#x2F;veth，只不过ifb的原理要简单得多，可以看作是一张只有tc过滤功能的虚拟网卡，而且它不会改变数据包的流向，比如把某张网卡接收流量导给ifb网卡，经过ifb的流量控制过滤后，继续走原网卡的接收流程，发送也是如此；这样我们就可以把pod在主机一端的网卡的接收重定向到ifb网卡，然后通过控制ifb网卡的发送速率，来间接控制pod的发送速率。</p><p>首先要确认内核有加载ifb模块，如果没有则加载</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modprobe ifb    <span class="comment">//需要加载ifb模块</span></span><br></pre></td></tr></table></figure><p>复制</p><p>然后创建ifb网卡，并设置发送队列长度为1000：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip link add ifb0 type ifb</span><br><span class="line">ip link set dev ifb0 up txqueuelen <span class="number">1000</span></span><br></pre></td></tr></table></figure><p>复制</p><p>把<code>veth-pod-a</code>的接收重定向到ifb网卡上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tc qdisc add dev veth-pod-a ingress handle <span class="attr">ffff</span>: </span><br><span class="line">tc filter add dev veth-pod-a parent <span class="attr">ffff</span>: protocol ip u32 match u32 <span class="number">0</span> <span class="number">0</span> flowid <span class="number">1</span>:<span class="number">1</span> action mirred egress redirect dev ifb0   <span class="comment">//重定向流量到ifb</span></span><br></pre></td></tr></table></figure><p>复制</p><p>设置ifb0的发送速率：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tc qdisc add dev ifb0 root tbf rate 100mbit burst 100mbit limit 100mbit</span><br></pre></td></tr></table></figure><p>复制</p><p>此时再测：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec pod-a  iperf3 -c <span class="number">192.168</span><span class="number">.6</span><span class="number">.160</span> -i <span class="number">1</span> -t <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Connecting</span> to host <span class="number">192.168</span><span class="number">.6</span><span class="number">.160</span>, port <span class="number">5201</span></span><br><span class="line">[  <span class="number">5</span>] local <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span> port <span class="number">54762</span> connected to <span class="number">192.168</span><span class="number">.6</span><span class="number">.160</span> port <span class="number">5201</span></span><br><span class="line">[ <span class="variable constant_">ID</span>] <span class="title class_">Interval</span>           <span class="title class_">Transfer</span>     <span class="title class_">Bitrate</span>         <span class="title class_">Retr</span>  <span class="title class_">Cwnd</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">1.00</span>   sec  <span class="number">26.5</span> <span class="title class_">MBytes</span>   <span class="number">223</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>    <span class="number">700</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">1.00</span>-<span class="number">2.00</span>   sec  <span class="number">11.2</span> <span class="title class_">MBytes</span>  <span class="number">94.4</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>    <span class="number">700</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">2.00</span>-<span class="number">3.00</span>   sec  <span class="number">11.2</span> <span class="title class_">MBytes</span>  <span class="number">94.4</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>    <span class="number">700</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">3.00</span>-<span class="number">4.00</span>   sec  <span class="number">11.2</span> <span class="title class_">MBytes</span>  <span class="number">94.4</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>    <span class="number">700</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">4.00</span>-<span class="number">5.00</span>   sec  <span class="number">12.5</span> <span class="title class_">MBytes</span>   <span class="number">105</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>    <span class="number">700</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">5.00</span>-<span class="number">6.00</span>   sec  <span class="number">11.2</span> <span class="title class_">MBytes</span>  <span class="number">94.4</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>    <span class="number">700</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">6.00</span>-<span class="number">7.00</span>   sec  <span class="number">11.2</span> <span class="title class_">MBytes</span>  <span class="number">94.4</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>    <span class="number">700</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">7.00</span>-<span class="number">8.00</span>   sec  <span class="number">11.2</span> <span class="title class_">MBytes</span>  <span class="number">94.4</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>    <span class="number">700</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">8.00</span>-<span class="number">9.00</span>   sec  <span class="number">11.2</span> <span class="title class_">MBytes</span>  <span class="number">94.4</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>    <span class="number">700</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">9.00</span>-<span class="number">10.00</span>  sec  <span class="number">11.2</span> <span class="title class_">MBytes</span>  <span class="number">94.4</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>    <span class="number">700</span> <span class="title class_">KBytes</span></span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">[ <span class="variable constant_">ID</span>] <span class="title class_">Interval</span>           <span class="title class_">Transfer</span>     <span class="title class_">Bitrate</span>         <span class="title class_">Retr</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">10.00</span>  sec   <span class="number">129</span> <span class="title class_">MBytes</span>   <span class="number">108</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>             sender</span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">10.05</span>  sec   <span class="number">126</span> <span class="title class_">MBytes</span>   <span class="number">105</span> <span class="title class_">Mbits</span>/sec                  receiver</span><br><span class="line">iperf <span class="title class_">Done</span>.</span><br></pre></td></tr></table></figure><p>复制</p><p>105mbit&#x2F;秒，符合预期，改一下速率限制，从100mbit改为200mbit：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tc qdisc replace dev ifb0 root tbf rate 200mbit burst 200mbit limit 200mbit</span><br></pre></td></tr></table></figure><p>复制</p><p>然后再测：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec pod-a  iperf3 -c <span class="number">192.168</span><span class="number">.6</span><span class="number">.160</span> -i <span class="number">1</span> -t <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Connecting</span> to host <span class="number">192.168</span><span class="number">.6</span><span class="number">.160</span>, port <span class="number">5201</span></span><br><span class="line">[  <span class="number">5</span>] local <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span> port <span class="number">56044</span> connected to <span class="number">192.168</span><span class="number">.6</span><span class="number">.160</span> port <span class="number">5201</span></span><br><span class="line">[ <span class="variable constant_">ID</span>] <span class="title class_">Interval</span>           <span class="title class_">Transfer</span>     <span class="title class_">Bitrate</span>         <span class="title class_">Retr</span>  <span class="title class_">Cwnd</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">1.00</span>   sec  <span class="number">48.0</span> <span class="title class_">MBytes</span>   <span class="number">403</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>    <span class="number">354</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">1.00</span>-<span class="number">2.00</span>   sec  <span class="number">23.1</span> <span class="title class_">MBytes</span>   <span class="number">194</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>    <span class="number">354</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">2.00</span>-<span class="number">3.00</span>   sec  <span class="number">23.1</span> <span class="title class_">MBytes</span>   <span class="number">194</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>    <span class="number">354</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">3.00</span>-<span class="number">4.00</span>   sec  <span class="number">22.4</span> <span class="title class_">MBytes</span>   <span class="number">188</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>    <span class="number">354</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">4.00</span>-<span class="number">5.00</span>   sec  <span class="number">23.1</span> <span class="title class_">MBytes</span>   <span class="number">194</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>    <span class="number">354</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">5.00</span>-<span class="number">6.00</span>   sec  <span class="number">22.4</span> <span class="title class_">MBytes</span>   <span class="number">188</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>    <span class="number">354</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">6.00</span>-<span class="number">7.00</span>   sec  <span class="number">23.1</span> <span class="title class_">MBytes</span>   <span class="number">194</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>    <span class="number">354</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">7.00</span>-<span class="number">8.00</span>   sec  <span class="number">23.1</span> <span class="title class_">MBytes</span>   <span class="number">194</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>    <span class="number">354</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">8.00</span>-<span class="number">9.00</span>   sec  <span class="number">22.4</span> <span class="title class_">MBytes</span>   <span class="number">188</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>    <span class="number">354</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">9.00</span>-<span class="number">10.00</span>  sec  <span class="number">23.1</span> <span class="title class_">MBytes</span>   <span class="number">194</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>    <span class="number">354</span> <span class="title class_">KBytes</span></span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">[ <span class="variable constant_">ID</span>] <span class="title class_">Interval</span>           <span class="title class_">Transfer</span>     <span class="title class_">Bitrate</span>         <span class="title class_">Retr</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">10.00</span>  sec   <span class="number">254</span> <span class="title class_">MBytes</span>   <span class="number">213</span> <span class="title class_">Mbits</span>/sec    <span class="number">0</span>             sender</span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">10.04</span>  sec   <span class="number">252</span> <span class="title class_">MBytes</span>   <span class="number">210</span> <span class="title class_">Mbits</span>/sec                  receiver</span><br><span class="line">iperf <span class="title class_">Done</span>.</span><br></pre></td></tr></table></figure><p>复制</p><p>210mbit&#x2F;秒，都符合预期。</p><p>删除pod-a的发送限速：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tc qdisc del dev veth-pod-a ingress</span><br><span class="line">tc qdisc del dev ifb0 root tbf rate 200mbit burst 200mbit limit 200mbit</span><br><span class="line">ip link del ifb0</span><br></pre></td></tr></table></figure><p>复制</p><p>OK，pod的流量控制也就说完了。</p><p>到目前为止，我们已经解决了一个常规则的k8s的cni需要解决的一切问题，但直到现在，也没见过go语言的影子，所以说k8s都是负责粘合功能的胶水代码，真正工作的是linux系统，与其说学习k8s的网络，不如说在学习linux提供的各种虚拟网络设备及内核协议栈的工作机制。</p><p>下一章我们来详细介绍下flannel，然后再动手用go语言撸个cni出来。</p>]]></content>
      
      
      <categories>
          
          <category> k8s网络原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> k8s网络原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解kubernetes（k8s）网络原理之五-flannel原理</title>
      <link href="/2022/12/17/k8s%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E5%8E%9F%E7%90%865/"/>
      <url>/2022/12/17/k8s%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E5%8E%9F%E7%90%865/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>此文章转载于<a href="https://cloud.tencent.com/developer/inventory/21543/article/1871939,%E6%88%91%E8%A7%89%E5%BE%97%E5%86%99%E5%BE%97%E9%9D%9E%E5%B8%B8%E5%A5%BD,%E6%80%95%E4%BB%96%E5%93%AA%E5%A4%A9%E4%B8%8D%E8%A7%81%E4%BA%86,%E5%B0%B1%E8%AE%B0%E5%BD%95%E4%B8%8B%E6%9D%A5%E4%BA%86">https://cloud.tencent.com/developer/inventory/21543/article/1871939,我觉得写得非常好,怕他哪天不见了,就记录下来了</a></p></blockquote><p>flannel有udp、vxlan和host-gw三种模式，udp模式因为性能较低现在已经比较少用到，host-gw我们在前面简单介绍过，因为使用场景比较受限，所以vxlan模式是flannel使用最多的模式，本章我们来介绍一下vxlan模式的原理。</p><p>我们在第三篇文章中已经详细介绍过vxlan如何完成跨主机pod通信，所以在这我们主要介绍flannel的几个组件的工作原理，最后也会简要介绍一下udp模式。</p><p>在vlan模式下，每个节点会有一个符合cni规范的二进制可执行文件flannel（下面简称flannel-cni），一个以k8s的daemonset方式运行的kube-flannel，下面来分别介绍下它们是干啥的：</p><h2 id="flannel-cni"><a href="#flannel-cni" class="headerlink" title="flannel-cni"></a>flannel-cni</h2><p>flannel文件存放在每个节点的&#x2F;opt&#x2F;cni&#x2F;bin目录下，这个目录下还有cni官方默认提供的其它插件，这些cni插件分为三类：</p><ul><li>ipam，负责地址分配，主要有：host-local、dhcp、static</li><li>main，负责主机和<a href="https://cloud.tencent.com/product/tke?from=10680">容器</a>网络的编织，主要有：bridge、ptp、ipvlan、macvlan、host-device、</li><li>meta，其它，主要有：flannel、bandwidth、firewall、portmap、tuning、sbr</li></ul><p>这些文件是我们在安装kubeadm和kubelet时自动安装的，如果发现这个目录为空，也可以用下面的命令手动安装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install kubernetes-cni -y</span><br></pre></td></tr></table></figure><p>复制</p><p>这个文件不做具体的容器网络编织的工作，而是生成其它cni插件需要的配置文件，然后调用其它的cni插件（通常是bridge和host-local），完成主机内容器到主机的网络互通，这个flannel-cni文件的源码已经不在flannel项目上了，而是在cni的plugins中，地址如下：</p><p><a href="https://github.com/containernetworking/plugins/tree/master/plugins/meta/flannel">https://github.com/containernetworking/plugins/tree/master/plugins/meta/flannel</a></p><h3 id="flannel-cni工作流程"><a href="#flannel-cni工作流程" class="headerlink" title="flannel-cni工作流程"></a>flannel-cni工作流程</h3><p>kubelet创建一个pod时，先会创建一个pause容器，然后用pause容器的网络命名空间为入参（类似：&#x2F;var&#x2F;run&#x2F;<a href="https://cloud.tencent.com/product/tke?from=10680">docker</a>&#x2F;netns&#x2F;xxxx，用docker inspect nginx|grep Sandbox能获取到），加上其它一些参数，调用&#x2F;etc&#x2F;cni&#x2F;net.d&#x2F;目录下的配置文件指定的cni插件，内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/cni/net.<span class="property">d</span>/<span class="number">10</span>-flannel.<span class="property">conflist</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;cbr0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;cniVersion&quot;</span>: <span class="string">&quot;0.3.1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;plugins&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;flannel&quot;</span>,</span><br><span class="line">      <span class="string">&quot;delegate&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;hairpinMode&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">&quot;isDefaultGateway&quot;</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;portmap&quot;</span>,</span><br><span class="line">      <span class="string">&quot;capabilities&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;portMappings&quot;</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复制</p><blockquote><p>这个配置文件是kube-flannel启动时复制进去的，我们编写cni时也要生成这个文件</p></blockquote><p>这个文件中指定的cni插件叫flannel，于是kubelet就调用了&#x2F;opt&#x2F;cni&#x2F;bin&#x2F;flannel文件，这个文件先会读取&#x2F;run&#x2F;flannel&#x2F;subnet.env文件，里面主要包含当前节点的子网信息，内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat /run/flannel/subnet.<span class="property">env</span></span><br><span class="line"></span><br><span class="line"><span class="variable constant_">FLANNEL_NETWORK</span>=<span class="number">10.244</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">16</span></span><br><span class="line"><span class="variable constant_">FLANNEL_SUBNET</span>=<span class="number">10.244</span><span class="number">.1</span><span class="number">.1</span>/<span class="number">24</span></span><br><span class="line"><span class="variable constant_">FLANNEL_MTU</span>=<span class="number">1450</span></span><br><span class="line"><span class="variable constant_">FLANNEL_IPMASQ</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>复制</p><blockquote><p>这个文件也是kube-flannel启动时写入的</p></blockquote><p>flannel读取该文件内容后，紧接着会生成一个符合cni标准的配置文件，内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;cniVersion&quot;</span>: <span class="string">&quot;0.3.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;networks&quot;</span>,</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;bridge&quot;</span>,</span><br><span class="line">  <span class="string">&quot;bridge&quot;</span>: <span class="string">&quot;cni0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;isDefaultGateway&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;ipam&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;host-local&quot;</span>,</span><br><span class="line">    <span class="string">&quot;subnet&quot;</span>: <span class="string">&quot;10.244.1.0/24&quot;</span>,</span><br><span class="line">    <span class="string">&quot;dataDir&quot;</span>: <span class="string">&quot;/var/lib/cni/&quot;</span>,</span><br><span class="line">    <span class="string">&quot;routes&quot;</span>: [&#123; <span class="string">&quot;dst&quot;</span>: <span class="string">&quot;0.0.0.0/0&quot;</span> &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复制</p><blockquote><p>其实可以一步到位，直接生成这个格式的文件放在&#x2F;etc&#x2F;cni&#x2F;net.d&#x2F;目录下，flannel这样处理应该是为了节点子网发生变化时不用重启kubelet吧</p></blockquote><p>然后像kubelet调用flannel的方式一样调用另一个cni插件bridge，并把上面的配置文件的内容用标准输入的方式传递过去，调用方式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">&#x27;&#123; &quot;cniVersion&quot;: &quot;0.3.0&quot;, &quot;name&quot;: &quot;network&quot;, &quot;type&quot;:&quot;bridge&quot;,&quot;bridge&quot;:&quot;cni0&quot;, &quot;ipam&quot;:&#123;&quot;type&quot;:&quot;host-local&quot;,&quot;subnet&quot;: &quot;10.244.1.0/24&quot;,&quot;dataDir&quot;: &quot;/var/lib/cni/&quot;,&quot;routes&quot;: [&#123; &quot;dst&quot;: &quot;0.0.0.0/0&quot; &#125;]&#125;&#125;&#x27;</span> | <span class="variable constant_">CNI_COMMAND</span>=<span class="variable constant_">ADD</span></span><br><span class="line"><span class="variable constant_">CNI_CONTAINERID</span>=xxx </span><br><span class="line"><span class="variable constant_">CNI_NETNS</span>=<span class="regexp">/var/</span>run/docker/netns/xxxx </span><br><span class="line"><span class="variable constant_">CNI_IFNAME</span>=xxx </span><br><span class="line"><span class="variable constant_">CNI_ARGS</span>=<span class="string">&#x27;IgnoreUnknown=1;K8S_POD_NAMESPACE=applife;K8S_POD_NAME=redis-59b4c86fd9-wrmr9&#x27;</span> </span><br><span class="line"><span class="variable constant_">CNI_PATH</span>=<span class="regexp">/opt/</span>cni/bin/ </span><br><span class="line">./bridge</span><br></pre></td></tr></table></figure><p>复制</p><blockquote><p>后面我们动手编写cni插件时，可以用上述的方式来模拟kubelet调用cni，这样测试会方便很多</p></blockquote><p>剩余的工作就会由&#x2F;opt&#x2F;cni&#x2F;bin&#x2F;bridge插件完成，它会：</p><ul><li>在主机上创建一个名为cni0的linux bridge，然后把子网的第一个地址（如示例中：10.244.1.1）绑到cni0上，这样cni0同时也是该节点上所有pod的默认网关；</li><li>在主机上创建一条主机路由：<code>ip route add 10.244.1.0/24 dev cni0 scope link src 10.244.1.1</code>，这样一来，节点到本节点所有的pod就都会走cni0了；</li><li>创建veth网卡对，把一端插到新创建的pod的ns中，另一端插到cni0网桥上；</li><li>在pod的ns为刚刚创建的veth网卡设置IP，IP为host-local分配的值，默认网关设置为cni0的IP地址：10.244.1.1；</li><li>设置网卡的mtu，这个很关键，跟使用哪种跨节点通信方案相关，如果使用vxlan，一般就是1460，如果是host-gw，就是1500；</li></ul><p>然后pod到主机、同主机的pod的通信就完成了，这就是flannel-cni完成的工作，只负责同节点pod的通信，对于跨节点pod通信由kube-flannel完成。</p><blockquote><p>host-local是以写本地文件的方式来标识哪些IP已经被占用，它会在&#x2F;var&#x2F;lib&#x2F;cni&#x2F;network&#x2F;host-local&#x2F;（这个目录其实是上面的dataDir参数指定的）目录下生成一些文件，文件名为已分配的IP，文件内容为使用该IP的容器ID，有一个指示当前已分配最新的IP的文件。</p></blockquote><h2 id="kube-flannel"><a href="#kube-flannel" class="headerlink" title="kube-flannel"></a>kube-flannel</h2><p>kube-flannel以k8s的daemonset方式运行，主要负责编织跨节点pod通信，启动后会完成以下几件事情：</p><ul><li>启动容器会把&#x2F;etc&#x2F;kube-flannel&#x2F;cni-conf.json文件复制到&#x2F;etc&#x2F;cni&#x2F;net.d&#x2F;10-flannel.conflist，这个文件是容器启动时从配置项挂载到容器上的，可以通过修改flannel部署的yaml文件来修改配置，选择使用其它的cni插件。</li><li>运行容器会从api-server中获取属于本节点的pod-cidr，然后写一个配置文件&#x2F;run&#x2F;flannel&#x2F;subnet.env给flannel-cni用</li><li>如果是vxlan模式，则创建一个名为flannel.1的vxlan设备（关闭了自动学习机制），把这个设备的MAC地址和IP以及本节点的IP记录到节点的注解中。</li><li>启动一个协程，不断地检查本机的路由信息是否被删除，如果检查到缺失，则重新创建，防止误删导致网络不通的情况。</li><li>从api-server或etcd订阅资源变化的事件，维护路由表项、邻居表项、fdb表项</li></ul><p>接下来介绍一下当kube-flannel收到节点新增事件时会完成的事情。</p><p>假设现在有一个k8s集群拥有master、node1和node2三个节点，这时候新增了一个节点node3，node3的IP为：192.168.3.10，node3上的kube-flannel为node3创建的vxlan设备IP地址为10.244.3.0，mac地址为：02:3f:39:67:7d:f9 ，相关的信息已经保存在节点的annotation上，用kubectl查看node3的节点信息如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@node1]# kubectl describe node node3</span><br><span class="line"></span><br><span class="line"><span class="title class_">Name</span>:               node3</span><br><span class="line">...</span><br><span class="line"><span class="title class_">Annotations</span>:        flannel.<span class="property">alpha</span>.<span class="property">coreos</span>.<span class="property">com</span>/backend-<span class="attr">data</span>: &#123;<span class="string">&quot;VtepMAC&quot;</span>:<span class="string">&quot;02:3f:39:67:7d:f9&quot;</span>&#125;</span><br><span class="line">                    flannel.<span class="property">alpha</span>.<span class="property">coreos</span>.<span class="property">com</span>/backend-<span class="attr">type</span>: vxlan</span><br><span class="line">                    flannel.<span class="property">alpha</span>.<span class="property">coreos</span>.<span class="property">com</span>/kube-subnet-<span class="attr">manager</span>: <span class="literal">true</span></span><br><span class="line">                    flannel.<span class="property">alpha</span>.<span class="property">coreos</span>.<span class="property">com</span>/public-<span class="attr">ip</span>: <span class="number">192.168</span><span class="number">.3</span><span class="number">.10</span></span><br><span class="line">...</span><br><span class="line"><span class="title class_">PodCIDR</span>: <span class="number">10.244</span><span class="number">.3</span><span class="number">.0</span>/<span class="number">24</span></span><br></pre></td></tr></table></figure><p>复制</p><p>node1上的kube-flannel收到node3的新增事件，会完成以下几件事：</p><ul><li>新增一条到10.244.3.0&#x2F;24的主机路由，并指示通过flannel.1设备走，下一跳为node3上的vxlan设备的IP地址<code>10.244.3.0</code>：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route add <span class="number">10.244</span><span class="number">.3</span><span class="number">.0</span>/<span class="number">24</span> via <span class="number">10.244</span><span class="number">.3</span><span class="number">.0</span> dev flannel<span class="number">.1</span> onlink</span><br></pre></td></tr></table></figure><p>复制</p><ul><li>新增一条邻居表信息，指示node3的vxlan设备10.244.3.0的mac地址为：<code>02:3f:39:67:7d:f9</code>,并用<code>nud permanent</code>指明该arp记录不会过期，不用做存活检查：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip neigh add <span class="number">10.244</span><span class="number">.3</span><span class="number">.0</span> lladdr <span class="number">02</span>:3<span class="attr">f</span>:<span class="number">39</span>:<span class="number">67</span>:7<span class="attr">d</span>:f9 dev flannel<span class="number">.1</span> nud permanent</span><br></pre></td></tr></table></figure><p>复制</p><ul><li>新增一条fdb（forwarding database)记录，指明到node3的vxlan设备的mac地址的下一跳主机为node3的ip：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bridge fdb append  <span class="number">02</span>:3<span class="attr">f</span>:<span class="number">39</span>:<span class="number">67</span>:7<span class="attr">d</span>:f9 dev vxlan0 dst <span class="number">192.168</span><span class="number">.3</span><span class="number">.10</span> self permanent</span><br></pre></td></tr></table></figure><p>复制</p><ul><li>如果在配置中启用了Directrouting，那么在这里会判断新增节点与当前节点是否在同一子网，如果是，则前面三步都不会发生，取而代之的是：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route add <span class="number">10.244</span><span class="number">.3</span><span class="number">.0</span>/<span class="number">24</span> via <span class="number">192.168</span><span class="number">.3</span><span class="number">.10</span> dev eth0 onlink</span><br></pre></td></tr></table></figure><p>复制</p><blockquote><p>注意这里的下一跳node3的节点IP，出口设备为eth0，这就是主机路由与vxlan模式下kube-flannel的主要区别</p></blockquote><p>下面我们通过一个例子来介绍一下上面新增的这些记录的实际用途，假设：</p><ul><li>pod1运行在节点node1上，pod1的IP为<code>10.244.1.3</code>；</li><li>pod2运行在节点node3，pod2的IP为<code>10.244.3.3</code>；</li></ul><p>来看一下在vxlan模式下从pod1发送数据包到pod2的详细流程；</p><h3 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h3><ol><li>数据包从pod1出来，到达node1的协议栈，node1发现目标地址并非本机地址，且本机开启了流量转发功能，于是查找路由并转发；</li><li>目标IP为<code>10.244.3.3</code>,主机路由匹配到应该走flannel.1设备，下一跳为<code>10.244.3.0</code>（上面的node3新增时，步骤一添加的路由表项就用上了）</li><li>数据包到达flannel.1设备，它会先查找下一跳IP<code>10.244.3.0</code>的mac地址，在arp表中找到了匹配的记录为<code>02:3f:39:67:7d:f9</code>（上面节点新增时，步骤二添加的ARP记录在这里就用上了）,然后完成mac头封装，准备发送。</li><li>因为是vxlan设备，发送方法与普通的网卡有些区别（详见下面的代码<code>vxlan_xmit</code>），数据包没有被提交到网卡的发送队列，而是由vxlan设备进一步封装成一个udp数据包，它会根据目标mac地址来反查下一跳的主机地址以决定把这个udp数据包发给哪个主机，这时候就会用到上面提到的fdb表了，它查到去往<code>02:3f:39:67:7d:f9</code>的下一跳主机地址为<code>192.168.3.10</code>（节点新增时，步骤三添加的FDB记录就用上了）,于是封装udp包，走<code>ip_local_out</code>，发往node3 。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linux-4.18\drivers\net\vxlan.c</span></span><br><span class="line"><span class="keyword">static</span> netdev_tx_t <span class="title function_">vxlan_xmit</span>(<span class="params">struct sk_buff *skb, struct net_device *dev</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//取链路层头部</span></span><br><span class="line">    eth = <span class="title function_">eth_hdr</span>(skb);</span><br><span class="line">    <span class="comment">// 根据目标mac地址查找fdb表项</span></span><br><span class="line">    f = <span class="title function_">vxlan_find_mac</span>(vxlan, eth-&gt;h_dest, vni);</span><br><span class="line">    ...</span><br><span class="line">    <span class="title function_">vxlan_xmit_one</span>(skb, dev, vni, fdst, did_rsc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">vxlan_xmit_one</span>(<span class="params">struct sk_buff *skb, struct net_device *dev,</span></span><br><span class="line"><span class="params">               __be32 default_vni, struct vxlan_rdst *rdst,bool did_rsc</span>)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">        <span class="comment">// 封装vxlan头</span></span><br><span class="line">        err = <span class="title function_">vxlan_build_skb</span>(skb, ndst, <span class="title function_">sizeof</span>(struct iphdr),</span><br><span class="line">                      vni, md, flags, udp_sum);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">            goto tx_error;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 封装UDP头、外部IP头，最后走ip_local_out</span></span><br><span class="line">        <span class="title function_">udp_tunnel_xmit_skb</span>(rt, sock4-&gt;sock-&gt;sk, skb, local_ip.<span class="property">sin</span>.<span class="property">sin_addr</span>.<span class="property">s_addr</span>,</span><br><span class="line">                    dst-&gt;sin.<span class="property">sin_addr</span>.<span class="property">s_addr</span>, tos, ttl, df,</span><br><span class="line">                    src_port, dst_port, xnet, !udp_sum);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复制</p><h3 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h3><ol><li>node3接收到udp包后，走主机协议栈，发现目标地址为本机，于是走INPUT方向，最终发到UDP层处理。</li><li>当我们创建vxlan设备时，vxlan的设备驱动会注册一个UDP的socket，端口默认为4789，然后为这个udp的socket的接收流程注册一个vxlan的接收函数；当linux协议栈的收包流程走到<code>udp_rcv</code>时，会调用<code>vxlan_rcv</code>处理，<code>vxlan_rcv</code>做的事情就是剥去vxlan头，将内部的一个完整的二层包重新送入主机协议栈（见下面的源码）。</li><li>剥去vxlan头部后的包重新来到主机协议栈，此时包的目标地址是10.244.3.3，经过路由判决时，发现不是本机地址，走转发，找到合适的路由，最终发往pod2。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linux-4.18\drivers\net\vxlan.c</span></span><br><span class="line"><span class="comment">//创建vxlan设备时，会调用vxlan_open -&gt; vxlan_sock_add -&gt; __vxlan_sock_add -&gt; vxlan_socket_create，最终会在这个方法中创建一个udp的socket，然后把vxlan的收包函数注册进来</span></span><br><span class="line"><span class="keyword">static</span> struct vxlan_sock *<span class="title function_">vxlan_socket_create</span>(<span class="params">struct net *net, bool ipv6,</span></span><br><span class="line"><span class="params">                          __be16 port, u32 flags</span>)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    tunnel_cfg.<span class="property">encap_rcv</span> = vxlan_rcv;   <span class="comment">//这是最关键的点，收包的时候，会把vxlan的包给vxlan_rcv处理</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">udp_rcv</span>(<span class="params">struct sk_buff *skb</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">__udp4_lib_rcv</span>(skb, &amp;udp_table, <span class="variable constant_">IPPROTO_UDP</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//udp包接收方法，从udp_rcv -&gt; __udp4_lib_rcv -&gt; udp_queue_rcv_skb，在这里，如果是vxlan设备创建的端口收的包，会给vxlan_rcv处理</span></span><br><span class="line"><span class="keyword">static</span> int <span class="title function_">udp_queue_rcv_skb</span>(<span class="params">struct sock *sk, struct sk_buff *skb</span>)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* if we&#x27;re overly short, let UDP handle it */</span></span><br><span class="line">encap_rcv = <span class="title function_">READ_ONCE</span>(up-&gt;encap_rcv);</span><br><span class="line"><span class="keyword">if</span> (encap_rcv) &#123;</span><br><span class="line">int ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Verify checksum before giving to encap */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">udp_lib_checksum_complete</span>(skb))</span><br><span class="line">goto csum_error;</span><br><span class="line"></span><br><span class="line">ret = <span class="title function_">encap_rcv</span>(sk, skb);  <span class="comment">//这里就会走到vxlan_rcv函数去</span></span><br><span class="line"><span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="title function_">__UDP_INC_STATS</span>(<span class="title function_">sock_net</span>(sk),</span><br><span class="line"><span class="variable constant_">UDP_MIB_INDATAGRAMS</span>,</span><br><span class="line">is_udplite);</span><br><span class="line"><span class="keyword">return</span> -ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Callback from net/ipv4/udp.c to receive packets */</span></span><br><span class="line"><span class="keyword">static</span> int <span class="title function_">vxlan_rcv</span>(<span class="params">struct sock *sk, struct sk_buff *skb</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//剥vxlan头    </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">__iptunnel_pull_header</span>(skb, <span class="variable constant_">VXLAN_HLEN</span>, protocol, raw_proto,</span><br><span class="line">                   !<span class="title function_">net_eq</span>(vxlan-&gt;net, <span class="title function_">dev_net</span>(vxlan-&gt;dev))))</span><br><span class="line">            goto drop;</span><br><span class="line">     ...</span><br><span class="line">     <span class="title function_">gro_cells_receive</span>(&amp;vxlan-&gt;gro_cells, skb);</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">gro_cells_receive</span>(<span class="params">struct gro_cells *gcells, struct sk_buff *skb</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!gcells-&gt;cells || <span class="title function_">skb_cloned</span>(skb) || <span class="title function_">netif_elide_gro</span>(dev))</span><br><span class="line">        <span class="comment">//非NAPI收包处理，linux虚拟网络设备接收如果需要软中断触发通常会走这里</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">netif_rx</span>(skb);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复制</p><h2 id="udp模式"><a href="#udp模式" class="headerlink" title="udp模式"></a>udp模式</h2><p>在udp模式下，每个节点还运行了一个叫<code>flanneld</code>的守护进程，这个守护进程并非以容器的方式运行，而且是实实在在地参与数据包的转发工作，这个守护进程要是挂了，通信就会中断；</p><p>这个守护进程会：</p><ul><li>开启一个unix domain socket服务，接受来自kube-flannel同步的路由信息；</li><li>打开&#x2F;dev&#x2F;net&#x2F;tun文件；</li><li>打开一个udp端口并监听（默认是8285）</li><li>并且总会把udp端口收到的数据写到tun文件，从tun文件读到的数据，通过udp发出去；</li></ul><p>每个节点同样存在一个名叫flannel.1的虚拟设备，只不过不是vxlan设备，而是一个tun设备，tun设备的工作原理是：用户态程序打开&#x2F;dev&#x2F;net&#x2F;tun文件，主机就会多一张名为tun0的网卡，任何时候往这个打开的文件写的内容都会直接被内核协议栈收包，效果就是相当于上面代码中调用了<code>netif_rx(skb)</code>的效果，而发往这个tun0网卡的数据，都会被打开&#x2F;dev&#x2F;net&#x2F;tun文件的用户程序读到，读到的内容包含IP包头及以上的全部内容（如果想读到链路层的帧头，这里就应该打开一个tap设备，tun&#x2F;tap的主要区别就在这）；</p><p>udp模式下，kube-flannel也不再写fdb表和邻居表，而是通过unix domain socket 与本节点的<code>flanneld</code>守护进程通信，把从etcd订阅到的路由信息同步给flanneld。</p><p>我们继续用上面的场景举例，说明一下udp模式下的数据包发送流程：</p><ul><li>pod1发送给pod2的数据给会被主机路由引导通过tun设备（flannel.1）发送；</li><li><code>flanneld</code>进程从打开的&#x2F;dev&#x2F;net&#x2F;tun文件收到来自pod1的数据包，目标地址是10.244.3.3，于是它要查找去往这个目标的下一跳是哪里，这个信息kube-flannel已同步，kube-flannel通过etcd可以获取到每一个pod在哪个节点中，并把pod和节点的IP的映射关系同步给flanneld；</li><li>它知道下一跳是node3后，就把从tun设备收到的包作为payload向node3的<code>flanneld</code>（端口8285）发送udp包，跟vxlan的封包的区别就是这里是没有链路层包头的相关信息的（上面说了，tun只能拿到三层及以上）</li><li>node3运行的flanneld守护进程会收到这个来自node1的包，然后把payload向打开的&#x2F;dev&#x2F;net&#x2F;tun文件写，根据tun设备的工作原理，它的另一端flannel.1网卡会收到这个包，然后就通过主机协议栈转发到pod2。</li></ul><p>flanneld是由c语言直接实现的，关键代码在&#x2F;backend&#x2F;udp&#x2F;proxy_adm64.c</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tun网卡的包通过udp发给对端</span></span><br><span class="line"><span class="keyword">static</span> int <span class="title function_">tun_to_udp</span>(<span class="params">int tun, int sock, char *buf, size_t buflen</span>) &#123;</span><br><span class="line">  struct iphdr *iph;</span><br><span class="line">  struct sockaddr_in *next_hop;</span><br><span class="line">  ssize_t pktlen = <span class="title function_">tun_recv_packet</span>(tun, buf, buflen);</span><br><span class="line">  <span class="keyword">if</span>( pktlen &lt; <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  iph = (struct iphdr *)buf;</span><br><span class="line">  next_hop = <span class="title function_">find_route</span>((in_addr_t) iph-&gt;daddr);</span><br><span class="line">  <span class="keyword">if</span>( !next_hop ) &#123;</span><br><span class="line">    <span class="title function_">send_net_unreachable</span>(tun, buf);</span><br><span class="line">    goto _active;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>( !<span class="title function_">decrement_ttl</span>(iph) ) &#123;</span><br><span class="line">    <span class="comment">/* TTL went to 0, discard.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">TODO:</span> send back ICMP Time Exceeded</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    goto _active;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sock_send_packet</span>(sock, buf, pktlen, next_hop);</span><br><span class="line"><span class="attr">_active</span>:</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从对端收到的包写到tun网卡</span></span><br><span class="line"><span class="keyword">static</span> int <span class="title function_">udp_to_tun</span>(<span class="params">int sock, int tun, char *buf, size_t buflen</span>) &#123;</span><br><span class="line">  struct iphdr *iph;</span><br><span class="line">  ssize_t pktlen = <span class="title function_">sock_recv_packet</span>(sock, buf, buflen);</span><br><span class="line">  <span class="keyword">if</span>( pktlen &lt; <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  iph = (struct iphdr *)buf;</span><br><span class="line">  <span class="keyword">if</span>( !<span class="title function_">decrement_ttl</span>(iph) ) &#123;</span><br><span class="line">    <span class="comment">/* TTL went to 0, discard.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">TODO:</span> send back ICMP Time Exceeded</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    goto _active;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">tun_send_packet</span>(tun, buf, pktlen);</span><br><span class="line"><span class="attr">_active</span>:</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复制</p><p>udp模式中守护进程<code>flanneld</code>发挥的作用与vxlan设备很接近，都是在封包拆包，只不过vxlan封包拆包全程在内核态完成，而udp模式会经过4次用户与内核态切换，性能就下降了，而且udp模式下，flanneld挂了，通信就会中断；</p><h2 id="0-9-0之前的版本"><a href="#0-9-0之前的版本" class="headerlink" title="0.9.0之前的版本"></a>0.9.0之前的版本</h2><p>特别介绍一下flannel在0.9.0版本之前，用的策略完全不一样：</p><ul><li>kube-flannel不会在新增节点的时候就增加arp表和fdb表，而是在数据包传递的过程中，需要目标ip的mac地址但没有找到时会发送一个l3miss的消息（RTM_GETNEIGH）给用户态的进程，让用户进程补充邻居表信息； </li><li>在封装udp包时，在fdb表找不到mac地址对应的fdb表项时，会发送一个l2miss消息给用户态进程，让用户态的进程补充fdb表项，让流程接着往下走。</li></ul><p>它启动时会打开下面的标志位：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">3</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/neigh/flannel<span class="number">.1</span>/app_solicit</span><br></pre></td></tr></table></figure><p>复制</p><p>这样vxlan在封包过程中如果缺少arp记录和fdb记录就会往用户进程发送消息</p><p>从0.9.0版本开始，flannel取消了监听netlink消息：</p><p><a href="https://github.com/coreos/flannel/releases/tag/v0.9.0">https://github.com/coreos/flannel/releases/tag/v0.9.0</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以看出，从0.9.0版本后的flannel在vxlan模式下，容器的通信完全由linux内核完成，已经不用kube-flannel参与了，这就意味着，哪怕在运行的过程中，kube-flannel挂掉了，也不会影响现有容器的通信，只会影响新加入的节点和新创建的容器。</p><p>了解了flannel的原理后，接下来我们照着撸一个cni吧。</p>]]></content>
      
      
      <categories>
          
          <category> k8s网络原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> k8s网络原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解kubernetes（k8s）网络原理之六-同主机pod连接的几种方式及性能对比</title>
      <link href="/2022/12/17/k8s%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E5%8E%9F%E7%90%866/"/>
      <url>/2022/12/17/k8s%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E5%8E%9F%E7%90%866/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>此文章转载于<a href="https://cloud.tencent.com/developer/inventory/21543/article/1871939,%E6%88%91%E8%A7%89%E5%BE%97%E5%86%99%E5%BE%97%E9%9D%9E%E5%B8%B8%E5%A5%BD,%E6%80%95%E4%BB%96%E5%93%AA%E5%A4%A9%E4%B8%8D%E8%A7%81%E4%BA%86,%E5%B0%B1%E8%AE%B0%E5%BD%95%E4%B8%8B%E6%9D%A5%E4%BA%86">https://cloud.tencent.com/developer/inventory/21543/article/1871939,我觉得写得非常好,怕他哪天不见了,就记录下来了</a></p></blockquote><p>本来说这一篇是要撸个cni出来的，但感觉这个没什么好说的，cni的源码github一大堆了，大概的套路也就是把前面说的命令用go语言实现一下，于是本着想到啥写啥的原则，我决定介绍一下相同主机的pod连接的另外几种方式及性能对比。</p><p>在本系列的第一篇文章中，我们介绍过pod用veth网卡连接主机，其实同主机的pod的连接方式一共有以下几种：</p><ul><li>veth连接主机，把主机当路由器用，第一篇文章就是介绍的这种方式，（下面我们简称：veth方式）</li><li>用linux bridge连接各个pod，把网关地址挂在linux bridge，flannel就是使用这种方式</li><li>macvlan，使用场景有些限制，云平台一般用不了</li><li>ipvlan，对内核有要求，默认3.10是不支持的</li><li>开启eBPF支持</li></ul><p>在这一章中我们专门来对比一下上面这几种方式的区别和性能。</p><p>因为eBPF对内核版本有要求，所以我使用的环境linux内核版本是4.18，普通的PC机，8核32G的配置；</p><blockquote><p>在执行下面的命令时，注意创建的网卡名不要与主机的物理网卡冲突，笔者使用的主机网卡是eno2，所以我都是创建名为叫eth0的网卡，但这个网卡名在你的环境中可能很容易冲突，所以注意先修改一下</p></blockquote><h2 id="veth方式"><a href="#veth方式" class="headerlink" title="veth方式"></a>veth方式</h2><p>这种方式在第一篇文章中详细介绍过，所以就直接上命令了；</p><p>创建pod-a和pod-b：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ip netns add pod-a</span><br><span class="line">ip link add eth0 type veth peer name veth-pod-a</span><br><span class="line">ip link set eth0 netns pod-a</span><br><span class="line">ip netns exec pod-a ip addr add <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span>/<span class="number">24</span> dev eth0</span><br><span class="line">ip netns exec pod-a ip link set eth0 up</span><br><span class="line">ip netns exec pod-a ip route add <span class="keyword">default</span> via <span class="number">169.254</span><span class="number">.10</span><span class="number">.24</span> dev eth0 onlink</span><br><span class="line">ip link set veth-pod-a up</span><br><span class="line">echo <span class="number">1</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/conf/veth-pod-a/proxy_arp</span><br><span class="line">ip route add <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span> dev veth-pod-a scope link</span><br><span class="line"></span><br><span class="line">ip netns add pod-b</span><br><span class="line">ip link add eth0 type veth peer name veth-pod-b</span><br><span class="line">ip link set eth0 netns pod-b</span><br><span class="line">ip netns exec pod-b ip addr add <span class="number">192.168</span><span class="number">.10</span><span class="number">.11</span>/<span class="number">24</span> dev eth0</span><br><span class="line">ip netns exec pod-b ip link set eth0 up</span><br><span class="line">ip netns exec pod-b ip route add <span class="keyword">default</span> via <span class="number">169.254</span><span class="number">.10</span><span class="number">.24</span> dev eth0 onlink</span><br><span class="line">ip link set veth-pod-b up</span><br><span class="line">echo <span class="number">1</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/conf/veth-pod-b/proxy_arp</span><br><span class="line">ip route add <span class="number">192.168</span><span class="number">.10</span><span class="number">.11</span> dev veth-pod-b scope link</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo <span class="number">1</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/ip_forward</span><br><span class="line">iptables -I <span class="variable constant_">FORWARD</span> -s <span class="number">192.168</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">16</span> -d <span class="number">192.168</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">16</span> -j <span class="variable constant_">ACCEPT</span></span><br></pre></td></tr></table></figure><p>复制</p><p>在pod-a中启动iperf3服务：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec pod-a iperf3 -s</span><br></pre></td></tr></table></figure><p>复制</p><p>另开一个终端，在pod-b中请求pod-a，测试连接性能：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec pod-b iperf3 -c <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span> -i <span class="number">1</span> -t <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Connecting</span> to host <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span>, port <span class="number">5201</span></span><br><span class="line">[  <span class="number">5</span>] local <span class="number">192.168</span><span class="number">.10</span><span class="number">.11</span> port <span class="number">35014</span> connected to <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span> port <span class="number">5201</span></span><br><span class="line">[ <span class="variable constant_">ID</span>] <span class="title class_">Interval</span>           <span class="title class_">Transfer</span>     <span class="title class_">Bitrate</span>         <span class="title class_">Retr</span>  <span class="title class_">Cwnd</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">1.00</span>   sec  <span class="number">7.32</span> <span class="title class_">GBytes</span>  <span class="number">62.9</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">964</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">1.00</span>-<span class="number">2.00</span>   sec  <span class="number">7.90</span> <span class="title class_">GBytes</span>  <span class="number">67.8</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">964</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">2.00</span>-<span class="number">3.00</span>   sec  <span class="number">7.79</span> <span class="title class_">GBytes</span>  <span class="number">66.9</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1012</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">3.00</span>-<span class="number">4.00</span>   sec  <span class="number">7.92</span> <span class="title class_">GBytes</span>  <span class="number">68.0</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1012</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">4.00</span>-<span class="number">5.00</span>   sec  <span class="number">7.89</span> <span class="title class_">GBytes</span>  <span class="number">67.8</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1012</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">5.00</span>-<span class="number">6.00</span>   sec  <span class="number">7.87</span> <span class="title class_">GBytes</span>  <span class="number">67.6</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1012</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">6.00</span>-<span class="number">7.00</span>   sec  <span class="number">7.68</span> <span class="title class_">GBytes</span>  <span class="number">66.0</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.16</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">7.00</span>-<span class="number">8.00</span>   sec  <span class="number">7.79</span> <span class="title class_">GBytes</span>  <span class="number">66.9</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.27</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">8.00</span>-<span class="number">9.00</span>   sec  <span class="number">7.75</span> <span class="title class_">GBytes</span>  <span class="number">66.5</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.47</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">9.00</span>-<span class="number">10.00</span>  sec  <span class="number">7.90</span> <span class="title class_">GBytes</span>  <span class="number">67.8</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.47</span> <span class="title class_">MBytes</span></span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">[ <span class="variable constant_">ID</span>] <span class="title class_">Interval</span>           <span class="title class_">Transfer</span>     <span class="title class_">Bitrate</span>         <span class="title class_">Retr</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">10.00</span>  sec  <span class="number">77.8</span> <span class="title class_">GBytes</span>  <span class="number">66.8</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>             sender</span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">10.04</span>  sec  <span class="number">77.8</span> <span class="title class_">GBytes</span>  <span class="number">66.6</span> <span class="title class_">Gbits</span>/sec                  receiver</span><br></pre></td></tr></table></figure><p>复制</p><p>因为大多数时候，在部署在<a href="https://cloud.tencent.com/product/tke?from=10680">容器</a>的应用间相互访问都是使用clusterIP的，所以也要测试一下用clusterIP访问，先用iptables创建clusterIP，这个我们在第二篇文章介绍过：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A <span class="variable constant_">PREROUTING</span> -t nat -d <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span> -j <span class="variable constant_">DNAT</span> --to-destination <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span></span><br></pre></td></tr></table></figure><p>复制</p><blockquote><p>为了保证测试结果不受其它因素的干扰，最好确保主机上只有一条nat规则，这条nat规则可以全程使用，后面不再反复地删除并创建了</p></blockquote><p>结果如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec pod-b iperf3 -c <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span> -i <span class="number">1</span> -t <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Connecting</span> to host <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span>, port <span class="number">5201</span></span><br><span class="line">[  <span class="number">5</span>] local <span class="number">192.168</span><span class="number">.10</span><span class="number">.11</span> port <span class="number">44528</span> connected to <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span> port <span class="number">5201</span></span><br><span class="line">[ <span class="variable constant_">ID</span>] <span class="title class_">Interval</span>           <span class="title class_">Transfer</span>     <span class="title class_">Bitrate</span>         <span class="title class_">Retr</span>  <span class="title class_">Cwnd</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">1.00</span>   sec  <span class="number">6.41</span> <span class="title class_">GBytes</span>  <span class="number">55.0</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">725</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">1.00</span>-<span class="number">2.00</span>   sec  <span class="number">7.21</span> <span class="title class_">GBytes</span>  <span class="number">61.9</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">902</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">2.00</span>-<span class="number">3.00</span>   sec  <span class="number">7.99</span> <span class="title class_">GBytes</span>  <span class="number">68.6</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">902</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">3.00</span>-<span class="number">4.00</span>   sec  <span class="number">7.88</span> <span class="title class_">GBytes</span>  <span class="number">67.7</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">902</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">4.00</span>-<span class="number">5.00</span>   sec  <span class="number">7.94</span> <span class="title class_">GBytes</span>  <span class="number">68.2</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">947</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">5.00</span>-<span class="number">6.00</span>   sec  <span class="number">7.86</span> <span class="title class_">GBytes</span>  <span class="number">67.5</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">947</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">6.00</span>-<span class="number">7.00</span>   sec  <span class="number">7.79</span> <span class="title class_">GBytes</span>  <span class="number">66.9</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">947</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">7.00</span>-<span class="number">8.00</span>   sec  <span class="number">8.04</span> <span class="title class_">GBytes</span>  <span class="number">69.1</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">947</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">8.00</span>-<span class="number">9.00</span>   sec  <span class="number">7.85</span> <span class="title class_">GBytes</span>  <span class="number">67.5</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">996</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">9.00</span>-<span class="number">10.00</span>  sec  <span class="number">7.88</span> <span class="title class_">GBytes</span>  <span class="number">67.7</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">996</span> <span class="title class_">KBytes</span></span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">[ <span class="variable constant_">ID</span>] <span class="title class_">Interval</span>           <span class="title class_">Transfer</span>     <span class="title class_">Bitrate</span>         <span class="title class_">Retr</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">10.00</span>  sec  <span class="number">76.9</span> <span class="title class_">GBytes</span>  <span class="number">66.0</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>             sender</span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">10.04</span>  sec  <span class="number">76.9</span> <span class="title class_">GBytes</span>  <span class="number">65.8</span> <span class="title class_">Gbits</span>/sec                  receiver</span><br></pre></td></tr></table></figure><p>复制</p><p>可以看到，在veth方式下，使用podIP或通过clusterIP访问pod在性能上区别是不大的，当然在iptables的规则很多的时候（例如2000个k8s服务），性能就会有影响了，但这并不是我们这一篇文章的重点；</p><p>清理一下现场，先停止iperf3服务，然后删除ns（上面的iptables规则留着）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip netns del pod-a</span><br><span class="line">ip netns del pod-b</span><br></pre></td></tr></table></figure><p>复制</p><p>我们接着来试一下bridge方式。</p><h2 id="bridge方式"><a href="#bridge方式" class="headerlink" title="bridge方式"></a>bridge方式</h2><p>如果把bridge当成纯二层的交换机来负责两个pod的连接性能是很不错的，比上面用veth的方式要好，但是因为要支持k8s的serviceIP，所以有必要让数据包走一遍主机的iptables规则，所以一般都会给bridge挂个网关的IP，一来能响应pod的ARP请求，这样也就不用开启veth网卡对主机这一端的arp代答，再来这样能让数据包走一遍主机的netfilter的扩展函数，这样iptables规则就能生效了。</p><blockquote><p>按理说linux bridge作为交换机是工作在二层，可是从源码中可以看到bridge是实实在在地执行了netfilter的几个hook点的函数的（PREROUTING&#x2F;INPUT&#x2F;FORWARD&#x2F;OUTPUT&#x2F;POSTROUTING），当然也有开关可以关闭这个功能（net.bridge.bridge-nf-call-iptables）</p></blockquote><p>下面我们来测一下用bridge连接两个pod时的性能，创建br0的bridge然后把pod-a和pod-b都接上去：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ip link add br0 type bridge </span><br><span class="line">ip addr add <span class="number">192.168</span><span class="number">.10</span><span class="number">.1</span> dev br0  ## 给br0挂pod的默认网关的<span class="variable constant_">IP</span></span><br><span class="line">ip link set br0 up</span><br><span class="line"></span><br><span class="line">ip netns add pod-a</span><br><span class="line">ip link add eth0 type veth peer name veth-pod-a</span><br><span class="line">ip link set eth0 netns pod-a</span><br><span class="line">ip netns exec pod-a ip addr add <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span>/<span class="number">24</span> dev eth0</span><br><span class="line">ip netns exec pod-a ip link set eth0 up</span><br><span class="line">ip netns exec pod-a ip route add <span class="keyword">default</span> via <span class="number">192.168</span><span class="number">.10</span><span class="number">.1</span> dev eth0 onlink  ## 默认网关是br0的地址</span><br><span class="line">ip link set veth-pod-a master br0  ## veth网卡主机这一端插到bridge上</span><br><span class="line">ip link set veth-pod-a up</span><br><span class="line"></span><br><span class="line">ip netns add pod-b</span><br><span class="line">ip link add eth0 type veth peer name veth-pod-b</span><br><span class="line">ip link set eth0 netns pod-b</span><br><span class="line">ip netns exec pod-b ip addr add <span class="number">192.168</span><span class="number">.10</span><span class="number">.11</span>/<span class="number">24</span> dev eth0</span><br><span class="line">ip netns exec pod-b ip link set eth0 up</span><br><span class="line">ip netns exec pod-b ip route add <span class="keyword">default</span> via <span class="number">192.168</span><span class="number">.10</span><span class="number">.1</span> dev eth0 onlink</span><br><span class="line">ip link set veth-pod-b master br0</span><br><span class="line">ip link set veth-pod-b up</span><br><span class="line"></span><br><span class="line">ip route add <span class="number">192.168</span><span class="number">.10</span><span class="number">.0</span>/<span class="number">24</span> via <span class="number">192.168</span><span class="number">.10</span><span class="number">.1</span> dev br0 scope link  ## 主机到所有的pod的路由，下一跳为br0</span><br></pre></td></tr></table></figure><p>复制</p><p>再次在pod-a中运行iperf3：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec pod-a iperf3 -s</span><br></pre></td></tr></table></figure><p>复制</p><p>在pod-b中测试连接性能：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec pod-b iperf3 -c <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span> -i <span class="number">1</span> -t <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Connecting</span> to host <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span>, port <span class="number">5201</span></span><br><span class="line">[  <span class="number">5</span>] local <span class="number">192.168</span><span class="number">.10</span><span class="number">.11</span> port <span class="number">38232</span> connected to <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span> port <span class="number">5201</span></span><br><span class="line">[ <span class="variable constant_">ID</span>] <span class="title class_">Interval</span>           <span class="title class_">Transfer</span>     <span class="title class_">Bitrate</span>         <span class="title class_">Retr</span>  <span class="title class_">Cwnd</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">1.00</span>   sec  <span class="number">7.64</span> <span class="title class_">GBytes</span>  <span class="number">65.6</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">642</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">1.00</span>-<span class="number">2.00</span>   sec  <span class="number">7.71</span> <span class="title class_">GBytes</span>  <span class="number">66.2</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">642</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">2.00</span>-<span class="number">3.00</span>   sec  <span class="number">7.49</span> <span class="title class_">GBytes</span>  <span class="number">64.4</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">786</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">3.00</span>-<span class="number">4.00</span>   sec  <span class="number">7.61</span> <span class="title class_">GBytes</span>  <span class="number">65.3</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">786</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">4.00</span>-<span class="number">5.00</span>   sec  <span class="number">7.54</span> <span class="title class_">GBytes</span>  <span class="number">64.8</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">786</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">5.00</span>-<span class="number">6.00</span>   sec  <span class="number">7.71</span> <span class="title class_">GBytes</span>  <span class="number">66.2</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">786</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">6.00</span>-<span class="number">7.00</span>   sec  <span class="number">7.66</span> <span class="title class_">GBytes</span>  <span class="number">65.8</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">826</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">7.00</span>-<span class="number">8.00</span>   sec  <span class="number">7.63</span> <span class="title class_">GBytes</span>  <span class="number">65.5</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">826</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">8.00</span>-<span class="number">9.00</span>   sec  <span class="number">7.64</span> <span class="title class_">GBytes</span>  <span class="number">65.7</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">826</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">9.00</span>-<span class="number">10.00</span>  sec  <span class="number">7.71</span> <span class="title class_">GBytes</span>  <span class="number">66.2</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">826</span> <span class="title class_">KBytes</span></span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">[ <span class="variable constant_">ID</span>] <span class="title class_">Interval</span>           <span class="title class_">Transfer</span>     <span class="title class_">Bitrate</span>         <span class="title class_">Retr</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">10.00</span>  sec  <span class="number">76.3</span> <span class="title class_">GBytes</span>  <span class="number">65.6</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>             sender</span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">10.04</span>  sec  <span class="number">76.3</span> <span class="title class_">GBytes</span>  <span class="number">65.3</span> <span class="title class_">Gbits</span>/sec                  receiver</span><br></pre></td></tr></table></figure><p>复制</p><p>与veth差距并不大，反复测了几次，都差不多，对于这个结果我觉得有点不科学，从源码上看，bridge转发的流程肯定要比走一遍主机的协议栈转发要快的，于是我想了一下，是不是把bridge执行netfilter扩展函数关闭会好一点呢？于是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w net.<span class="property">bridge</span>.<span class="property">bridge</span>-nf-call-iptables=<span class="number">0</span></span><br></pre></td></tr></table></figure><p>复制</p><p>再次试了一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec pod-b iperf3 -c <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span> -i <span class="number">1</span> -t <span class="number">10</span></span><br><span class="line"> </span><br><span class="line"><span class="title class_">Connecting</span> to host <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span>, port <span class="number">5201</span></span><br><span class="line">[  <span class="number">5</span>] local <span class="number">192.168</span><span class="number">.10</span><span class="number">.11</span> port <span class="number">40658</span> connected to <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span> port <span class="number">5201</span></span><br><span class="line">[ <span class="variable constant_">ID</span>] <span class="title class_">Interval</span>           <span class="title class_">Transfer</span>     <span class="title class_">Bitrate</span>         <span class="title class_">Retr</span>  <span class="title class_">Cwnd</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">1.00</span>   sec  <span class="number">8.55</span> <span class="title class_">GBytes</span>  <span class="number">73.4</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">810</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">1.00</span>-<span class="number">2.00</span>   sec  <span class="number">8.86</span> <span class="title class_">GBytes</span>  <span class="number">76.1</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">940</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">2.00</span>-<span class="number">3.00</span>   sec  <span class="number">8.96</span> <span class="title class_">GBytes</span>  <span class="number">77.0</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">940</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">3.00</span>-<span class="number">4.00</span>   sec  <span class="number">9.04</span> <span class="title class_">GBytes</span>  <span class="number">77.6</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">940</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">4.00</span>-<span class="number">5.00</span>   sec  <span class="number">8.89</span> <span class="title class_">GBytes</span>  <span class="number">76.4</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">987</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">5.00</span>-<span class="number">6.00</span>   sec  <span class="number">9.18</span> <span class="title class_">GBytes</span>  <span class="number">78.9</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">987</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">6.00</span>-<span class="number">7.00</span>   sec  <span class="number">9.09</span> <span class="title class_">GBytes</span>  <span class="number">78.1</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">987</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">7.00</span>-<span class="number">8.00</span>   sec  <span class="number">9.10</span> <span class="title class_">GBytes</span>  <span class="number">78.1</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.01</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">8.00</span>-<span class="number">9.00</span>   sec  <span class="number">8.98</span> <span class="title class_">GBytes</span>  <span class="number">77.1</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.12</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">9.00</span>-<span class="number">10.00</span>  sec  <span class="number">9.13</span> <span class="title class_">GBytes</span>  <span class="number">78.4</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.12</span> <span class="title class_">MBytes</span></span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">[ <span class="variable constant_">ID</span>] <span class="title class_">Interval</span>           <span class="title class_">Transfer</span>     <span class="title class_">Bitrate</span>         <span class="title class_">Retr</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">10.00</span>  sec  <span class="number">89.8</span> <span class="title class_">GBytes</span>  <span class="number">77.1</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>             sender</span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">10.04</span>  sec  <span class="number">89.8</span> <span class="title class_">GBytes</span>  <span class="number">76.8</span> <span class="title class_">Gbits</span>/sec                  receiver</span><br></pre></td></tr></table></figure><p>复制</p><p>果然，是会快许多的，但这结果多少令我也有点吃惊，我已经确保主机上只有一条iptables规则，只是开启了bridge执行netfilter扩展函数居然前后会相差10Gbits&#x2F;sec。</p><p>但是，这个标志是不能关的，前面说了，要执行iptables规则把clusterIP转成podIP，所以还是要开起来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w net.<span class="property">bridge</span>.<span class="property">bridge</span>-nf-call-iptables=<span class="number">1</span></span><br></pre></td></tr></table></figure><p>复制</p><p>这时候用clusterIP试试：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec pod-b iperf3 -c <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span> -i <span class="number">1</span> -t <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Connecting</span> to host <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span>, port <span class="number">5201</span></span><br><span class="line">[  <span class="number">5</span>] local <span class="number">192.168</span><span class="number">.10</span><span class="number">.11</span> port <span class="number">47414</span> connected to <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span> port <span class="number">5201</span></span><br><span class="line">[ <span class="variable constant_">ID</span>] <span class="title class_">Interval</span>           <span class="title class_">Transfer</span>     <span class="title class_">Bitrate</span>         <span class="title class_">Retr</span>  <span class="title class_">Cwnd</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">1.00</span>   sec  <span class="number">7.02</span> <span class="title class_">GBytes</span>  <span class="number">60.3</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">669</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">1.00</span>-<span class="number">2.00</span>   sec  <span class="number">7.23</span> <span class="title class_">GBytes</span>  <span class="number">62.1</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">738</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">2.00</span>-<span class="number">3.00</span>   sec  <span class="number">7.17</span> <span class="title class_">GBytes</span>  <span class="number">61.6</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">899</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">3.00</span>-<span class="number">4.00</span>   sec  <span class="number">7.21</span> <span class="title class_">GBytes</span>  <span class="number">62.0</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">899</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">4.00</span>-<span class="number">5.00</span>   sec  <span class="number">7.31</span> <span class="title class_">GBytes</span>  <span class="number">62.8</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">899</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">5.00</span>-<span class="number">6.00</span>   sec  <span class="number">7.19</span> <span class="title class_">GBytes</span>  <span class="number">61.8</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1008</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">6.00</span>-<span class="number">7.00</span>   sec  <span class="number">7.24</span> <span class="title class_">GBytes</span>  <span class="number">62.2</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1008</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">7.00</span>-<span class="number">8.00</span>   sec  <span class="number">7.22</span> <span class="title class_">GBytes</span>  <span class="number">62.0</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.26</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">8.00</span>-<span class="number">9.00</span>   sec  <span class="number">6.99</span> <span class="title class_">GBytes</span>  <span class="number">60.0</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.26</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">9.00</span>-<span class="number">10.00</span>  sec  <span class="number">7.07</span> <span class="title class_">GBytes</span>  <span class="number">60.8</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.26</span> <span class="title class_">MBytes</span></span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">[ <span class="variable constant_">ID</span>] <span class="title class_">Interval</span>           <span class="title class_">Transfer</span>     <span class="title class_">Bitrate</span>         <span class="title class_">Retr</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">10.00</span>  sec  <span class="number">71.6</span> <span class="title class_">GBytes</span>  <span class="number">61.5</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>             sender</span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">10.04</span>  sec  <span class="number">71.6</span> <span class="title class_">GBytes</span>  <span class="number">61.3</span> <span class="title class_">Gbits</span>/sec                  receiver</span><br></pre></td></tr></table></figure><p>复制</p><p>反复试了几次，大概都是这个值，可以看到，使用clusterIP比直接用podIP访问性能下降了8%；</p><p>接着来测macvlan，先清理一下现场：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip netns del pod-a</span><br><span class="line">ip netns del pod-b</span><br><span class="line">ip link del br0</span><br></pre></td></tr></table></figure><p>复制</p><h2 id="macvlan"><a href="#macvlan" class="headerlink" title="macvlan"></a>macvlan</h2><p>macvlan模式是从一个物理网卡虚拟出多个虚拟网络接口，每个虚拟的接口都有单独的mac地址，可以给这些虚拟接口配置IP地址，在bridge模式下（其它几种模式不适用，所以不作讨论），父接口作为交换机来完成子接口间的通信，子接口可以通过父接口访问外网；</p><p>我们使用bridge模式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ip link add link eno2 name eth0 type macvlan mode bridge  ## eno2是我的物理网卡名称，eth0是我虚拟出来的接口名，请根据你的实际情况修改</span><br><span class="line">ip netns add pod-a</span><br><span class="line">ip l set eth0 netns pod-a</span><br><span class="line">ip netns exec pod-a ip addr add <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span>/<span class="number">24</span> dev eth0</span><br><span class="line">ip netns exec pod-a ip link set eth0 up</span><br><span class="line">ip netns exec pod-a ip route add <span class="keyword">default</span> via <span class="number">192.168</span><span class="number">.10</span><span class="number">.1</span> dev eth0  </span><br><span class="line"></span><br><span class="line">ip link add link eno2 name eth0 type macvlan mode bridge</span><br><span class="line">ip netns add pod-b</span><br><span class="line">ip l set eth0 netns pod-b</span><br><span class="line">ip netns exec pod-b ip addr add <span class="number">192.168</span><span class="number">.10</span><span class="number">.11</span>/<span class="number">24</span> dev eth0</span><br><span class="line">ip netns exec pod-b ip link set eth0 up</span><br><span class="line">ip netns exec pod-b ip route add <span class="keyword">default</span> via <span class="number">192.168</span><span class="number">.10</span><span class="number">.1</span> dev eth0</span><br><span class="line"></span><br><span class="line">ip link add link eno2 name eth0 type macvlan mode bridge</span><br><span class="line">ip addr add <span class="number">192.168</span><span class="number">.10</span><span class="number">.1</span>/<span class="number">24</span> dev eth0  ## 多创建一个子接口，留在主机上，把pod的默认网关的<span class="variable constant_">IP</span>挂这里，这样pod里面请求clusterIP的流量会走到主机来，主机协议栈的iptables规则就有机会执行了</span><br><span class="line">ip link set eth0 up</span><br><span class="line"></span><br><span class="line">iptables -A <span class="variable constant_">POSTROUTING</span> -t nat -s <span class="number">192.168</span><span class="number">.10</span><span class="number">.0</span>/<span class="number">24</span> -d <span class="number">192.168</span><span class="number">.10</span><span class="number">.0</span>/<span class="number">24</span> -j <span class="variable constant_">MASQUERADE</span>  ## 要让回包也经过主机协议栈，所以要做源地址转换</span><br></pre></td></tr></table></figure><p>复制</p><p>测试结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec pod-b iperf3 -c <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span> -i <span class="number">1</span> -t <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Connecting</span> to host <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span>, port <span class="number">5201</span></span><br><span class="line">[  <span class="number">5</span>] local <span class="number">192.168</span><span class="number">.10</span><span class="number">.11</span> port <span class="number">47050</span> connected to <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span> port <span class="number">5201</span></span><br><span class="line">[ <span class="variable constant_">ID</span>] <span class="title class_">Interval</span>           <span class="title class_">Transfer</span>     <span class="title class_">Bitrate</span>         <span class="title class_">Retr</span>  <span class="title class_">Cwnd</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">1.00</span>   sec  <span class="number">9.47</span> <span class="title class_">GBytes</span>  <span class="number">81.3</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">976</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">1.00</span>-<span class="number">2.00</span>   sec  <span class="number">9.81</span> <span class="title class_">GBytes</span>  <span class="number">84.3</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">976</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">2.00</span>-<span class="number">3.00</span>   sec  <span class="number">9.74</span> <span class="title class_">GBytes</span>  <span class="number">83.6</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.16</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">3.00</span>-<span class="number">4.00</span>   sec  <span class="number">9.77</span> <span class="title class_">GBytes</span>  <span class="number">83.9</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.16</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">4.00</span>-<span class="number">5.00</span>   sec  <span class="number">9.73</span> <span class="title class_">GBytes</span>  <span class="number">83.6</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.16</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">5.00</span>-<span class="number">6.00</span>   sec  <span class="number">9.69</span> <span class="title class_">GBytes</span>  <span class="number">83.2</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.16</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">6.00</span>-<span class="number">7.00</span>   sec  <span class="number">9.75</span> <span class="title class_">GBytes</span>  <span class="number">83.7</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.22</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">7.00</span>-<span class="number">8.00</span>   sec  <span class="number">9.78</span> <span class="title class_">GBytes</span>  <span class="number">84.0</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.30</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">8.00</span>-<span class="number">9.00</span>   sec  <span class="number">9.81</span> <span class="title class_">GBytes</span>  <span class="number">84.3</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.30</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">9.00</span>-<span class="number">10.00</span>  sec  <span class="number">9.84</span> <span class="title class_">GBytes</span>  <span class="number">84.5</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.30</span> <span class="title class_">MBytes</span></span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">[ <span class="variable constant_">ID</span>] <span class="title class_">Interval</span>           <span class="title class_">Transfer</span>     <span class="title class_">Bitrate</span>         <span class="title class_">Retr</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">10.00</span>  sec  <span class="number">97.4</span> <span class="title class_">GBytes</span>  <span class="number">83.6</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>             sender</span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">10.04</span>  sec  <span class="number">97.4</span> <span class="title class_">GBytes</span>  <span class="number">83.3</span> <span class="title class_">Gbits</span>/sec                  receiver</span><br></pre></td></tr></table></figure><p>复制</p><p>直接用podIP访问是非常快的，几种方式中最快的；</p><p>用clusterIP试试：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec pod-b iperf3 -c <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span> -i <span class="number">1</span> -t <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Connecting</span> to host <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span>, port <span class="number">5201</span></span><br><span class="line">[  <span class="number">5</span>] local <span class="number">192.168</span><span class="number">.10</span><span class="number">.11</span> port <span class="number">35780</span> connected to <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span> port <span class="number">5201</span></span><br><span class="line">[ <span class="variable constant_">ID</span>] <span class="title class_">Interval</span>           <span class="title class_">Transfer</span>     <span class="title class_">Bitrate</span>         <span class="title class_">Retr</span>  <span class="title class_">Cwnd</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">1.00</span>   sec  <span class="number">7.16</span> <span class="title class_">GBytes</span>  <span class="number">61.5</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">477</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">1.00</span>-<span class="number">2.00</span>   sec  <span class="number">7.18</span> <span class="title class_">GBytes</span>  <span class="number">61.7</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">477</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">2.00</span>-<span class="number">3.00</span>   sec  <span class="number">7.13</span> <span class="title class_">GBytes</span>  <span class="number">61.2</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">608</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">3.00</span>-<span class="number">4.00</span>   sec  <span class="number">7.18</span> <span class="title class_">GBytes</span>  <span class="number">61.7</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">670</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">4.00</span>-<span class="number">5.00</span>   sec  <span class="number">7.16</span> <span class="title class_">GBytes</span>  <span class="number">61.5</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">670</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">5.00</span>-<span class="number">6.00</span>   sec  <span class="number">7.30</span> <span class="title class_">GBytes</span>  <span class="number">62.7</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">822</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">6.00</span>-<span class="number">7.00</span>   sec  <span class="number">7.34</span> <span class="title class_">GBytes</span>  <span class="number">63.1</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">822</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">7.00</span>-<span class="number">8.00</span>   sec  <span class="number">7.30</span> <span class="title class_">GBytes</span>  <span class="number">62.7</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.00</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">8.00</span>-<span class="number">9.00</span>   sec  <span class="number">7.19</span> <span class="title class_">GBytes</span>  <span class="number">61.8</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.33</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">9.00</span>-<span class="number">10.00</span>  sec  <span class="number">7.15</span> <span class="title class_">GBytes</span>  <span class="number">61.4</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.33</span> <span class="title class_">MBytes</span></span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">[ <span class="variable constant_">ID</span>] <span class="title class_">Interval</span>           <span class="title class_">Transfer</span>     <span class="title class_">Bitrate</span>         <span class="title class_">Retr</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">10.00</span>  sec  <span class="number">72.1</span> <span class="title class_">GBytes</span>  <span class="number">61.9</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>             sender</span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">10.04</span>  sec  <span class="number">72.1</span> <span class="title class_">GBytes</span>  <span class="number">61.7</span> <span class="title class_">Gbits</span>/sec                  receiver</span><br></pre></td></tr></table></figure><p>复制</p><p>走一遍主机的内核协议栈就下降了将近25%；</p><p>清理一下现场：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip netns del pod-a</span><br><span class="line">ip netns del pod-b</span><br><span class="line">iptables -D <span class="variable constant_">POSTROUTING</span> -t nat -s <span class="number">192.168</span><span class="number">.10</span><span class="number">.0</span>/<span class="number">24</span> -d <span class="number">192.168</span><span class="number">.10</span><span class="number">.0</span>/<span class="number">24</span> -j <span class="variable constant_">MASQUERADE</span></span><br></pre></td></tr></table></figure><p>复制</p><h2 id="ipvlan"><a href="#ipvlan" class="headerlink" title="ipvlan"></a>ipvlan</h2><p>与macvlan类似，ipvlan也是在一个物理网卡上虚拟出多个子接口，与macvlan不同的是，ipvlan的每一个子接口的mac地址是一样的，IP地址不同；</p><p>ipvlan有l2和l3模式，l2模式下，与macvlan的工作原理类似，父接口作为交换机来转发子接口的数据包，不同的是，ipvlan的流量转发时是通过dmac&#x3D;&#x3D;smac来判断这是子接口间的通信的；</p><p>l2模式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ip l add link eno2 name eth0 type ipvlan mode l2</span><br><span class="line">ip netns add pod-a</span><br><span class="line">ip l set eth0 netns pod-a</span><br><span class="line">ip netns exec pod-a ip addr add <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span>/<span class="number">24</span> dev eth0</span><br><span class="line">ip netns exec pod-a ip link set eth0 up</span><br><span class="line">ip netns exec pod-a ip route add <span class="keyword">default</span> via <span class="number">192.168</span><span class="number">.10</span><span class="number">.1</span> dev eth0</span><br><span class="line"></span><br><span class="line">ip l add link eno2 name eth0 type ipvlan mode l2</span><br><span class="line">ip netns add pod-b</span><br><span class="line">ip l set eth0 netns pod-b</span><br><span class="line">ip netns exec pod-b ip addr add <span class="number">192.168</span><span class="number">.10</span><span class="number">.11</span>/<span class="number">24</span> dev eth0</span><br><span class="line">ip netns exec pod-b ip link set eth0 up</span><br><span class="line">ip netns exec pod-b ip route add <span class="keyword">default</span> via <span class="number">192.168</span><span class="number">.10</span><span class="number">.1</span> dev eth0</span><br><span class="line"></span><br><span class="line">ip link add link eno2 name eth0 type ipvlan mode l2</span><br><span class="line">ip link set eth0 up</span><br><span class="line">ip addr add <span class="number">192.168</span><span class="number">.10</span><span class="number">.1</span>/<span class="number">24</span> dev eth0</span><br><span class="line"></span><br><span class="line">iptables -A <span class="variable constant_">POSTROUTING</span> -t nat -s <span class="number">192.168</span><span class="number">.10</span><span class="number">.0</span>/<span class="number">24</span> -d <span class="number">192.168</span><span class="number">.10</span><span class="number">.0</span>/<span class="number">24</span> -j <span class="variable constant_">MASQUERADE</span>  ##跟上面的一样，也是要让回包经过主机协议栈，所以要做源地址转换</span><br></pre></td></tr></table></figure><p>复制</p><p>测试结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec pod-b iperf3 -c <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span> -i <span class="number">1</span> -t <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Connecting</span> to host <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span>, port <span class="number">5201</span></span><br><span class="line">[  <span class="number">5</span>] local <span class="number">192.168</span><span class="number">.10</span><span class="number">.11</span> port <span class="number">59580</span> connected to <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span> port <span class="number">5201</span></span><br><span class="line">[ <span class="variable constant_">ID</span>] <span class="title class_">Interval</span>           <span class="title class_">Transfer</span>     <span class="title class_">Bitrate</span>         <span class="title class_">Retr</span>  <span class="title class_">Cwnd</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">1.00</span>   sec  <span class="number">9.70</span> <span class="title class_">GBytes</span>  <span class="number">83.3</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">748</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">1.00</span>-<span class="number">2.00</span>   sec  <span class="number">9.71</span> <span class="title class_">GBytes</span>  <span class="number">83.4</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">748</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">2.00</span>-<span class="number">3.00</span>   sec  <span class="number">10.1</span> <span class="title class_">GBytes</span>  <span class="number">86.9</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">748</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">3.00</span>-<span class="number">4.00</span>   sec  <span class="number">9.84</span> <span class="title class_">GBytes</span>  <span class="number">84.5</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">826</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">4.00</span>-<span class="number">5.00</span>   sec  <span class="number">9.82</span> <span class="title class_">GBytes</span>  <span class="number">84.3</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">826</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">5.00</span>-<span class="number">6.00</span>   sec  <span class="number">9.74</span> <span class="title class_">GBytes</span>  <span class="number">83.6</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.19</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">6.00</span>-<span class="number">7.00</span>   sec  <span class="number">9.77</span> <span class="title class_">GBytes</span>  <span class="number">83.9</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.19</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">7.00</span>-<span class="number">8.00</span>   sec  <span class="number">9.53</span> <span class="title class_">GBytes</span>  <span class="number">81.8</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.41</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">8.00</span>-<span class="number">9.00</span>   sec  <span class="number">9.56</span> <span class="title class_">GBytes</span>  <span class="number">82.1</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.41</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">9.00</span>-<span class="number">10.00</span>  sec  <span class="number">9.54</span> <span class="title class_">GBytes</span>  <span class="number">82.0</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.41</span> <span class="title class_">MBytes</span></span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">[ <span class="variable constant_">ID</span>] <span class="title class_">Interval</span>           <span class="title class_">Transfer</span>     <span class="title class_">Bitrate</span>         <span class="title class_">Retr</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">10.00</span>  sec  <span class="number">97.3</span> <span class="title class_">GBytes</span>  <span class="number">83.6</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>             sender</span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">10.04</span>  sec  <span class="number">97.3</span> <span class="title class_">GBytes</span>  <span class="number">83.3</span> <span class="title class_">Gbits</span>/sec                  receiver</span><br></pre></td></tr></table></figure><p>复制</p><p>结果显示，ipvlan的l2模式下，同主机的pod通信的性能和macvlan差不多，l3模式下也差不多，所以就不展示了；</p><p>使用clusterIP访问：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec pod-b iperf3 -c <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span> -i <span class="number">1</span> -t <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Connecting</span> to host <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span>, port <span class="number">5201</span></span><br><span class="line">[  <span class="number">5</span>] local <span class="number">192.168</span><span class="number">.10</span><span class="number">.11</span> port <span class="number">38540</span> connected to <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span> port <span class="number">5201</span></span><br><span class="line">[ <span class="variable constant_">ID</span>] <span class="title class_">Interval</span>           <span class="title class_">Transfer</span>     <span class="title class_">Bitrate</span>         <span class="title class_">Retr</span>  <span class="title class_">Cwnd</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">1.00</span>   sec  <span class="number">7.17</span> <span class="title class_">GBytes</span>  <span class="number">61.6</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">611</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">1.00</span>-<span class="number">2.00</span>   sec  <span class="number">7.22</span> <span class="title class_">GBytes</span>  <span class="number">62.0</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">708</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">2.00</span>-<span class="number">3.00</span>   sec  <span class="number">7.31</span> <span class="title class_">GBytes</span>  <span class="number">62.8</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">708</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">3.00</span>-<span class="number">4.00</span>   sec  <span class="number">7.29</span> <span class="title class_">GBytes</span>  <span class="number">62.6</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">833</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">4.00</span>-<span class="number">5.00</span>   sec  <span class="number">7.27</span> <span class="title class_">GBytes</span>  <span class="number">62.4</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">833</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">5.00</span>-<span class="number">6.00</span>   sec  <span class="number">7.36</span> <span class="title class_">GBytes</span>  <span class="number">63.3</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">833</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">6.00</span>-<span class="number">7.00</span>   sec  <span class="number">7.26</span> <span class="title class_">GBytes</span>  <span class="number">62.4</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">874</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">7.00</span>-<span class="number">8.00</span>   sec  <span class="number">7.19</span> <span class="title class_">GBytes</span>  <span class="number">61.8</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">874</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">8.00</span>-<span class="number">9.00</span>   sec  <span class="number">7.17</span> <span class="title class_">GBytes</span>  <span class="number">61.6</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">874</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">9.00</span>-<span class="number">10.00</span>  sec  <span class="number">7.28</span> <span class="title class_">GBytes</span>  <span class="number">62.5</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">874</span> <span class="title class_">KBytes</span></span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">[ <span class="variable constant_">ID</span>] <span class="title class_">Interval</span>           <span class="title class_">Transfer</span>     <span class="title class_">Bitrate</span>         <span class="title class_">Retr</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">10.00</span>  sec  <span class="number">72.5</span> <span class="title class_">GBytes</span>  <span class="number">62.3</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>             sender</span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">10.04</span>  sec  <span class="number">72.5</span> <span class="title class_">GBytes</span>  <span class="number">62.0</span> <span class="title class_">Gbits</span>/sec                  receiver</span><br></pre></td></tr></table></figure><p>复制</p><p>可以看到，使用clusterIP访问相比直接用podIP，性能下降了25%，而且还有个问题，同主机pod之间的访问不需要经过iptables规则，所以network policy无法生效，如果在ipvlan或macvlan的模式下，能很好解决clusterIP的问题就好了，下面我们来试试直接在pod内给网卡附加eBPF程序解决clusterIP的问题</p><h2 id="ipvlan模式下附加eBPF程序"><a href="#ipvlan模式下附加eBPF程序" class="headerlink" title="ipvlan模式下附加eBPF程序"></a>ipvlan模式下附加eBPF程序</h2><p>下面的方式因为需要附加我们自定义的eBPF程序（mst_lxc.o），所以各位就不能跟着做了，看个结果吧；</p><p>pod-b的eth0网卡的tc ingress和tc egress附加eBPF程序（因为是在pod里面，所以附加的程序刚好是反过来的，因为eBPF程序写的时候，针对的是主机的网卡）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec pod-b bash</span><br><span class="line">ulimit -l unlimited</span><br><span class="line">tc qdisc add dev eth0 clsact</span><br><span class="line">tc filter add dev eth0 ingress prio <span class="number">1</span> handle <span class="number">1</span> bpf da obj mst_lxc.<span class="property">o</span> sec lxc-egress   #ingress方向附加lxc-egress，主要完成rev-<span class="variable constant_">DNAT</span>：podIP-&gt;clusterIP</span><br><span class="line">tc filter add dev eth0 egress prio <span class="number">1</span> handle <span class="number">1</span> bpf da obj mst_lxc.<span class="property">o</span> sec lxc-ingress   #egress方向完成<span class="variable constant_">DNAT</span>：clusterIP-&gt;podIP</span><br></pre></td></tr></table></figure><p>复制</p><p>增加svc及后端（功能和上面的iptables的DNAT规则的功能是类似的）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mustang svc add --service=<span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span>:<span class="number">5201</span> --backend=<span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span>:<span class="number">5201</span></span><br><span class="line"></span><br><span class="line"><span class="variable constant_">I0908</span> <span class="number">09</span>:<span class="number">51</span>:<span class="number">35.754539</span>    <span class="number">5694</span> bpffs_linux.<span class="property">go</span>:<span class="number">260</span>] <span class="title class_">Detected</span> mounted <span class="variable constant_">BPF</span> filesystem at /sys/fs/bpf</span><br><span class="line"><span class="variable constant_">I0908</span> <span class="number">09</span>:<span class="number">51</span>:<span class="number">35.891046</span>    <span class="number">5694</span> service.<span class="property">go</span>:<span class="number">578</span>] <span class="title class_">Restored</span> services <span class="keyword">from</span> maps</span><br><span class="line"><span class="variable constant_">I0908</span> <span class="number">09</span>:<span class="number">51</span>:<span class="number">35.891103</span>    <span class="number">5694</span> bpf_svc_add.<span class="property">go</span>:<span class="number">86</span>] created success,<span class="attr">id</span>:<span class="number">1</span></span><br></pre></td></tr></table></figure><p>复制</p><p>查看一下配置（mustang工具是我们自定义的用户态工具，用来操作eBPF的map）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mustang svc ls</span><br><span class="line"></span><br><span class="line">==========================================================================</span><br><span class="line"><span class="title class_">Mustang</span> <span class="title class_">Service</span> <span class="attr">count</span>:<span class="number">1</span></span><br><span class="line">==========================================================================</span><br><span class="line">id      pro     service         port    backends</span><br><span class="line">--------------------------------------------------------------------------</span><br><span class="line"><span class="number">1</span>       <span class="variable constant_">NONE</span>    <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span>     <span class="number">5201</span>    <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span>:<span class="number">5201</span>,</span><br><span class="line">==========================================================================</span><br></pre></td></tr></table></figure><p>复制</p><p>一切准备就绪，这时候再来测试用clusterIP访问pod-a：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec pod-b iperf3 -c <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span> -i <span class="number">1</span> -t <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Connecting</span> to host <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span>, port <span class="number">5201</span></span><br><span class="line">[  <span class="number">5</span>] local <span class="number">192.168</span><span class="number">.10</span><span class="number">.11</span> port <span class="number">57152</span> connected to <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span> port <span class="number">5201</span></span><br><span class="line">[ <span class="variable constant_">ID</span>] <span class="title class_">Interval</span>           <span class="title class_">Transfer</span>     <span class="title class_">Bitrate</span>         <span class="title class_">Retr</span>  <span class="title class_">Cwnd</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">1.00</span>   sec  <span class="number">8.96</span> <span class="title class_">GBytes</span>  <span class="number">77.0</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.04</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">1.00</span>-<span class="number">2.00</span>   sec  <span class="number">8.83</span> <span class="title class_">GBytes</span>  <span class="number">75.8</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.26</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">2.00</span>-<span class="number">3.00</span>   sec  <span class="number">9.13</span> <span class="title class_">GBytes</span>  <span class="number">78.4</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.46</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">3.00</span>-<span class="number">4.00</span>   sec  <span class="number">9.10</span> <span class="title class_">GBytes</span>  <span class="number">78.2</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.46</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">4.00</span>-<span class="number">5.00</span>   sec  <span class="number">9.37</span> <span class="title class_">GBytes</span>  <span class="number">80.5</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.46</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">5.00</span>-<span class="number">6.00</span>   sec  <span class="number">9.44</span> <span class="title class_">GBytes</span>  <span class="number">81.1</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.46</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">6.00</span>-<span class="number">7.00</span>   sec  <span class="number">9.14</span> <span class="title class_">GBytes</span>  <span class="number">78.5</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.46</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">7.00</span>-<span class="number">8.00</span>   sec  <span class="number">9.36</span> <span class="title class_">GBytes</span>  <span class="number">80.4</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.68</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">8.00</span>-<span class="number">9.00</span>   sec  <span class="number">9.11</span> <span class="title class_">GBytes</span>  <span class="number">78.3</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.68</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">9.00</span>-<span class="number">10.00</span>  sec  <span class="number">9.29</span> <span class="title class_">GBytes</span>  <span class="number">79.8</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.68</span> <span class="title class_">MBytes</span></span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">[ <span class="variable constant_">ID</span>] <span class="title class_">Interval</span>           <span class="title class_">Transfer</span>     <span class="title class_">Bitrate</span>         <span class="title class_">Retr</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">10.00</span>  sec  <span class="number">91.7</span> <span class="title class_">GBytes</span>  <span class="number">78.8</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>             sender</span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">10.04</span>  sec  <span class="number">91.7</span> <span class="title class_">GBytes</span>  <span class="number">78.5</span> <span class="title class_">Gbits</span>/sec                  receiver</span><br></pre></td></tr></table></figure><p>复制</p><p>可以看到，在ipvlan模式下，附加eBPF程序来实现clusterIP后性能大大提升了，相对于直接用podIP来访问，性能只是有不到5%的损耗，相对于用主机的iptables规则实现clusterIP性能提升了20%，也是上述所有方案中最优的一种，我们自研的cni（mustang）支持这种方式，同时也支持veth方式上附加eBPF程序的方式，下面是veth附加eBPF程序的测试结果；</p><blockquote><p>这里要先清理一下现场</p></blockquote><h2 id="veth方式附加eBPF程序"><a href="#veth方式附加eBPF程序" class="headerlink" title="veth方式附加eBPF程序"></a>veth方式附加eBPF程序</h2><ol><li>还是先创建pod-a和pod-b：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ip netns add pod-a</span><br><span class="line">ip link add eth0 type veth peer name veth-pod-a</span><br><span class="line">ip link set eth0 netns pod-a</span><br><span class="line">ip netns exec pod-a ip addr add <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span>/<span class="number">24</span> dev eth0</span><br><span class="line">ip netns exec pod-a ip link set eth0 up</span><br><span class="line">ip netns exec pod-a ip route add <span class="keyword">default</span> via <span class="number">169.254</span><span class="number">.10</span><span class="number">.24</span> dev eth0 onlink</span><br><span class="line">ip link set veth-pod-a up</span><br><span class="line">echo <span class="number">1</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/conf/veth-pod-a/proxy_arp</span><br><span class="line">ip route add <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span> dev veth-pod-a scope link</span><br><span class="line"></span><br><span class="line">ip netns add pod-b</span><br><span class="line">ip link add eth0 type veth peer name veth-pod-b</span><br><span class="line">ip link set eth0 netns pod-b</span><br><span class="line">ip netns exec pod-b ip addr add <span class="number">192.168</span><span class="number">.10</span><span class="number">.11</span>/<span class="number">24</span> dev eth0</span><br><span class="line">ip netns exec pod-b ip link set eth0 up</span><br><span class="line">ip netns exec pod-b ip route add <span class="keyword">default</span> via <span class="number">169.254</span><span class="number">.10</span><span class="number">.24</span> dev eth0 onlink</span><br><span class="line">ip link set veth-pod-b up</span><br><span class="line">echo <span class="number">1</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/conf/veth-pod-b/proxy_arp</span><br><span class="line">ip route add <span class="number">192.168</span><span class="number">.10</span><span class="number">.11</span> dev veth-pod-b scope link</span><br><span class="line"></span><br><span class="line">echo <span class="number">1</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure><p>复制</p><ol><li>附加eBPF程序</li></ol><p>给pod-a和pod-b主机一端的网卡的tc ingress和tc egress都附加eBPF程序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tc qdisc add dev veth-pod-b clsact</span><br><span class="line">tc filter add dev veth-pod-b ingress prio <span class="number">1</span> handle <span class="number">1</span> bpf da obj mst_lxc.<span class="property">o</span> sec lxc-ingress  ## 因为这是附加在主机一端的网卡，与附加在容器时的方向是反的</span><br><span class="line">tc filter add dev veth-pod-b egress prio <span class="number">1</span> handle <span class="number">1</span> bpf da obj mst_lxc.<span class="property">o</span> sec lxc-egress</span><br><span class="line"></span><br><span class="line">tc qdisc add dev veth-pod-a clsact</span><br><span class="line">tc filter add dev veth-pod-a ingress prio <span class="number">1</span> handle <span class="number">1</span> bpf da obj mst_lxc.<span class="property">o</span> sec lxc-ingress</span><br><span class="line">tc filter add dev veth-pod-a egress prio <span class="number">1</span> handle <span class="number">1</span> bpf da obj mst_lxc.<span class="property">o</span> sec lxc-egress</span><br></pre></td></tr></table></figure><p>复制</p><ol><li>增加svc和增加endpoint（为了对数据包进行快速重定向）：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mustang svc add --service=<span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span>:<span class="number">5201</span> --backend=<span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span>:<span class="number">5201</span></span><br><span class="line">mustang ep add --ifname=eth0 --netns=<span class="regexp">/var/</span>run/netns/pod-a</span><br><span class="line">mustang ep add --ifname=eth0 --netns=<span class="regexp">/var/</span>run/netns/pod-b</span><br></pre></td></tr></table></figure><p>复制</p><ol><li>查看一下配置</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mustang svc ls</span><br><span class="line">==========================================================================</span><br><span class="line"><span class="title class_">Mustang</span> <span class="title class_">Service</span> <span class="attr">count</span>:<span class="number">1</span></span><br><span class="line">==========================================================================</span><br><span class="line">id      pro     service         port    backends</span><br><span class="line">--------------------------------------------------------------------------</span><br><span class="line"><span class="number">1</span>       <span class="variable constant_">NONE</span>    <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span>     <span class="number">5201</span>    <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span>:<span class="number">5201</span>,</span><br><span class="line">==========================================================================</span><br><span class="line"></span><br><span class="line">mustang ep ls</span><br><span class="line">==========================================================================</span><br><span class="line"><span class="title class_">Mustang</span> <span class="title class_">Endpoint</span> <span class="attr">count</span>:<span class="number">2</span></span><br><span class="line">==========================================================================</span><br><span class="line"><span class="title class_">Id</span>      <span class="variable constant_">IP</span>              <span class="title class_">Host</span>    <span class="title class_">IfIndex</span>         <span class="title class_">LxcMAC</span>                  <span class="title class_">NodeMAC</span></span><br><span class="line">--------------------------------------------------------------------------</span><br><span class="line"><span class="number">1</span>       <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span>   <span class="literal">false</span>   <span class="number">653</span>             <span class="number">76</span>:6<span class="attr">C</span>:<span class="number">37</span>:2<span class="attr">C</span>:<span class="number">81</span>:<span class="number">05</span>       3<span class="attr">E</span>:<span class="attr">E9</span>:<span class="number">02</span>:<span class="number">96</span>:<span class="number">60</span>:<span class="variable constant_">D6</span></span><br><span class="line"><span class="number">2</span>       <span class="number">192.168</span><span class="number">.10</span><span class="number">.11</span>   <span class="literal">false</span>   <span class="number">655</span>             6<span class="attr">A</span>:<span class="attr">CD</span>:<span class="number">11</span>:<span class="number">13</span>:<span class="number">76</span>:2C       <span class="number">72</span>:<span class="number">90</span>:<span class="number">74</span>:4<span class="attr">A</span>:<span class="attr">CB</span>:<span class="number">84</span></span><br><span class="line">==========================================================================</span><br></pre></td></tr></table></figure><p>复制</p><ol><li>可以开测了，老套路，pod-a跑服务端，在pod-b上测，先试试用clusterIP：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> ip netns exec pod-b iperf3 -c <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span> -i <span class="number">1</span> -t <span class="number">10</span></span><br><span class="line"><span class="title class_">Connecting</span> to host <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span>, port <span class="number">5201</span></span><br><span class="line">[  <span class="number">5</span>] local <span class="number">192.168</span><span class="number">.10</span><span class="number">.11</span> port <span class="number">36492</span> connected to <span class="number">10.96</span><span class="number">.0</span><span class="number">.100</span> port <span class="number">5201</span></span><br><span class="line">[ <span class="variable constant_">ID</span>] <span class="title class_">Interval</span>           <span class="title class_">Transfer</span>     <span class="title class_">Bitrate</span>         <span class="title class_">Retr</span>  <span class="title class_">Cwnd</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">1.00</span>   sec  <span class="number">8.52</span> <span class="title class_">GBytes</span>  <span class="number">73.2</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.07</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">1.00</span>-<span class="number">2.00</span>   sec  <span class="number">8.54</span> <span class="title class_">GBytes</span>  <span class="number">73.4</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.07</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">2.00</span>-<span class="number">3.00</span>   sec  <span class="number">8.64</span> <span class="title class_">GBytes</span>  <span class="number">74.2</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.07</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">3.00</span>-<span class="number">4.00</span>   sec  <span class="number">8.57</span> <span class="title class_">GBytes</span>  <span class="number">73.6</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.12</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">4.00</span>-<span class="number">5.00</span>   sec  <span class="number">8.61</span> <span class="title class_">GBytes</span>  <span class="number">73.9</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.18</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">5.00</span>-<span class="number">6.00</span>   sec  <span class="number">8.48</span> <span class="title class_">GBytes</span>  <span class="number">72.8</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.18</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">6.00</span>-<span class="number">7.00</span>   sec  <span class="number">8.57</span> <span class="title class_">GBytes</span>  <span class="number">73.6</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.18</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">7.00</span>-<span class="number">8.00</span>   sec  <span class="number">9.11</span> <span class="title class_">GBytes</span>  <span class="number">78.3</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.18</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">8.00</span>-<span class="number">9.00</span>   sec  <span class="number">8.86</span> <span class="title class_">GBytes</span>  <span class="number">76.1</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.18</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">9.00</span>-<span class="number">10.00</span>  sec  <span class="number">8.71</span> <span class="title class_">GBytes</span>  <span class="number">74.8</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.18</span> <span class="title class_">MBytes</span></span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">[ <span class="variable constant_">ID</span>] <span class="title class_">Interval</span>           <span class="title class_">Transfer</span>     <span class="title class_">Bitrate</span>         <span class="title class_">Retr</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">10.00</span>  sec  <span class="number">86.6</span> <span class="title class_">GBytes</span>  <span class="number">74.4</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>             sender</span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">10.04</span>  sec  <span class="number">86.6</span> <span class="title class_">GBytes</span>  <span class="number">74.1</span> <span class="title class_">Gbits</span>/sec                  receiver</span><br></pre></td></tr></table></figure><p>复制</p><p>再试试直接用podIP：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec pod-b iperf3 -c <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span> -i <span class="number">1</span> -t <span class="number">10</span></span><br><span class="line"><span class="title class_">Connecting</span> to host <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span>, port <span class="number">5201</span></span><br><span class="line">[  <span class="number">5</span>] local <span class="number">192.168</span><span class="number">.10</span><span class="number">.11</span> port <span class="number">56460</span> connected to <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span> port <span class="number">5201</span></span><br><span class="line">[ <span class="variable constant_">ID</span>] <span class="title class_">Interval</span>           <span class="title class_">Transfer</span>     <span class="title class_">Bitrate</span>         <span class="title class_">Retr</span>  <span class="title class_">Cwnd</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">1.00</span>   sec  <span class="number">8.76</span> <span class="title class_">GBytes</span>  <span class="number">75.3</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">676</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">1.00</span>-<span class="number">2.00</span>   sec  <span class="number">8.87</span> <span class="title class_">GBytes</span>  <span class="number">76.2</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">708</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">2.00</span>-<span class="number">3.00</span>   sec  <span class="number">8.78</span> <span class="title class_">GBytes</span>  <span class="number">75.5</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">708</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">3.00</span>-<span class="number">4.00</span>   sec  <span class="number">8.99</span> <span class="title class_">GBytes</span>  <span class="number">77.2</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">708</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">4.00</span>-<span class="number">5.00</span>   sec  <span class="number">8.85</span> <span class="title class_">GBytes</span>  <span class="number">76.1</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">782</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">5.00</span>-<span class="number">6.00</span>   sec  <span class="number">8.98</span> <span class="title class_">GBytes</span>  <span class="number">77.1</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>    <span class="number">782</span> <span class="title class_">KBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">6.00</span>-<span class="number">7.00</span>   sec  <span class="number">8.64</span> <span class="title class_">GBytes</span>  <span class="number">74.2</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.19</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">7.00</span>-<span class="number">8.00</span>   sec  <span class="number">8.40</span> <span class="title class_">GBytes</span>  <span class="number">72.2</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.55</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">8.00</span>-<span class="number">9.00</span>   sec  <span class="number">8.16</span> <span class="title class_">GBytes</span>  <span class="number">70.1</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.88</span> <span class="title class_">MBytes</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">9.00</span>-<span class="number">10.00</span>  sec  <span class="number">8.16</span> <span class="title class_">GBytes</span>  <span class="number">70.1</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>   <span class="number">1.88</span> <span class="title class_">MBytes</span></span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">[ <span class="variable constant_">ID</span>] <span class="title class_">Interval</span>           <span class="title class_">Transfer</span>     <span class="title class_">Bitrate</span>         <span class="title class_">Retr</span></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">10.00</span>  sec  <span class="number">86.6</span> <span class="title class_">GBytes</span>  <span class="number">74.4</span> <span class="title class_">Gbits</span>/sec    <span class="number">0</span>             sender</span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span>-<span class="number">10.04</span>  sec  <span class="number">86.6</span> <span class="title class_">GBytes</span>  <span class="number">74.1</span> <span class="title class_">Gbits</span>/sec                  receiver</span><br></pre></td></tr></table></figure><p>复制</p><p>可以看到，附加eBPF程序后，用PodIP访问比原来性能提升了12%左右（见最上面veth方式的测试结果，66Gbits&#x2F;sec），且clusterIP访问和podIP访问几乎没有差异；</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>veth           ：（PODIP）66Gbits&#x2F;sec   （clusterIP）66Gbits&#x2F;sec</li><li>bridge         : （PODIP）77Gbits&#x2F;sec   （clusterIP）61Gbits&#x2F;sec</li><li>macvlan      ：（PODIP）83Gbits&#x2F;sec   （clusterIP）62Gbits&#x2F;sec</li><li>ipvlan         ：（PODIP）83Gbits&#x2F;sec   （clusterIP）62Gbits&#x2F;sec</li><li>ipvlan+eBPF：（PODIP）83Gbits&#x2F;sec   （clusterIP）78Gbits&#x2F;sec</li><li>veth+eBPF  ：（PODIP）74Gbits&#x2F;sec   （clusterIP）74Gbits&#x2F;sec</li></ul><p><img src="/2022/12/17/k8s%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E5%8E%9F%E7%90%866/../img/%E5%8E%9F%E7%90%866assets/1620.jpeg" alt="img"></p><p>同主机pod连接的几种方式及性能对比</p><p>综上所述：</p><ul><li>macvlan和ipvlan在使用podIP访问时性能是所有方案中最高的，但clusterIP的访问因为走了主机协议栈，降了25%，有eBPF加持后又提升了20%，不过macvlan在无线网卡不支持，且单网卡mac数量有限制，不支持云平台源目的检查等，所以一般都较为推荐ipvlan+eBPF方式，不过这种方式下附加eBPF程序还是有点点麻烦，上面演示时为了简洁直接把eBPF的map在pod里创建了，实际是在主机上创建eBPF的map，然后让所有的pod共享这份eBPF的map；</li><li>veth方式附加eBPF程序后，用serviceIP和直接用podIP性能上没有差异，且比不附加eBPF程序性能有12%的提升，而且还可以用主机上的iptables防火墙规则，在主机端附加eBPF程序比较简单，所以这是我们的mustang默认的方案；</li><li>bridge在podIP访问时性能是比veth方式高的，但因为执行iptables规则性能被拖低了，所以在不附加eBPF的情况下，还是比较推荐veth方式，这是calico的默认方案；bridge方式是flannel的默认方案</li></ul>]]></content>
      
      
      <categories>
          
          <category> k8s网络原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> k8s网络原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/12/17/k8s%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/k8s%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E8%87%AA%E6%88%91%E6%80%BB%E7%BB%93%E7%AF%87/"/>
      <url>/2022/12/17/k8s%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/k8s%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E8%87%AA%E6%88%91%E6%80%BB%E7%BB%93%E7%AF%87/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>单词本</title>
      <link href="/2022/12/17/English/%E5%8D%95%E8%AF%8D%E6%9C%AC/"/>
      <url>/2022/12/17/English/%E5%8D%95%E8%AF%8D%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th align="center">word</th></tr></thead><tbody><tr><td align="center">ref</td></tr><tr><td align="center">stack</td></tr><tr><td align="center">dose</td></tr><tr><td align="center">notion</td></tr><tr><td align="center">formula</td></tr><tr><td align="center">bubble</td></tr><tr><td align="center">faculty</td></tr><tr><td align="center">harnerss</td></tr><tr><td align="center"></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/12/14/%E5%8A%9B%E6%89%A3/%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
      <url>/2022/12/14/%E5%8A%9B%E6%89%A3/%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/12/14/%E5%8A%9B%E6%89%A3/%E5%91%A8%E8%B5%9B/"/>
      <url>/2022/12/14/%E5%8A%9B%E6%89%A3/%E5%91%A8%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/12/14/%E5%8A%9B%E6%89%A3/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2022/12/14/%E5%8A%9B%E6%89%A3/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="1697"><a href="#1697" class="headerlink" title="1697"></a>1697</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/12/13/%E4%BA%91%E5%8E%9F%E7%94%9F/docker%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"/>
      <url>/2022/12/13/%E4%BA%91%E5%8E%9F%E7%94%9F/docker%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="NameSpace-资源隔离"><a href="#NameSpace-资源隔离" class="headerlink" title="NameSpace  资源隔离"></a>NameSpace  资源隔离</h2><p>docker 容器其实也是宿主机的一个进程,也直接共享着操作系统的资源,但是有着众多的隔离手段,让docker容器感知不到外界的存在,就像是独立存在的一台主机一样</p><h2 id="cgroups-资源限制"><a href="#cgroups-资源限制" class="headerlink" title="cgroups 资源限制"></a>cgroups 资源限制</h2><p>cgroups 能够对任务资源进行限制,按照优先级分配,资源统计,任务控制(挂起,恢复)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/12/13/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s-3/"/>
      <url>/2022/12/13/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s-3/</url>
      
        <content type="html"><![CDATA[<p><img src="/2022/12/13/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s-3/../img/k8s-3assets/image-20221213104035867.png" alt="image-20221213104035867"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux进阶</title>
      <link href="/2022/12/13/linux/linux%E8%BF%9B%E9%98%B6/"/>
      <url>/2022/12/13/linux/linux%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello</title>
      <link href="/2022/12/12/test/test/"/>
      <url>/2022/12/12/test/test/</url>
      
        <content type="html"><![CDATA[<h2 id="hello"><a href="#hello" class="headerlink" title="hello"></a>hello</h2><p>看看我的博客推送有多简单</p><p><img src="/2022/12/12/test/test/../img/testassets/image-20221212114132699.png" alt="image-20221212114132699"></p><p>图片也可以直接推送</p>]]></content>
      
      
      
        <tags>
            
            <tag> hello </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go总结</title>
      <link href="/2022/12/09/go/go/"/>
      <url>/2022/12/09/go/go/</url>
      
        <content type="html"><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>Go设置国内镜像源</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> env -w GOPROXY=https:<span class="comment">//goproxy.cn,direct</span></span><br></pre></td></tr></table></figure><h2 id="基础教程"><a href="#基础教程" class="headerlink" title="基础教程"></a>基础教程</h2><p>go.mod 是用来管理我们引入模块的信息,里面记录了我们当前模块的模块名,以及需要的模块的信息</p><p>go mod init 名字  用来创建一个模块</p><p>go mod tydy 加载模块(本地,或者远程)</p><p>init 函数会最先执行,早于main函数</p><p>go中**{**不能单独一行</p><p>一行代表一个语句结束,如果要多个语句写一起,就必须使用;分隔,但是并不推荐这样做</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>注意一下不同的数据类型就行了</p><ul><li><em>int   这个和c语言不同哦,c语言是int</em> ,不过使用起来是一样的,只是声明的时候不同</li><li>函数类型 声明的时候,是可以直接用变量接收一个函数的哦</li></ul><h3 id="变量声明方式"><a href="#变量声明方式" class="headerlink" title="变量声明方式"></a>变量声明方式</h3><p>方式1  var 名字1,名字2 …. type (没有赋值,默认值代替)</p><p>方式二 var 名字1,名字2 类型 &#x3D; 值1,值2  (值类型必须一致</p><p>方式三 var 名字 1,名字2&#x3D; 值1,值2  (根据类型推断)</p><p>方式四(局部变量才可以用) 名字1,名字2:&#x3D;值  相当于  var 名字1 type,var 名字2 type   名字1 &#x3D; 值1 名字2 &#x3D; 值2   (这么写方便啊,少写很多东西,哈哈哈哈)  这种方式只能用在函数内部,全局是不可以的,因为函数外面的全局只能写声明然后直接赋值,而不能声明后,再单独写个语句赋值</p><p>方式五  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var(</span><br><span class="line">a,b</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>比如说</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>; <span class="comment">//可行</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">int</span>;</span><br><span class="line">b = <span class="number">10</span>  <span class="comment">//不可行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go 语言中如果声明变量而不使用的话,则会报错,我们可以使用 _ &#x3D; 变量 , 消除这个报错, _ 是一个只写变量,而不能读它, 有人就说了,这不是搞笑么,我不声明不就行了嘛, 可是有时候,你不得不声明,比如一个函数可以返回多个值,你只想要其中某一部分的值,但是那些不要的值你也得接收啊,所有_就派上用场了(全局变量可以只声明而不使用哦)</p><h3 id="常量声明方式"><a href="#常量声明方式" class="headerlink" title="常量声明方式"></a>常量声明方式</h3><p>方式一  const name1,name2 &#x3D;val1,val2   (必须为每个变量赋值)</p><p>方式二 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b</span><br><span class="line">    c</span><br><span class="line">    d</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 这种方式的话 如果不赋值,默认跟前一个&quot;赋值方式一样&quot;所有第一个必须赋值</span></span><br><span class="line"><span class="comment">// iota 特殊常量</span></span><br><span class="line"><span class="comment">// 在这种常量赋值的方法中,iota会被赋值为0,每增加一个常量,iota的值就加一,我们是不能自己去修改的哦</span></span><br></pre></td></tr></table></figure><p>常量可以只声明而不使用的哦</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>go的运算符跟c++ 差不多,就简单说点不同的地方</p><blockquote><p>go  不支持 三目运算符哦</p></blockquote><p>go 提倡的是 一个语句占一行,像 a++ 这种已经就是一个语句了,所以我们这种写法会报错  sum +&#x3D; a++  这个相当于两条语句,所有go是不允许的</p><h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">if</span> ( 逻辑表达式)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">if</span> 逻辑表达式&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="swtich"><a href="#swtich" class="headerlink" title="swtich"></a>swtich</h4><p>这个与c语言还是有点区别的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只要进入了case的分支,就不会再进入其他case分支了(这里是与c语言不同的),不过可以通过fallthrough 强制执行后面分支</span></span><br><span class="line"><span class="keyword">switch</span> var1 &#123;</span><br><span class="line">    <span class="keyword">case</span> val1:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> val2:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//与c语言的一样但是不能加()</span><br><span class="line">for a:=1;a&lt;=10;a++&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//与c的while差不多</span><br><span class="line">a := true</span><br><span class="line">for a&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 与c的for(;;)一样</span><br><span class="line">for&#123;&#125;</span><br><span class="line">// 与 c++的for(int i : num) 差不多</span><br><span class="line">for k,v = range map</span><br></pre></td></tr></table></figure><p>go 里面没有while语句哦,for可以替代它的</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>这个基本是所有语言都有的,只不过格式不同罢了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcname</span> <span class="params">(parameter list)</span></span> return_types &#123;&#125;</span><br></pre></td></tr></table></figure><p>go的函数可以返回多个值,每个值的类型都必须声明好</p><p>这个参数是可以传递函数的哦,其实也没什么奇怪得啦,c语言里面传递函数是通过指针传递,用起来比较麻烦,但是go里面可以直接传递</p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>go里面的函数还可以闭包哦,就是一个函数的返回值也是一个函数,闭包的优势就在与,返回来的函数直接使用产生它的函数的变量,举个列子</p><p>求素数的列子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getPrimeFunc</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">i++</span><br><span class="line">j := <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> ; j &lt;= i/j; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> i%j == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> j &gt; i/j &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> getPrime = getPrimeFunc()</span><br><span class="line"><span class="built_in">println</span>(getPrime())</span><br><span class="line"><span class="built_in">println</span>(getPrime())</span><br><span class="line"><span class="built_in">println</span>(getPrime())</span><br><span class="line"><span class="built_in">println</span>(getPrime())</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用闭包,我们可以使的逻辑变的清晰,</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>方法与函数的声明有点区别,前面加了接受者类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (variable_name variable_data_type) funcname(paremeter list) (return_type)&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><ul><li>函数类定义的是局部变量,只能在函数内使用,所谓的函数内是指当前函数,以及这个函数产生的匿名函数也能够使用</li><li>函数外定义的是全局函数</li><li>函数定义中的变量是形参变量</li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums [<span class="number">10</span>] <span class="type">int</span>  <span class="comment">//一维 </span></span><br><span class="line"><span class="keyword">var</span> nums [<span class="number">10</span>][<span class="number">10</span>] <span class="type">int</span> <span class="comment">//二维  go的二维数组跟java很类似,第二维可以长度不一样,c++不行</span></span><br></pre></td></tr></table></figure><p>初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = [<span class="number">10</span>] <span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; <span class="comment">//定义的时候初始化</span></span><br><span class="line"><span class="keyword">var</span> nums = [...] <span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125; <span class="comment">//自动推断数组长度</span></span><br><span class="line">nums := [<span class="number">10</span>] <span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; <span class="comment">//这种就自然不用说了</span></span><br><span class="line">nums[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">//定义完后赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//go的数组跟java的很像,就是一个引用类型罢了,不过需要注意的是,java数组的引用是不需要长度一样的,而go是严格要求引用长度得一样</span></span><br><span class="line">nums := [<span class="number">10</span>] <span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">nums = [<span class="number">10</span>] <span class="type">int</span> &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125; <span class="comment">//ok</span></span><br><span class="line">nums = [<span class="number">3</span>] <span class="type">int</span> &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125; <span class="comment">// no</span></span><br></pre></td></tr></table></figure><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>看到这个我就不陌生了,c和c++里面再熟悉不过了</p><p>定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> point *<span class="type">int</span></span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line">point = &amp;a</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">*point</span><br></pre></td></tr></table></figure><p>go里面的空指针是nil,地址值就是0</p><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>回来了,都回来了,大一学的C语言和c++,后面被迫转java,java是很好,但是我觉得还是有点笨重,当然他的出现也是为了解决问题</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> people <span class="keyword">struct</span>&#123;</span><br><span class="line">age <span class="type">int</span></span><br><span class="line">name <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个传入参数也是值类型哦,不是引用类型,和c++是一样的,主要跟java的区别</p><h3 id="Range关键字"><a href="#Range关键字" class="headerlink" title="Range关键字"></a>Range关键字</h3><p>用于 for 循环中迭代数组,切片,通道,集合中的元素,并以k-v的方式返回</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>让我们来感受一下go提供的数据结构吧</p><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><p>哎呦我去,这不就是java的list,c++的vector,python里面的切片么</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; <span class="comment">//注意跟数组定义的区别哦,中括号里面是没有东西的哦</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">3</span>) <span class="comment">//或者这样哦</span></span><br></pre></td></tr></table></figure><p>切片是可以动态增长的哦,不像数组.既然叫切片,那让我们来看看它怎么切吧</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// len 是数组的长度</span></span><br><span class="line">s := arr[:] <span class="comment">//切片是整个数组[0,len)</span></span><br><span class="line">s := arr[start:] <span class="comment">//从start到整个数组后面 [start,len)</span></span><br><span class="line">s := arr[:end] <span class="comment">//从0到end-1 [0,end)</span></span><br></pre></td></tr></table></figure><h5 id="切片常用函数"><a href="#切片常用函数" class="headerlink" title="切片常用函数"></a>切片常用函数</h5><p>len() 计算当前数据长度,cap() 计算最大可达长度</p><p>append(slice,val) 向切片追加数据 ,copy(destnation,src) 复制一个切片到另一个切片</p><p>make(slicetype,len,cap)  定义一个切片当前大小为len,总容量为cap的切片</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/12/05/%E4%B9%A6%E7%B1%8D%E8%A7%82%E5%90%8E%E6%84%9F/thinking%20in%20java/"/>
      <url>/2022/12/05/%E4%B9%A6%E7%B1%8D%E8%A7%82%E5%90%8E%E6%84%9F/thinking%20in%20java/</url>
      
        <content type="html"><![CDATA[<p>首先我们应该要明白我们的程序需要做什么,而不是考虑程序要怎么做,我们应该将重心放到这一阶段的核心问题上,不要纠结与一些细枝末节,同时也不要过分在意系统的**”完美”**,否则容易产生挫败感和焦虑情绪</p><p>对自己的系统做一些**”名词”<strong>和</strong>“动词”**的描述,名词成为自然对象,动词成为对象接口中的方法</p><p>根据自己的经验与直觉,对一个项目进行日程估计,然后在这个时间上再加上百分之十,如果按时完成了,那么这个百分之十的时间,可以用来完善项目</p><p>如何构建计划呢? 通常建议使用UML很好</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    int x;</span><br><span class="line">    &#123;</span><br><span class="line">        int x; //在java里面,这个是非法的</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java 为什么没有sizeof ?</p><p>因为他不需要,c++和c有sizeof 是因为在不同的平台里面,有些数据类型的大小是不一样的,new 数据的时候就得通过sizeof去控制</p><p>java的包名命名规范一般是域名倒着来,首先,我们是想包名唯一,正好域名是唯一的,但是域名后两个是固定的,前面又可以随便变化,所以域名符合要求,而且我们为了方便管理,还要把域名倒过来才行,假如我有个域名 djm.com  那么 ww.djm.com,abc.djm.com  不都是我的子域名么,如果正着来,不好管理啊,反着来,前面都一样,好管理</p><p>@Override 是重写  发生在子父类之间(同名,同参数,而且子类访问权限不能小于父亲,子类异常也要是父类的异常的子类)</p><p>@Overload 是重载  发生在本类中(同名,不同参数)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2022/12/02/hexo/hexo-temp/"/>
      <url>/2022/12/02/hexo/hexo-temp/</url>
      
        <content type="html"><![CDATA[<p>Butterfly 所用 字体是 <a href="https://fontawesome.com.cn/icons/bug/">bug – Font Awesome 中文网</a>他们的字体</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker总结</title>
      <link href="/2022/12/02/%E4%BA%91%E5%8E%9F%E7%94%9F/docker%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/12/02/%E4%BA%91%E5%8E%9F%E7%94%9F/docker%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是docker"><a href="#什么是docker" class="headerlink" title="什么是docker"></a>什么是docker</h2><p>Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术(虚拟机是属于软件层面的虚拟化技术)。由于隔离的进程独立于宿主和其它的隔离的进程(既然是一个进程,当然能够直接使用系统资源)，因此也称其为容器</p><blockquote><p>以下所有操作均在CentOS Linux release 7.6.1810 (Core)中进行,仅供参考哦,不同版本可能回有区别</p></blockquote><h2 id="为什么要用docker"><a href="#为什么要用docker" class="headerlink" title="为什么要用docker"></a>为什么要用docker</h2><p>传统的虚拟技术是利用软件虚拟出一套硬件环境,而且还需要再跑一个操作系统,所以无论执行速度,内存损耗,文件存储,都比传统的虚拟技术,而且一套dockerfile可以保证相同的环境,一次创建,到处可以运行,Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单,因此docker有以下几个优势</p><ul><li>更高效的利用系统资源</li><li>更快的启动速度</li><li>一致运行环境</li><li>更轻松的迁移</li><li>更轻松的拓展与维护</li></ul><h2 id="搭建与卸载"><a href="#搭建与卸载" class="headerlink" title="搭建与卸载"></a>搭建与卸载</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载包管理工具</span></span><br><span class="line">yum install -y yum-utils </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置docker下载源为清华源</span></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装docker</span>   </span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="启动docker服务"><a href="#启动docker服务" class="headerlink" title="启动docker服务"></a>启动docker服务</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动docker 并且设置开机自启动</span></span><br><span class="line">systemctl enable docker --now</span><br></pre></td></tr></table></figure><h4 id="配置docker镜像加速源"><a href="#配置docker镜像加速源" class="headerlink" title="配置docker镜像加速源"></a>配置docker镜像加速源</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/docker</span><br><span class="line">tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;:[&quot;https://o13jbvy6.mirror.aliyuncs.com&quot;],</span><br><span class="line">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看还有哪些配置没删掉</span></span><br><span class="line">whereis docker</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker: /etc/docker /usr/libexec/docker</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删掉所有相关配置</span></span><br><span class="line">rm -rf /etc/docker /usr/libexec/docker</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>Docker的镜像是一个特殊的文件系统,提供容器运行时所需要的程序,库,资源,配置,以及运行时准备的参数(环境变量,用户)等等,镜像不包含动态数据,构建好后,镜像的内容也不会发生改变</p><h3 id="分层存储"><a href="#分层存储" class="headerlink" title="分层存储"></a>分层存储</h3><p>docker的镜像是由基础镜像一层一层构建过来的,每一层的内容都只可读不可以更改,这么设计的好处是可以共享镜像,如果需要更改只能在容器层记录哪些文件被更改了,所有我们尽量把那些需要更改的文件通过容器卷的方式传递给容器,因为容器卷里面的东西不属于镜像,属于宿主机,</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>容器其实就是一个进程,但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全</p><p>容器启动时,在镜像的基础上加了一层<strong>容器存储层</strong>,所有的更改操作都进行在这一层,当容器死亡的时候,这一层也将消失</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h3><p>拉取一个镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull (地址/仓库/)镜像名字:版本号(没有版本号默认拉取最新版)</span><br></pre></td></tr></table></figure><h3 id="images"><a href="#images" class="headerlink" title="images"></a>images</h3><p>查看所有镜像 </p><h3 id="rmi"><a href="#rmi" class="headerlink" title="rmi"></a>rmi</h3><p>删除一个镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rmi 镜像名字或者id</span><br><span class="line">docker rmi $(docker images -q)  # 删除所有镜像</span><br></pre></td></tr></table></figure><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p>基于镜像启动一个容器</p><ul><li>-i 开启交互式</li><li>-t 分配一个终端</li><li>-d 后台运行 </li><li>-p 本地端口:容器端口 做端口映射</li><li>–privileged 在容器内真正的拥有root权限</li><li>-v 设置容器卷</li><li>-w 设置进入容器的工作目录</li><li>–rm 容器退出后,删除容器</li><li>–name 设置名字</li><li>–network 设置要连接到网络名字</li><li>–entrypoint 设置容器启动时执行的命令,如果用了这个参数,后面输入的shell命令会当成参数</li></ul><blockquote><p>如果镜像不存在,会去自动拉取</p></blockquote><h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p>进入一个运行中的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 容器名字/id bash(进入方式)</span><br></pre></td></tr></table></figure><ul><li>-i 将当前终端输入流给容器</li><li>-t 分配一个终端</li><li>-w 指定工作目录</li><li>-e 指定环境变量</li><li>-u 指定用户</li></ul><h3 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h3><p>查看容器后台输出的信息,方便我们纠错</p><h3 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h3><p>关闭一个容器  docker stop  id或者名字</p><h3 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h3><p>重启一个容器 docker restart id 或者名字</p><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>删掉一个容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f id或者名字</span><br><span class="line">docker rm -f $(docker ps -aq) #删除所有容器</span><br></pre></td></tr></table></figure><h3 id="rename"><a href="#rename" class="headerlink" title="rename"></a>rename</h3><p>更改容器的名字</p><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>与linux的ps功能差不多</p><ul><li>docker ps 查看运行的容器</li><li>docker ps -a 查看运行和停止的容器</li></ul><h3 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h3><p>将容器打包成镜像(不推荐使用,建议使用build),这个</p><ul><li>–message 打包说明</li><li>–author 作者</li><li>docker commit 容器  (仓库名字)镜像:标签</li></ul><h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><p>拿容器层与镜像层做对比,看多了哪些,修改了哪些,删除了哪些东西</p><h3 id="inspect"><a href="#inspect" class="headerlink" title="inspect"></a>inspect</h3><p>查看容器,网络,镜像,容器卷,网络的详细信息或者说元信息</p><h3 id="network"><a href="#network" class="headerlink" title="network"></a>network</h3><ul><li>create -d 类型(一般用bridge,也是默认值) 网络名字 创建一个网络</li><li>rm 删除一个网络</li><li>prune 删除未使用的网络</li><li>connect 将容器加入到某个网络当中去</li></ul><h3 id="volume"><a href="#volume" class="headerlink" title="volume"></a>volume</h3><ul><li>create name 创建一个容器卷</li><li>rm name&#x2F;id 删除一个容器</li><li>inspect name&#x2F;id 查看容器卷的元信息</li><li>prune 删除没有在使用的容器卷(只要有容器挂载,不管是运行的容器,还是停止的容器,都算在使用)</li></ul><h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><p>基于dockerfile构建一个镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t 镜像名字:版本  .</span><br></pre></td></tr></table></figure><ul><li>-t 指定镜像名字与版本</li><li>-f 指定dockerfile路径(默认在上下文中)</li><li>后面这个点 <strong>.</strong> 是指上下文路径  build的时候,会将这个路径下的所有文件打包发给docker 服务端</li></ul><h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p>查看镜像的构建历史命令</p><ul><li>–no-trunc 查看完整命令(默认只能看到前几个字符)</li></ul><h3 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h3><p>可以改变一个镜像的仓库名字,镜像名字,版本号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tag nginx:latest mynginx:v1</span><br></pre></td></tr></table></figure><h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><p>将一个容器导出成一个文件,但是不会保存所有的commit记录,比如说你的CMD命令,entrypoint的这些都不会保存,因此在打出的镜像执行的时候需要去重新输入CMD命令才能保证容器继续运行</p><ul><li>docker export nginx -o my-nginx.tar</li></ul><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>将本地或者远程文件导入成镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import ./my-nginx.tar my-nginx:v2</span><br></pre></td></tr></table></figure><h2 id="容器卷"><a href="#容器卷" class="headerlink" title="容器卷"></a>容器卷</h2><p>挂在容器卷的几种方式:</p><ul><li>先创建 容器卷 docker volume create –name vol (会创建 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;vol&#x2F;_data 然后 将这个目录挂载到容器指定目录上去</li><li>直接使用不存在的容器卷名字,docker会给我们创建一个容器卷假设名字为a,那么对应的目录就为 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;a&#x2F;_data</li><li>使用自定义文件或者文件夹,<strong>必须使用绝对路径</strong>,然后使用-v 宿主机路径:容器路径   如果两个路径都不存在,docker会为我们创建,如果容器路径存在,那么里面东西会被宿主机的东西覆盖</li></ul><p>一个容器可以挂载多个容器卷,我们可以设置容器对容器卷的操作权限,比如只读 -v 宿主机路径:容器路径:ro</p><p>权限问题,当我们使用容器卷的时候,会发现里面的数据我们居然没办法查看,也没有办法创建文件,这个时候,我们需要使用  –privileged&#x3D;true 创建容器</p><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><h3 id="commit-1"><a href="#commit-1" class="headerlink" title="commit"></a>commit</h3><p>当我们使用commit 之后,是将当前容器的存储层+原来的镜像打包成一个新的镜像,这样容器的存储层就会被保留下来,后面也无法再更改,如果我们使用了卷的话,这个东西并不属于存储层,自然不会被保存</p><p>启动一个nginx的容器,并且修改它的index页面,然后commit打包成一个镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动一个容器,并设置端口映射</span></span><br><span class="line">docker run -d --name nginx -p 8080:80 nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入这个容器</span></span><br><span class="line">docker exec -it nginx bash</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改默认页面</span></span><br><span class="line">echo &quot;&lt;h1&gt;hello world&lt;/h1&gt;&quot; &gt; /usr/share/nginx/html/index.html</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">退出容器 <span class="built_in">exit</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">访问虚拟机8080 端口</span> </span><br><span class="line">curl localhost:8080 </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出&lt;h1&gt;hello world&lt;/h1&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将容器做成镜像</span></span><br><span class="line">docker commit --author &quot;djm&quot; --message &quot;修改了默认网页&quot; nginx mynginx:v1 </span><br><span class="line"></span><br><span class="line">docker images #查看我们自己的镜像</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过打包好的镜像启动容器</span></span><br><span class="line">docker run -d --name nginx1  -p 8081:80 mynginx:v1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">访问ip:8081就能访问到我们修改的页面</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">不要使用docker commit 来制作镜像,这样会导致很多文件被加入到这一层中,到时候docker commit的次数越来越多,镜像会变得很臃肿</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">而且docker commit 制作镜像,别人根本不知道我们在基础镜像上面干了些什么东西</span></span><br></pre></td></tr></table></figure><h3 id="dockerfile"><a href="#dockerfile" class="headerlink" title="dockerfile"></a>dockerfile</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">dockerfile 的编写</span></span><br><span class="line"></span><br><span class="line">ARG 设置环境变量(放在FROM前面,变量只能在所有FROM里面使用,放在其他指令前面,只有那一个指令能用)</span><br><span class="line">FROM 基础镜像(名字:版本号)  (scratch 空镜像)</span><br><span class="line">ENV 设置环境变量(到时候容器里面会存在这个变量哦)</span><br><span class="line">RUN 命令   </span><br><span class="line">CP 源路径(相对于上下文来说) 目标路径(可以相对于容器来说,也可以相对于容器里面的工作目录(通过WORKDIR指定来说)</span><br><span class="line">ADD 压缩包路径(相对于上下文) 目录路径(同上)  add 可以做其他的事(和cp一样的功能,下载文件),但是推荐只做这个事情</span><br><span class="line">CMD [&quot;可执行文件&quot;,&quot;参数&quot;] 容器启动时默认执行命令,当然我们自己写的命令会替换掉这个,CMD里面的命令会最终被替换成</span><br><span class="line">sh -c &quot;可执行文件&quot;,&quot;参数&quot;</span><br><span class="line">ENTRYPOINT [&quot;可执行文件&quot;,&quot;参数&quot;,CMD] 这个命令和CMD命令的目的都是一样的,让容器启动的时候执行一些命令,但是如果这个命令与CMD</span><br><span class="line">一起使用的时候,CMD里面的东西会被当成参数,默认这个命令是不会被替换掉的,我们需要使用--entrypoint来指定</span><br><span class="line">VOLUME 定义一个匿名卷,如果用户没有指定容器卷,我们也能挂在一个匿名卷,把动态数据放在容器卷中,这样就能防止一些动态数据的写操作发生在容器层</span><br><span class="line">WORKDIR 指定容器的工作目录,可以使用绝对路径和相对路径,相对路径是相对于上次的WORKDIR来说的,最初始的WORKDIR在/ (这个是会影响到后面的层的)</span><br><span class="line">USER 切换用户 ,这个用户必须事先存在(这个也会影响到后面的层</span><br><span class="line">HEALTHCHECK 健康检查,检查容器有没有出什么异常,通过返回值判断</span><br><span class="line">HEALTHCHECK --interval=5s --timeout=3s CMD curl -fs http://localhost/ || exit 1  </span><br><span class="line">每5秒执行一次,如果超过这个时间没有返回数据,则说明出异常,返回0代表正常,1代表异常</span><br><span class="line">ONBUILD 为子镜像执行的命令,后面可以跟RUN,CMD这些</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dockerfile 的流程解释</span><br><span class="line"></span><br><span class="line">要想明白dockerfile 咱们就得知道docker commit 制作镜像,dockerfile 其实也就是使用了它做镜像</span><br><span class="line"></span><br><span class="line">FROM -&gt; 启动一个容器</span><br><span class="line">ENV -&gt; 定义一些变量供下面的命令使用</span><br><span class="line">RUN  -&gt; 进入容器更改文件或者安装东西然后 commit  所以我们不要写很多run(如果有很多命令,我们可以使用&amp;&amp;连接起来) </span><br><span class="line">不然就会commit很多次,这样的镜像很臃肿 </span><br><span class="line">(我们最好写一组清理工作的命令,将那些没有用的文件给删掉)</span><br><span class="line">CP -&gt; 将上下文里面的东西复制到容器里面 会将源文件的各种元数据都保留(所有者,所属组) 我们可以通过 --chown=user:group来更改</span><br><span class="line">ADD -&gt; 将压缩包解压,也可以使用--chown=user:group 这个参数</span><br><span class="line">CMD -&gt; 相当于 docker run -d CMD 这样,所有我们不要瞎写CMD,如果CMD命令执行完了,那么这个进程就执行完了,容器一起来就结束(cmd与ENTRYPOINT只会执行一次,多写了没用)</span><br></pre></td></tr></table></figure><p>再以上面commit的例子来一遍dockerfile的操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mkdir mynginx &amp;&amp; cd mynginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">默认支持dockerfile Dockerfile 可以构建的时候使用-f指定dockerfile的路径</span></span><br><span class="line">vim Dockerfile</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">编写dockerfile</span></span><br><span class="line">FROM nginx</span><br><span class="line">RUN echo &quot;&lt;h1&gt;hello world DJM NB&lt;/h1&gt;&quot; &gt; /usr/share/nginx/html/index.html</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构建dockerfile</span> </span><br><span class="line">docker build -t mynginx:v2 .  #这个.是上下文路径,不是dockerfile的路径哦</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输出的东西</span></span><br><span class="line">Sending build context to Docker daemon 2.048 kB #将上下文的东西发给docker守护进程</span><br><span class="line">Step 1/2 : FROM nginx</span><br><span class="line"><span class="meta prompt_"> ---&gt; </span><span class="language-bash">88736fe82739</span></span><br><span class="line">Step 2/2 : RUN echo &quot;&lt;h1&gt;hello world DJM NB&lt;/h1&gt;&quot; &gt; /usr/share/nginx/html/index.html</span><br><span class="line"><span class="meta prompt_"> ---&gt; </span><span class="language-bash">Running <span class="keyword">in</span> fbccf519f6af</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"> ---&gt; </span><span class="language-bash">873049df2a75</span></span><br><span class="line">Removing intermediate container fbccf519f6af</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看我们的镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">运行容器</span></span><br><span class="line">docker run -d --name nginx2 -p 8082:80 mynginx:v2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看网页</span></span><br></pre></td></tr></table></figure><p>docker build 的流程</p><p>首先将上下文中不在.dockerignore里面的文件全部(是全部哦,所以你的上下文中,不要多一些乱七八糟没有用的东西)发送给docker服务端(守护进程),然后再依次执行dockerfile里面的指令</p><p>注意点:   </p><ul><li>默认情况下,是在上下文里面找dockerfile,不过我们可以通过-f 来指定dockerfile的路径</li><li>在dockerfile的编写时,使用cp 或者 add命令的时候, 要访问上下文里面的文件时候,要使用.&#x2F; 开头,不能使用绝对路径这样,除非你把上下文放到了根目录下面,这样你会将硬盘里面的文件全部发送给守护进程</li></ul><p>挖个坑</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dockerfile</span></span><br><span class="line"><span class="keyword">FROM</span> centos:<span class="number">7</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> /data</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">touch</span> /data/file</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 请问我将上面这个dockerfile build生成镜像然后运行容器的时候,这个文件会存在吗?</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 答案是:不会</span></span><br><span class="line">我们来分析一下流程:</span><br><span class="line">首先拿到基础镜像,启动一个挂在了本地无名容器卷的容器,这样容器里面就有了/data目录,然后在/data里面创建文件,然后进行提交</span><br><span class="line">但是/data目录的东西并不会被打包,它不属于容器,提交后,docker再把这个无名卷删掉了,所有压根就不会有这个文件存在,只会有/data目录</span><br><span class="line">总结: 要判断创建文件会不会存在镜像中,我们只需要判断这个文件的创建是在挂在容器卷之前还是之后,如果是挂在容器卷之前,而且正好是在容器卷下面创建的,那么不会存在,不然就会存在</span><br><span class="line">这个<span class="keyword">VOLUME</span><span class="language-bash"> 选项就是为了防止用户不设置容器卷,也能有一个匿名卷,还有就是能给给使用者留点讯息</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f `docker ps -aq` 快速删除所有容器  docker ps -aq 是列出所用容器id </span><br></pre></td></tr></table></figure><p>* </p><p> <strong>容器是否会长久运行，是和 <code>docker run</code> 指定的命令有关，和 <code>-d</code> 参数无关</strong></p><p>如果使用attach进入容器,退出后则会结束容器,但是使用exec命令</p><h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h2><p>这个东西是用来管理docker容器的,那么多docker容器,难道我们每次部署都要去一一启动并且配置吗?那多麻烦,得用docker-compose去管理</p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://get.daocloud.io/docker/compose/releases/download/v2.4.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">赋予权限</span></span><br><span class="line">chmod o+x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>配置好自动自动补全</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -L https://raw.githubusercontent.com/docker/compose/1.27.4/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose</span></span><br></pre></td></tr></table></figure><h3 id="卸载-1"><a href="#卸载-1" class="headerlink" title="卸载"></a>卸载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -f /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><p>​我们使用docker-compose的时候可以指定一些参数</p><ul><li>-f 指定docker-compse.yml的位置(默认就在当前目录) </li><li>-p 指定项目名字(默认就是目录名字)</li></ul><blockquote><p>docker-compose只有在具有docker-compose.yml目录下使用才有用(<strong>除非指定docker-compse.yml的位置</strong>),否则会提示<br>no configuration file provided: not found</p></blockquote><h4 id="build-1"><a href="#build-1" class="headerlink" title="build"></a>build</h4><p>构建项目中的镜像,就是构建在配置文件中使用了build配置项的服务,如果有的话,则会构建一个镜像到仓库中,默认名字是当前目录名字+service对应的名字</p><h4 id="config"><a href="#config" class="headerlink" title="config"></a>config</h4><p>检查配置文件是否正确,正确则显示完整配置文件,否则说明错误原因</p><h4 id="down"><a href="#down" class="headerlink" title="down"></a>down</h4><p>删掉项目中通过up启动的服务,并且删除网络</p><h4 id="exec-1"><a href="#exec-1" class="headerlink" title="exec"></a>exec</h4><p>进入项目中的容器</p><h4 id="images-1"><a href="#images-1" class="headerlink" title="images"></a>images</h4><p>列出compose文件中启动的容器对应的镜像</p><h4 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h4><p>杀掉一个项目中的服务(得使用服务名字哦)</p><h4 id="stop-1"><a href="#stop-1" class="headerlink" title="stop"></a>stop</h4><p>停止一个服务</p><h4 id="up"><a href="#up" class="headerlink" title="up"></a>up</h4><p>这个命令巨屌好吧,帮我们省了不少事,它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作</p><h4 id="scale"><a href="#scale" class="headerlink" title="scale"></a>scale</h4><p>指定开启服务个数,如果服务多于这个就停止,少了就增加 </p><h3 id="docker-compose-yml-模板"><a href="#docker-compose-yml-模板" class="headerlink" title="docker-compose.yml 模板"></a>docker-compose.yml 模板</h3><h4 id="build-2"><a href="#build-2" class="headerlink" title="build"></a>build</h4><p>如果镜像存在则不会构建镜像,否则根据指定文件夹路径(可以是相对docker-compose.yml的路径,也可以是绝对路径)构建镜像,构建镜像的名字为当前docker-compose 文件所在目录的目录名+服务名字版本为最新版本,子命令</p><ul><li>context 指定dockerfile的位置</li></ul><h4 id="command"><a href="#command" class="headerlink" title="command"></a>command</h4><p>覆盖容器启动的时候执行的命令,也就是相当于在dockerfile后面多加一条CMD</p><h4 id="devices"><a href="#devices" class="headerlink" title="devices"></a>devices</h4><p>设备映射关系</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devices:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;/dev/ttyUSB1:/dev/ttyUSB0&quot;</span></span><br></pre></td></tr></table></figure><h4 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a>depends_on</h4><p>解决容器依赖关系,比如先得启动哪些服务,在启动自己</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br></pre></td></tr></table></figure><p>比如这个先启动,db,redis 然后就启动自己(不是等db,redis,完全启动后再启动自己哦)</p><h4 id="dns"><a href="#dns" class="headerlink" title="dns"></a>dns</h4><p>指定DNS服务器,可以是单个数据,也可以是列表</p><h4 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h4><p>指定环境变量</p><p>设置环境变量。你可以使用数组或字典两种格式。</p><p>只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">environment:</span></span><br><span class="line">  <span class="attr">RACK_ENV:</span> <span class="string">development</span></span><br><span class="line">  <span class="attr">SESSION_SECRET:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">environment:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">RACK_ENV=development</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">SESSION_SECRET</span></span><br></pre></td></tr></table></figure><p>如果变量名称或者值中用到 <code>true|false，yes|no</code> 等表达 <a href="https://yaml.org/type/bool.html">布尔</a> 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。</p><h4 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h4><p>暴露端口,但是不映射,互联在一个网络中的容器可以访问</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">expose:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;3000&quot;</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;8000&quot;</span></span><br></pre></td></tr></table></figure><h4 id="extra-hosts"><a href="#extra-hosts" class="headerlink" title="extra_hosts"></a>extra_hosts</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">extra_hosts:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;mysql:123.323.12.12&quot;</span></span><br></pre></td></tr></table></figure><p>这个时候&#x2F;etc&#x2F;hosts下面会多</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123.323.12.12 mysql</span><br></pre></td></tr></table></figure><h4 id="healthcheck"><a href="#healthcheck" class="headerlink" title="healthcheck"></a>healthcheck</h4><p>通过命令检查容器是否健康运行。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">healthcheck:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">test:</span> [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;http://localhost&quot;</span>]</span><br><span class="line">  <span class="attr">interval:</span> <span class="string">1m30s</span></span><br><span class="line">  <span class="attr">timeout:</span> <span class="string">10s</span></span><br><span class="line">  <span class="attr">retries:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="image"><a href="#image" class="headerlink" title="image"></a>image</h4><p>指定为镜像名称或镜像 ID。如果镜像在本地不存在，Compose 将会尝试拉取这个镜像,用这个镜像启动作为容器</p><h4 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h4><p>配置日志</p><h4 id="port"><a href="#port" class="headerlink" title="port"></a>port</h4><p>与docker run -p 里面的作用是差不多的</p><h2 id="额外补充"><a href="#额外补充" class="headerlink" title="额外补充"></a>额外补充</h2><h3 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h3><p>如果我们虚拟机没有连接外网,但是我们本机可以连接外网,我们可以使用本地下载好后,上传到虚拟机,然后</p><h2 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h2><ul><li><p>开启或者关闭防火墙后,一定要重启docker,不然会报错</p></li><li><p>如果挂载好容器卷发现在容器里面无法访问数据,权限出问题,那大概率是selinux没有设置成disabled   修改&#x2F;etc&#x2F;selinux&#x2F;config 里面的SELINUX为disabled</p></li><li><p><strong>Failed to get D-Bus connection: Operation not permitted</strong> ,Docker的设计理念是在容器里面不运行后台服务，容器本身就是宿主机上的一个独立的主进程，也可以间接的理解为就是容器里运行服务的应用进程。一个容器的生命周期是围绕这个主进程存在的，所以正确的使用容器方法是将里面的服务运行在前台。但是要在容器里面运行一个服务也不是不可以,创建容器的时候使用 &#x2F;usr&#x2F;sbin&#x2F;init作为启动执行命令,然后加入–privileged&#x3D;true</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -id -p 8081:22 --name centos7 --privileged=true  centos:7 /usr/sbin/init</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/12/01/%E5%85%B6%E4%BB%96/test/"/>
      <url>/2022/12/01/%E5%85%B6%E4%BB%96/test/</url>
      
        <content type="html"><![CDATA[<p>没开代理</p><p>GET &#x2F; HTTP&#x2F;1.1<br>Host: localhost:18000<br>Connection: keep-alive<br>sec-ch-ua: “Microsoft Edge”;v&#x3D;”107”, “Chromium”;v&#x3D;”107”, “Not&#x3D;A?Brand”;v&#x3D;”24”<br>sec-ch-ua-mobile: ?0<br>sec-ch-ua-platform: “Windows”<br>Upgrade-Insecure-Requests: 1<br>User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;107.0.0.0 Safari&#x2F;537.36 Edg&#x2F;107.0.1418.62<br>Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,<em>&#x2F;</em>;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9<br>Sec-Fetch-Site: none<br>Sec-Fetch-Mode: navigate<br>Sec-Fetch-User: ?1<br>Sec-Fetch-Dest: document<br>Accept-Encoding: gzip, deflate, br<br>Accept-Language: zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8,en-GB;q&#x3D;0.7,en-US;q&#x3D;0.6</p><p>开了代理</p><p>GET &#x2F; HTTP&#x2F;1.1<br>Host: localhost:18000<br>Connection: keep-alive<br>sec-ch-ua: “Microsoft Edge”;v&#x3D;”107”, “Chromium”;v&#x3D;”107”, “Not&#x3D;A?Brand”;v&#x3D;”24”<br>sec-ch-ua-mobile: ?0<br>sec-ch-ua-platform: “Windows”<br>Upgrade-Insecure-Requests: 1<br>User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;107.0.0.0 Safari&#x2F;537.36 Edg&#x2F;107.0.1418.62<br>Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,<em>&#x2F;</em>;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9<br>Sec-Fetch-Site: none<br>Sec-Fetch-Mode: navigate<br>Sec-Fetch-User: ?1<br>Sec-Fetch-Dest: document<br>Accept-Encoding: gzip, deflate, br<br>Accept-Language: zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8,en-GB;q&#x3D;0.7,en-US;q&#x3D;0.6</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/11/26/408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
      <url>/2022/11/26/408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="十万个为什么"><a href="#十万个为什么" class="headerlink" title="十万个为什么"></a>十万个为什么</h2><p>目前CPU分为两种架构,精简指令集和复杂指令集,不同的CPU的指令集是不一样的</p><p>精简指令集(RISC):动作简单,执行时间短,效率高,执行复杂操作的时候,需要多条指令集完成  主要的CPU有:ARM ,SPARC</p><p>复杂指令集(CISC):</p><p>硬盘是分扇区的,以前每个扇区512B,为了减少存储一个文件的拆解 现在一般是 4KB(所以现在文件所占大小一定是4KB的整数倍,所以文件的实际大小一般比文件所占大小小),</p><p>传统硬盘是分为很多盘片,每个盘片上又分为很多磁道(就是一圈一圈的),每个磁道又分了很多扇区,每个扇区就是存放一个文件的一部分的地方,每个盘片相同的磁道被称为柱面,当我们需要数据时,告诉磁头在哪个盘面哪个扇区哪个柱面就行,这样是比较慢的,因为盘面转一圈才能找到一个或者多个文件块.</p><p>固态硬盘像内存那样,可以直接定位到数据在哪,所有就非常快</p><p><strong>Linus是很聪明,但是,我觉得他的成功可不只有聪明,他早些年的经历(学过组合语言,经常跟硬件打交道,明白硬件的特性,CPU不够用,需要紧凑,这样写代码的话需要充分考虑资源,这些不是正好符合操作系统的功能吗?),让他写出了如此优秀的操作系统</strong></p><p><strong>为什么1TB的固态硬盘只有930多GB呢?</strong></p><p>因为1TB中的T对应的是10^12,而930多中的G单位是2^30</p><p><strong>为什么CPU型号一样,可执行程序不可以同时在windows和linux上跑呢?</strong></p><p>因为可执行程序里面不只有机器指令,它还包括了数据,运行资源等等,这些需要操作系统的管理的,不同的操作系统有不同的管理方式,还有就是api的不同,不同的操作系统提供的api是不同的,所以可执行程序需要同CPU,同操作系统才能跑起来</p><p><strong>是不是频率越高,CPU就越好呢?</strong></p><p>答案是否定的,频率越高只能说明,CPU运行次数快,但是不同的CPU对应的指令集不同,架构不同,所以每款CPU每次频率做的执行的指令也不一样多,如果一款CPU频率高,而且每次频率做执行指令也多,那么说明这个CPU好</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/11/25/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/docker%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2022/11/25/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/docker%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<hr><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/2022/11/25/git/git%E6%80%BB%E7%BB%93/"/>
      <url>/2022/11/25/git/git%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是git"><a href="#什么是git" class="headerlink" title="什么是git"></a>什么是git</h3><p>git是一个**”分布式”** <strong>“版本控制”</strong> 系统,简明扼要</p><p>什么是版本控制: 就是当你进行了修改,它会帮你保存原先的版本,当你想用原先版本的时候,它能帮你找到原先版本并且恢复过来</p><p>什么是分布式: 就是你可以从任何一个远程仓库中克隆过来,也可以提交到任何一个远程仓库,而不局限于某一个仓库</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>工作空间:就是创建git仓库的目录(.git除外)</p><p>暂存区: 用于存放于 git add 文件的地方,可能有人会说了,直接提交到仓库不就好了吗?对,确实可以,但是你想啊,每次改变一个文件就要提交一次,你不烦啊,我们可以改变以后一次提交嘛,而且你提交之后,就会有新纪录,如果你改一个文件就提交一次那不得产生很多版本吗?,到时候回退都不知道咋整,所以得整体改变完了后再做一次提交,改了部分就直接放到暂存区,还有就是,你暂存了之后,如果不对还能把它拿出来修改,如果直接提交了再做修改则又是一次提交</p><p>仓库: 就是存放你历史信息的地方(.git)</p><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><ul><li>git init 当前目录初始化仓库</li><li>git init path 指定目录初始化仓库</li><li>git</li></ul><h4 id="add"><a href="#add" class="headerlink" title="add"></a>add</h4><p>将修改的文件提交到暂存区</p><h4 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h4><p>将暂存区的文件提交到仓库中,<strong>而不是将工作目录中的文件提交到仓库中</strong></p><ul><li><strong>-m</strong> 添加提交消息</li><li><strong>-a</strong> 将<strong>所有追踪的而且修改的文件</strong>放入暂存区,一次提交</li><li><strong>–amend</strong> 如果我们已经提交了暂存区的东西,但是我们发现还有已经修改的文件没有提交到暂存区,我们需要把修改的文件提交到暂存区,然后使用–amend参数提交,这样就只有一次提交记录</li></ul><h4 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h4><ul><li>git diff 输出 工作目录与暂存区的区别(如果暂存区没有,则输出工作区与最近一次提交版本的区别)</li><li>git diff –staged&#x2F;cache 输出暂存区与最近一次提交版本的区别</li></ul><p>输出信息说明:</p><p>diff –git a&#x2F;test4.txt b&#x2F;test4.txt  (a&#x2F;test4.txt 是修改前 b&#x2F;test4.txt 是修改后)<br>index d00491f..0cfbf08 (修改前后的hash值) 100644(文件权限)<br>— a&#x2F;test4.txt (修改前文件)<br>+++ b&#x2F;test4.txt (修改后文件)<br>@@ -1 +1,2 @@ (修改前文件从第一行开始,总共一行(默认一行), 修改后文件从第一行开始,总共两行)<br>- 修改前文件位置内容<br>+ 修改后文件对应内容<br>+ 修改后文件对应内容</p><h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><p>这里是一个难以理解的点,请先看额外补充中git rm 与 rm 的区别</p><ul><li>git rm 直接删除文件而且提交”修改文件”到暂存区</li><li>git rm –cached 不删除文件 提交”修改文件”到暂存区</li></ul><h4 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h4><p>移动文件(可以做改名和删除操作)</p><h4 id="log"><a href="#log" class="headerlink" title="log"></a>log</h4><p>输出<strong>这个版本</strong>以前的历史版本信息,因为我们有时候会回退,所有当前版本不一定是最新版本</p><p>常用参数</p><ul><li>-p 输出版本信息的同时,输出两次对比</li><li>–stat 输出这个版本的简略信息,有多少行被增加,多少行被删除</li><li>–pretty&#x3D;oneline 将hash值与提交信息放在一行</li><li>-n 显示最近n次提交记录</li><li>–since, –after  仅显示指定时间之后的提交。</li><li>–until, –before 仅显示指定时间之前的提交。</li><li>–author 显示作者匹配字符的提交</li><li>–grep 显示提交说明中包含指定字符的提交</li></ul><h4 id="reflog"><a href="#reflog" class="headerlink" title="reflog"></a>reflog</h4><p>显示可引用的历史版本记录,就是显示在本地仓库的操作的历史版本记录,如果你不小心回退了回去,又不记得以前版本的hash值,你可以通过这个查看,如果是克隆远程仓库下来,你是看不了别人操作记录的,我觉得这个也很合理,别人没有创建分支来记录这个东西,确实没有必要看这些操作,只需要本地能够操作就行</p><h4 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h4><p>将远程仓库克隆到本地,默认创建orgin远程用户</p><ul><li><p>git clone url  克隆仓库的所有分支</p></li><li><p>git clone url -b 分支 克隆仓库的指定分支</p></li></ul><h4 id="checkout"><a href="#checkout" class="headerlink" title="checkout"></a>checkout</h4><p>可以切换分支,也可以创建分支,还可以移动HEAD指针位置</p><ul><li>git checkout name 切换分支</li><li>git checkout -b name 创建分支并且切换分支</li><li>git checkout commitid 移动HEAD 指针到这个位置,但是并不会创建分支</li></ul><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><ul><li>git switch name 切换分支</li><li>git switch -c name 创建分支(在当前版本上创建)并且切换分支</li><li>git switch -c name commitid 创建commitid对应版本的分支并且切换分支</li></ul><h4 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h4><ul><li>git branch 查看所有分支</li><li>git branch name 创建分支</li><li>git branch -v 查看所有分支的最后一次提交</li><li>git branch –merged name(默认为当前分支名字) 查看和name已经合并的分支</li><li>git branch –no-merged  name(默认为当前分支名字) 查看和name没有合并的分支</li><li>git branch -d name 删除分支</li><li>git branch -r 显示远程仓库的分支</li></ul><p>在a分支合并b a变成a和b合并体 但是b还在原地, 所以在 a 分支下 git branch –merged  是b 但是在b分支下 git branch –merged 是没有a的, 如果两个分支在同一个版本下,默认它两是合并的</p><h4 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h4><p>合并分支,如果两个分支都在同一条线上,就会快速合并(不会产生冲突),否则就看有没有冲突,如果有冲突则会将将不同的东西给列出来,生成一个新的同名文件到工作空间,等着我们去修改,修改完后再提交到暂存区,在提交到仓库</p><ul><li>git merge branchname    合并本地分支</li><li>git merge 远程仓库明&#x2F;branchname   合并远程分支</li></ul><h4 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h4><p>给当前版本打标签,就跟书签是一样的概念</p><ul><li>git tag tagname commitid 给commitid这个版本打一个简单标签</li><li>git tag -a tagname commitid -m 标注信息   给commitid这个版本打一个注解标签</li><li>git tag -d tagname 删除标签</li></ul><h4 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h4><ul><li>restore file (推荐使用)</li><li>checkout – file    这个命令功能与上面的是一样的,将文件还原为与上一次提交的文件的状态  <strong>这两个命令只能操作已修改状态的文件,不能操作暂存区的文件</strong></li><li>restore –staged  file(推荐使用)</li><li>reset HEAD file 同上 将文件从暂存区移除</li></ul><h4 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h4><p>重置到某个版本,但是这个版本之后的记录将不会出现在历史记录中(也就是git log 是看不到这个版本之后的提交记录的,可以通过git reflog 找到上一次重置的版本号,再一次重置回去,就能找到历史记录了)</p><ul><li>git reset &#x3D;&#x3D; git reset –mixed 工作目录文件保持不变(但是与重置的版本不同则状态会变成已修改,相当于我们在重置版本的文件上,修改成为当前目录文件)</li><li>git reset –soft 工作目录文件不变(但是与重置版本不同,状态则会变成暂存,相当于我们暂存了一次重置版本的文件,然后修改了目录文件为工作目录文件)</li><li>git reset –hard 工作目录变成重置版本文件</li></ul><h4 id="revert"><a href="#revert" class="headerlink" title="revert"></a>revert</h4><p>回退到某个历史版本,但是这个回退操作相当于一次提交,他的功能和reset很像,但是还是有区别的,详情请看额外补充</p><h4 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h4><p><strong>能进行分支合并</strong>,与merge的区别请看额外补充,这个还能修改历史提交,也请看额外补充</p><ul><li>git rebase branchname 合并分支 每一个不同的提交都需要去操作一下如果有冲突,就需要解决冲突</li></ul><h4 id="remote"><a href="#remote" class="headerlink" title="remote"></a>remote</h4><ul><li>git remote add name url  添加远程仓库(不写name 默认为orgin)</li><li>git remote 查看远程仓库名字</li><li>git remote -v  查看远程仓库名字对应url</li><li>git remote rename oldname newname 修改名字</li><li>git remote remove name 删除远程仓库</li><li>git remote set-url name url 更改url</li></ul><h4 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h4><p>拉取远程仓库的最新分支到本地,</p><ul><li>git fetch repositoryname  更新所有分支</li><li>git fetch repositoryname branch 更新指定分支</li></ul><h4 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h4><p>拉取远程仓库最新分支并且进行合并,如果远程仓库版本低于当前分支则会生成对比文件,需要我们自己去修改,然后再提交</p><ul><li>git pull 远程仓库名字 分支</li><li>git pull –rebase 远程仓库名字 分支 合并的时候选择用rebase这个方式</li></ul><h4 id="push"><a href="#push" class="headerlink" title="push"></a>push</h4><ul><li>git push repositoryname localbranchname:remotebranchname 推送本地分支到远程分支上</li><li>git push repositoryname :remotebranchname &#x3D;&#x3D; git push name –delete remotebranchname 删除远程仓库分支</li><li>git push repositoryname 推送所有分支到远程仓库</li><li><strong>git push -u 远程仓库名字 分支名</strong>  推送分支到远程仓库,并且创建与之对应的上流分支关系,以后在这个分支上可以直接执行git push命令就能将这个分支推送上去</li></ul><h4 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h4><p>我们在一个分支上修改了很多文件,但是我们现在需要切换到另一个分支去工作,我们又不想提交一次当前分支,所有我们需要储藏当前分支的内容,当我们回到这个分支的时候,再将数据恢复过来</p><ul><li>git stash 将当前工作区,暂存区的已追踪的文件放到贮藏区里面,<strong>这个结构是堆栈结构</strong></li><li>git stash list 查看贮藏区所有的东西</li><li>git stash apply stash@{编号} –index 将贮藏区的东西恢复到当前目录,如果不加–index 则不会恢复已暂存的</li></ul><h3 id="额外补充"><a href="#额外补充" class="headerlink" title="额外补充"></a>额外补充</h3><p>记住，在 Git 中任何 <strong>已提交</strong> 的东西几乎总是可以恢复的。 </p><h4 id="git-rm-与-rm-有什么区别"><a href="#git-rm-与-rm-有什么区别" class="headerlink" title="git rm 与 rm 有什么区别?"></a>git rm 与 rm 有什么区别?</h4><p>rm 是删除本地文件 这也算是对文件的一种操作,和修改这个文件是一样的,这个时候git会把它当成已修改文件处理,所以这个文件不在暂存区中,当你直接commit的时候你commit不了,必须使用commit -am 提交</p><p>当前使用 git rm的时候 git会直接把这个以修改文件直接暂存起来 当你直接使用commit的时候也能commit</p><p>无论使用git rm(后面不带–cached) 还是 rm 都可以删除文件 只要提交成功 git 都不会再追踪这个文件,它两的区别就在与提交的时候 需要使用的参数不同罢了,就跟跳过暂存区与不跳过暂存区一样 </p><p>总结:  rm a  + git add a &#x3D;&#x3D; git rm a</p><p>同理 mv a b + git rm a + git add b &#x3D;&#x3D; git mv a b</p><h4 id="本地远程分支"><a href="#本地远程分支" class="headerlink" title="本地远程分支"></a>本地远程分支</h4><p>当我们使用clone 或者 remote add 的时候, 我们本地会创建一个本地远程仓库分支 比如 origin&#x2F;master,这个分支是远程仓库的内容,我们是无法直接使用这个分支的,我们只能新创建一个分支去引用它,然后做提交到远程服务器,才能修改它,所以当我们使用git fetch 时,是把本地远程分支更新,不会影响到本地分支,我们也可以再通过git merge 去合并这个远程分支</p><h4 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h4><p>补丁其实就是一次提交记录,一个版本,我们可以把每次提交的东西都做成补丁,那补丁有什么用呢,它能够直接合并到一个分支里面,在rebase里面会有体现,我们一般不自己去打补丁,然后进行合并</p><h4 id="reset-revert-rebase"><a href="#reset-revert-rebase" class="headerlink" title="reset revert rebase"></a>reset revert rebase</h4><p>这三个都能操作历史版本,那有什么区别呢?</p><p>如果我们只是想回到某个历史版本,这个版本到历史版本之间提交了的记录,我不要了,我们可以使用reset(适合单文件一个地方改了很多次,然后回退回去)</p><p>如果我们想留着这个版本到历史版本之间的提交记录,可以使用revert,但是会再产生一次提交记录</p><p>上面两个指令的操作其实功能都是一样的,回退到历史某个版本,但是,这个版本和历史版本之间做出的修改,我们是无法保存的,而且,我们完全可以不用上面这两个指令,我们完全可以新建一个分支到历史版本上,做相应的修改</p><p>如果我们需要这个版本与历史版本之间提交了的东西,我们需要使用rebase命令,去依次修改有冲突的版本,如果是两个人开发一个分支,那么这个命令就要小心的用了,首先使用了这个命令修改了历史版本后,必须强制推送,那边开发的人要先合并解决冲突才能继续干活</p><h4 id="rebase合并分支流程及要点"><a href="#rebase合并分支流程及要点" class="headerlink" title="rebase合并分支流程及要点"></a>rebase合并分支流程及要点</h4><p>假设我们现在在master分支,然后有一个test分支,这两个分支有两个相同的提交版本,两个不同的提交版本,我们现在要将test分支的东西合并到master分支后面,我们需要的命令时  <strong>切换到test分支</strong> 然后进行 <strong>git rebase master</strong>  这里会创建一个新的游离分支,游离分支的起始位置为master,这样就会依次将HEAD与test与master不同的提交版本进行merge操作,最后test分支会指向HEAD,我们还需要将master分支重置到这里,或者直接合并(快速合并) </p><p><strong>只对尚未推送或分享给别人的本地修改执行变基操作清理历史， 从不对已推送至别处的提交执行变基操作</strong></p><h4 id="rebase为什么可以对历史版本修改"><a href="#rebase为什么可以对历史版本修改" class="headerlink" title="rebase为什么可以对历史版本修改"></a>rebase为什么可以对历史版本修改</h4><p>有下面这么一个仓库,我想把提交信息”1” 改成 “3” (当然,也可以改文件,这里不做演示)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span></span></span><br><span class="line">commit db40dce754f63cba67bdf70871f0c04ace718023 (HEAD -&gt; master)</span><br><span class="line">Author: djmnb &lt;1632782287@qq.com&gt;</span><br><span class="line">Date:   Tue Nov 22 16:39:23 2022 +0800</span><br><span class="line"></span><br><span class="line">    2</span><br><span class="line"></span><br><span class="line">commit 661f0b561591380f3b9c4a3a7187b5b165e49975</span><br><span class="line">Author: djmnb &lt;1632782287@qq.com&gt;</span><br><span class="line">Date:   Tue Nov 22 16:39:07 2022 +0800</span><br><span class="line"></span><br><span class="line">    1</span><br></pre></td></tr></table></figure><p>可以直接通过下面这个命令,根据提示直接改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~1 修改前一个版本信息</span><br></pre></td></tr></table></figure><p>  上面这个命令和下面的等价,看完下面这组命令,你就知道rebase为什么就能修改历史版本信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> git switch -c test  HEAD~1 # 创建一个临时分支,并且切换到临时分支</span><br><span class="line"> git commit --amend -m &quot;3&quot; # 修改提交信息</span><br><span class="line"> git switch master # 切换回原先分支</span><br><span class="line"> git rebase test # 合并分支</span><br><span class="line"> git branch -D test #删掉分支</span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">更改成功(如果这一步有冲突,就会等你解决冲突)</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果有很多版本,那就是一个递归操作,知道所有的版本都修改完</span></span><br><span class="line"><span class="meta prompt_"> $ </span><span class="language-bash">git <span class="built_in">log</span></span></span><br><span class="line">commit a188fc1146864dd12ffcd28a72bb5c920e5590a8 (HEAD -&gt; master)</span><br><span class="line">Author: djmnb &lt;1632782287@qq.com&gt;</span><br><span class="line">Date:   Tue Nov 22 16:39:23 2022 +0800</span><br><span class="line"></span><br><span class="line">    2</span><br><span class="line"></span><br><span class="line">commit 37d7ed5c2be4f0c52b5c345e1734c231d2647a11 (test)</span><br><span class="line">Author: djmnb &lt;1632782287@qq.com&gt;</span><br><span class="line">Date:   Tue Nov 22 16:39:07 2022 +0800</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>我这样也可以,用来理解这个操作还是很好的</p><p>rebase命令会给你提供一个文档,让你更改里面的文字选择对哪个版本进行修改,退出后,会依次来到要修改的版本,然后进行修改,提交,这样其实是产生新的提交,原来的提交其实还在,只是我们看不到了,所以rebase修改历史记录的本质,不是修改,而是新建,隐藏旧提交,这样让我们看起来像是修改了</p><h4 id="rebase-与-merge的区别"><a href="#rebase-与-merge的区别" class="headerlink" title="rebase 与 merge的区别"></a>rebase 与 merge的区别</h4><p>两个都能合并分支,但是merge合并的时候,不是线性合并,只是两个提交版本间的合并,而rebase合并的时候,会将发起合并所在分支中的所有在待合并的分支中没有的提交进行合并,这样的话,看起来是线性的,其实也不是线性的,只是原先那些提交记录,没有人去管他们,变成了游离分支,所以用git log查看不到原先的那些提交版本</p><h4 id="git钩子"><a href="#git钩子" class="headerlink" title="git钩子"></a>git钩子</h4><p>所谓钩子就是,再某一时刻,会被自动执行的代码,我们可以通过编写钩子代码,做到很多自动化的事,比如提交前干嘛,提交后干嘛,这个还是有点用处的,我么可以在用户提交后把提交来的东西转交给别处</p><h4 id="搭建git服务器"><a href="#搭建git服务器" class="headerlink" title="搭建git服务器"></a>搭建git服务器</h4><p>为了方便,首先先创建一个git用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd git</span><br><span class="line">passwd git # 修改登录密码</span><br><span class="line">su git # 切换到git用户</span><br></pre></td></tr></table></figure><p>创建git仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">mkdir git</span><br><span class="line">cd git</span><br><span class="line">git init --bare test.git</span><br></pre></td></tr></table></figure><p>现在可以克隆这个仓库了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone git@ip地址:/home/git/test.git</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后输入密码就可以了,如果不想输入密码,可以将本机的公钥放到/home/git/.ssh/authorized_keys 文件里面</span></span><br></pre></td></tr></table></figure><h4 id="sourceTree"><a href="#sourceTree" class="headerlink" title="sourceTree"></a>sourceTree</h4><p>其实吧,命令会一些基本就行了,咱们主要还是得用可视化啊,建议不要对这些命令钻的太深,但是一定要记住git可以做哪些操作,下面讲讲sourceTree中的操作对应哪些命令</p><p><img src="/2022/11/25/git/git%E6%80%BB%E7%BB%93/../img/git%E6%80%BB%E7%BB%93assets/image-20221122140208434.png" alt="image-20221122140208434"></p><p><img src="/2022/11/25/git/git%E6%80%BB%E7%BB%93/../img/git%E6%80%BB%E7%BB%93assets/image-20221122140542104.png" alt="image-20221122140542104"></p><h4 id="个人尝试删掉记录"><a href="#个人尝试删掉记录" class="headerlink" title="个人尝试删掉记录"></a>个人尝试删掉记录</h4><p>我们可能在工作的时候,心里不爽,骂了两句老板,在代码里面,然后我们还提交到了远程库,第二题,又怂了,想从远程库里面吧骂老板那句话给删掉</p><h5 id="方法一-不能删除-但是也难被发现"><a href="#方法一-不能删除-但是也难被发现" class="headerlink" title="方法一(不能删除,但是也难被发现)"></a>方法一(不能删除,但是也难被发现)</h5><p>直接把远程分支删掉,然后在本地修改好后再推送上去,看起来很好,但是,远程库里面会多出来一条游离分支,虽然不能直接看到,但是只要checkout到那个游离分支里面去,就会看到我骂老板的话,如果不是可视化的平台,像gittee,gitlab这种,是无法被发现的(如果不记得commitid,以我目前的水平还不知道怎么发现)</p><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><p>直接本地修改,再进行强制推送,好像这个和方法一也没什么区别(我可真是个大聪明)</p><p>总结:咱们还是不要乱骂老板,只要推送上去了,就会有记录,除非你直接删掉公司的仓库</p><h4 id="不在当前文件夹操作这个仓库"><a href="#不在当前文件夹操作这个仓库" class="headerlink" title="不在当前文件夹操作这个仓库"></a>不在当前文件夹操作这个仓库</h4><p>有时候,我们需要使用本地的git的钩子去操作另一个本地仓库(不知道你们有没有,我可以举个例子,比如我有一个服务器,我本地push一个页面到服务器的git仓库,但是它是一个裸仓库,看不到里面的东西的,而我的服务器部署的nginx需要这个页面,我需要把这个页面拿出来,这个时候我需要给服务器中心仓库设置钩子去自动更新服务器另一个不是裸仓库的仓库),但是这个路径有时候我把握不定,会造成更新失败,这个时候我们使用下面的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --work-tree=仓库路径 --git-dir=仓库路径/.git 命令</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java常用数据结构与方法</title>
      <link href="/2022/11/25/java/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2022/11/25/java/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="comment">// int[] nums = new int[10]&#123;1,3,4&#125; 这种是不行的哦</span></span><br><span class="line"><span class="type">int</span>[] nums = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>数组具有Object 的所有方法,以及一个length属性</p><h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;....&#125; <span class="comment">// i 代表索引</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i:nums)&#123;....&#125; <span class="comment">// i 代表nums里面的数值</span></span><br></pre></td></tr></table></figure><h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p>这个是java提供操作数组的工具类,对于需要使用到排序的地方,基本数据类型只能从小到大,引用数据类型要么实现Comparable接口,要么提供Comparator的实现类</p><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>有很多关于sort的重载方法,参数可以是基本数据类型,也可以是Object类型(因此可以为其他任何类型的数组排序,但是记得要实现Comparable接口或者提供Comparator的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">T[] nums = <span class="keyword">new</span> <span class="title class_">T</span>[<span class="number">10</span>]; <span class="comment">// 这里T代表基本数据类型</span></span><br><span class="line">Arrays.sort(nums);  <span class="comment">//从小到大排序 </span></span><br><span class="line">Arrays.sort(nums,<span class="number">1</span>,<span class="number">3</span>) <span class="comment">// 只排序[1,3) 这个区间里面的数据</span></span><br><span class="line"><span class="comment">// 基本数据类型使用sort方法就只能实现升序,不能实现降序</span></span><br><span class="line">   <span class="comment">//因为泛型它不支持基本数据类型,因此无法提供一个关于int泛型的Comparator接口</span></span><br><span class="line"></span><br><span class="line">T[] nums = <span class="keyword">new</span> <span class="title class_">T</span>[<span class="number">10</span>]; <span class="comment">//这里T代表引用数据类型</span></span><br><span class="line">Arrays.sort(nums)  <span class="comment">//如果要这么写,那么这个类必须实现了Comparable接口</span></span><br><span class="line">   Arrays.sort(nums,(a,b)-&gt;&#123;</span><br><span class="line">       ..... <span class="comment">// 你的判断逻辑,如果返回大于0的数则代表b应该和a换位置,否则就不换(b在后,a在前)</span></span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure><h3 id="parallelSort"><a href="#parallelSort" class="headerlink" title="parallelSort"></a>parallelSort</h3><p>这个方法和sort的用法是一样的,但是当数据量超过某一个值的时候,这个方法会采用并行的方式排序,在多核处理下优势就明显了,如果数据量少于某个值,依然使用sort方法排序,这个值是2^13</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parallelSort</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.length, p, g;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= MIN_ARRAY_SORT_GRAN ||</span><br><span class="line">            (p = ForkJoinPool.getCommonPoolParallelism()) == <span class="number">1</span>)</span><br><span class="line">            DualPivotQuicksort.sort(a, <span class="number">0</span>, n - <span class="number">1</span>, <span class="literal">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ArraysParallelSortHelpers</span>.FJInt.Sorter</span><br><span class="line">                (<span class="literal">null</span>, a, <span class="keyword">new</span> <span class="title class_">int</span>[n], <span class="number">0</span>, n, <span class="number">0</span>,</span><br><span class="line">                 ((g = n / (p &lt;&lt; <span class="number">2</span>)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span><br><span class="line">                 MIN_ARRAY_SORT_GRAN : g).invoke();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="binarySearch"><a href="#binarySearch" class="headerlink" title="binarySearch"></a>binarySearch</h3><p>必须是排序好的数组,利用二分查找找到值所在的位置,如果值不存在,返回它应该在的下标+1的相反数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">System.out.println(Arrays.binarySearch(nums,<span class="number">3</span>)); <span class="comment">//输出 1</span></span><br><span class="line">System.out.println(Arrays.binarySearch(nums,<span class="number">4</span>)); <span class="comment">// 输出 -3</span></span><br><span class="line">System.out.println(Arrays.binarySearch(nums,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>)); <span class="comment">//从[1,3) 这个数组区间去找</span></span><br></pre></td></tr></table></figure><blockquote><p>这个方法无法像c++ 的 lower_bound 和 upper_bound 一样找到第一个等于某个值的位置,和第一个大于某个值的位置,需要我们自己去写二分查找</p></blockquote><h3 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h3><p>比较两个数组元素是否相等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object[] a, Object[] a2)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (a==a2)</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">if</span> (a==<span class="literal">null</span> || a2==<span class="literal">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> a.length;</span><br><span class="line">       <span class="keyword">if</span> (a2.length != length)</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;length; i++) &#123;</span><br><span class="line">           <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> a[i];</span><br><span class="line">           <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> a2[i];</span><br><span class="line">           <span class="keyword">if</span> (!(o1==<span class="literal">null</span> ? o2==<span class="literal">null</span> : o1.equals(o2)))</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h3><p>填充数组的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">Arrays.fill(nums,<span class="number">1</span>); <span class="comment">// 全部填充成1 </span></span><br><span class="line">Arrays.fill(num,<span class="number">2</span>,<span class="number">5</span>,<span class="number">2</span>); <span class="comment">// [2,5) 填充成2</span></span><br></pre></td></tr></table></figure><h3 id="copyOf"><a href="#copyOf" class="headerlink" title="copyOf"></a>copyOf</h3><p>复制数组的值变成另外一个一个数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="type">int</span> newLength) &#123;</span><br><span class="line">        <span class="keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="copyOfRange"><a href="#copyOfRange" class="headerlink" title="copyOfRange"></a>copyOfRange</h3><p>复制某个区间的值变成另外一个数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOfRange(T[] original, <span class="type">int</span> from, <span class="type">int</span> to) &#123;</span><br><span class="line">        <span class="keyword">return</span> copyOfRange(original, from, to, (Class&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>[]&gt;) original.getClass());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="asList"><a href="#asList" class="headerlink" title="asList"></a>asList</h3><p>将可变参数变成list</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>); <span class="comment">//这里参数可以写任意多</span></span><br><span class="line"><span class="comment">// Arrays.asList(new int[]&#123;1,3,4&#125;) ,这种方法只能得到一个元素的列表,泛型还是 int[],所有这个方法是不能将数组变成List的</span></span><br></pre></td></tr></table></figure><blockquote><p>class java.util.Arrays$ArrayList 值这个方法产生的list对应的类,并不是ArrayList 哦</p></blockquote><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h3><p>将数组内容变成字符串,如果是基本数据类型就是拼接字符串,如果是引用数据类型就是执行元素里面的toString 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(nums)); <span class="comment">// [3,2,1]</span></span><br></pre></td></tr></table></figure><h3 id="deepToString"><a href="#deepToString" class="headerlink" title="deepToString"></a>deepToString</h3><p>如果是多维数组,那么toString 是没有办法将他们都转化成字符串的,显示的是地址值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][][] ints = &#123; &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;&#125;,&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;&#125;&#125;;</span><br><span class="line">System.out.println(Arrays.toString(ints)) <span class="comment">// [[[I@61bbe9ba, [[I@610455d6]</span></span><br><span class="line">System.out.println(Arrays.deepToString(ints)); <span class="comment">//[[[1, 2, 3], [2, 3, 4]], [[1, 2, 3], [2, 3, 4]]]</span></span><br></pre></td></tr></table></figure><h3 id="setAll"><a href="#setAll" class="headerlink" title="setAll"></a>setAll</h3><p>根据元素的下标设置元素的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">Arrays.setAll(nums,a-&gt;a*a);</span><br><span class="line">System.out.println(Arrays.toString(nums)); <span class="comment">// [0, 1, 4, 9, 16]</span></span><br></pre></td></tr></table></figure><h3 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h3><p>返回数组的流式数据,这个后面还会再总结</p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>Collection 接口中定义了set接口以及list接口通用的方法,掌握这里面的方法,就不用重复看他们的子接口,实现类的方法了</p><h3 id="提供方法"><a href="#提供方法" class="headerlink" title="提供方法"></a>提供方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;  <span class="comment">//返回 集合中元素个数</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>; <span class="comment">// 集合是否为空</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span>; <span class="comment">// 集合中是否包含某个元素</span></span><br><span class="line">Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>; <span class="comment">// 返回可以迭代整个集合的迭代器</span></span><br><span class="line">&lt;T&gt; T[] toArray(T[] a); <span class="comment">// 将集合变成指定类型的数组,基本数据类型数组是不行的哦,int[]-&gt;T[] T=int 但是基本数据类型没有泛型</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>; <span class="comment">// 添加一个元素 </span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span>; <span class="comment">// 删除一个元素</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span>; <span class="comment">// 是否包含另外一个集合的全部元素</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span>; <span class="comment">// 添加一个集合的所有元素,这个集合的泛型对应的类必须跟我一样或者是我的子类</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span>; <span class="comment">// 移除集合c中包含的所有元素</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span>; <span class="comment">// 移除不在c中的元素</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>; <span class="comment">// 清空集合</span></span><br></pre></td></tr></table></figure><blockquote><p>这个接口就是站在一个很抽象的层面,不管你用何种数据结构,这些方法都是能够实现的,比如删掉某个元素,增加一个元素,,是否包含某个元素等等</p></blockquote><h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><p>list接口是collection的子接口,因此它拥有collection的方法,list接口本身定义了很多方法,因此在它的子类中都会有实现,掌握list中的方法,就不用重复看其子类中的方法了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>; <span class="comment">//获取某个位置的元素</span></span><br><span class="line">E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span>; <span class="comment">// 设置某个位置的元素,返回原先位置的值</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span>; <span class="comment">// 在某个位置添加一个元素,这个位置及其后面的元素往后移动一个位置</span></span><br><span class="line">E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>; <span class="comment">// 删除一个位置的元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span>; <span class="comment">// 元素o 第一次出现的位置</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span>; <span class="comment">// 元素o 最后一次出现的位置</span></span><br><span class="line">List&lt;E&gt; <span class="title function_">subList</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span>; <span class="comment">// 获得子列表</span></span><br></pre></td></tr></table></figure><p><img src="/2022/11/25/java/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/../img/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84assets/image-20221219102945322.png" alt="image-20221219102945322"></p><p>ArrayList 和 linkedList 的区别在于底层实现</p><p>ArrayList 和 Vector 的区别在于 线程安全不安全, ArrayList是线程不安全的,Vector是线程安全的</p><blockquote><p>这个接口感觉就具体些些了,我底层是按**”顺序”**(逻辑上一个元素紧挨一个元素),来存储数据的,因此肯定就有下标这么一说,那么就应该要提供关于下标的方法</p></blockquote><h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><p>Set也是collection的子接口,这个接口并没有额外的定义方法,全部都是collection接口里面的方法,set接口的规定所有的数据必须唯一</p><p><img src="/2022/11/25/java/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/../img/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84assets/image-20221219105205189.png" alt="image-20221219105205189"></p><h4 id="SortedSet接口"><a href="#SortedSet接口" class="headerlink" title="SortedSet接口"></a>SortedSet接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;? <span class="built_in">super</span> E&gt; comparator(); <span class="comment">// 返回排序规则</span></span><br><span class="line"><span class="comment">// 返回 [fromElement,toElement) 这个区间里面的数据(是按照排序规则来的哦),返回结果也是SortedSet类型</span></span><br><span class="line">SortedSet&lt;E&gt; <span class="title function_">subSet</span><span class="params">(E fromElement, E toElement)</span>; </span><br><span class="line">SortedSet&lt;E&gt; <span class="title function_">headSet</span><span class="params">(E toElement)</span>; <span class="comment">//返回小于toElement的数据</span></span><br><span class="line">SortedSet&lt;E&gt; <span class="title function_">tailSet</span><span class="params">(E fromElement)</span>; <span class="comment">// 返回大于等于fromElement的数据 </span></span><br><span class="line">E <span class="title function_">first</span><span class="params">()</span>; <span class="comment">//返回最小的数据</span></span><br><span class="line">E <span class="title function_">last</span><span class="params">()</span>; <span class="comment">// 返回最大的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里面的最小与最大都是相对于排序规则而言</span></span><br></pre></td></tr></table></figure><p>我们可以通过这个接口来找第一个大于等于某个数,大于某个数,最后小于等于某个数,或者小于某个数的数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        SortedSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Integer&gt;();</span><br><span class="line">        set.add(<span class="number">3</span>);</span><br><span class="line">        set.add(<span class="number">7</span>);</span><br><span class="line">        set.add(<span class="number">5</span>);</span><br><span class="line">        set.add(<span class="number">6</span>);</span><br><span class="line">        <span class="comment">//第一个大于等于5的数</span></span><br><span class="line">        System.out.println(set.tailSet(<span class="number">5</span>).first());</span><br><span class="line">        <span class="comment">// 第一个大于5的数</span></span><br><span class="line">        System.out.println(set.tailSet(<span class="number">6</span>).first());</span><br><span class="line">        <span class="comment">// 第最后一个小于5的数</span></span><br><span class="line">        System.out.println(set.headSet(<span class="number">5</span>).last());</span><br><span class="line">        <span class="comment">// 第最后小于等于5的数</span></span><br><span class="line">        System.out.println(set.headSet(<span class="number">6</span>).last());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="NavigableSet接口"><a href="#NavigableSet接口" class="headerlink" title="NavigableSet接口"></a>NavigableSet接口</h4><p>这个是soreted的子接口,它多出来的功能,其实就是上面我们那段代码实现的功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">lower</span><span class="params">(E e)</span>; <span class="comment">// 找到最后一个小于e的元素,也就是小于e的最大值</span></span><br><span class="line">E <span class="title function_">floor</span><span class="params">(E e)</span>; <span class="comment">// 找到最后一个小于等于e的元素</span></span><br><span class="line">E <span class="title function_">ceiling</span><span class="params">(E e)</span>; <span class="comment">// 找到第一个大于等于e的元素</span></span><br><span class="line">E <span class="title function_">higher</span><span class="params">(E e)</span>; <span class="comment">// 找到第一个大于e的元素</span></span><br><span class="line">E <span class="title function_">pollFirst</span><span class="params">()</span>; <span class="comment">//删掉最小的</span></span><br><span class="line">E <span class="title function_">pollLast</span><span class="params">()</span>; <span class="comment">// 删掉最大的</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><h3 id="Queue接口"><a href="#Queue接口" class="headerlink" title="Queue接口"></a>Queue接口</h3><p>这个也是collection的子接口,拥有collection的全部方法,还自己提供了一些额外的方法哦</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>; <span class="comment">// 这个是重写collection里面的方法,往队列里面插入一个元素</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span>; <span class="comment">// 这个也是往队列里面插入一个元素,跟add的区别在于,如果容器不够了,add会抛出异常,offer只会返回false</span></span><br><span class="line">E <span class="title function_">remove</span><span class="params">()</span>;  <span class="comment">// 拿出队首元素</span></span><br><span class="line">E <span class="title function_">poll</span><span class="params">()</span>;  <span class="comment">// 拿出队首元素  和 remove的区别在于, 如果队列为空,poll返回null,remove 抛出异常</span></span><br><span class="line">E <span class="title function_">element</span><span class="params">()</span>; <span class="comment">// 查看队首元素</span></span><br><span class="line">E <span class="title function_">peek</span><span class="params">()</span>; <span class="comment">// 查看队首元素, 和 element 的区别在于 如果队列为空,peek 返回null,element抛出异常</span></span><br></pre></td></tr></table></figure><blockquote><p>刷题的时候推荐使用 offer,poll,peek</p></blockquote><p><img src="/2022/11/25/java/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/../img/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84assets/image-20221219100054193.png" alt="image-20221219100054193"></p><h4 id="Deque接口"><a href="#Deque接口" class="headerlink" title="Deque接口"></a>Deque接口</h4><p>这个是queue接口的子接口,这个是双向队列,在单向队列的基础上额外提供了在头部插入,尾部删除的功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个接口的方法就是在Queue提供的方法上,加上Last,First</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span>; <span class="comment">// 队首添加</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span>; <span class="comment">// 队尾添加</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">offerFirst</span><span class="params">(E e)</span>; <span class="comment">// 队首添加</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">offerLast</span><span class="params">(E e)</span>;  <span class="comment">// 队尾添加  offer和add的区别还是和queue中的一样</span></span><br><span class="line">E <span class="title function_">removeFirst</span><span class="params">()</span>;  <span class="comment">// 删除队首</span></span><br><span class="line">E <span class="title function_">removeLast</span><span class="params">()</span>;  <span class="comment">// 删除队尾</span></span><br><span class="line">E <span class="title function_">pollFirst</span><span class="params">()</span>;<span class="comment">// 删除队首</span></span><br><span class="line">E <span class="title function_">pollLast</span><span class="params">()</span>;<span class="comment">// 删除队尾  </span></span><br><span class="line">E <span class="title function_">getFirst</span><span class="params">()</span>; <span class="comment">// 查看队首元素 这个和 element的功能一样</span></span><br><span class="line">E <span class="title function_">getLast</span><span class="params">()</span>;  <span class="comment">// 查看队尾元素 </span></span><br><span class="line">E <span class="title function_">peekFirst</span><span class="params">()</span>; <span class="comment">// 查看队首</span></span><br><span class="line">E <span class="title function_">peekLast</span><span class="params">()</span>;  <span class="comment">// 查看队尾  这个和 get的区别就跟他和 element区别一样</span></span><br><span class="line"><span class="comment">// 下面这个几个方法,就和栈一样了,我们以后就用Deque的子类代替栈的使用了</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">push</span><span class="params">(E e)</span>; <span class="comment">// 往栈顶添加一个元素  等同于 addFirst</span></span><br><span class="line">E <span class="title function_">pop</span><span class="params">()</span>; <span class="comment">// 弹出栈顶元素  ==  removeFirst</span></span><br><span class="line">E <span class="title function_">peek</span><span class="params">()</span>; <span class="comment">// 查看栈顶元素  == getFirst</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>就不用java提供的stack的类了,它是继承了vector这个类再做的操作,我们可以直接使用双向队列替代</p></blockquote><p>它的子实现类中 LinkedList底层用链表实现,ArrayDeque用数组实现</p><h3 id="子实现类"><a href="#子实现类" class="headerlink" title="子实现类"></a>子实现类</h3><p>在所有的子实现类中,一定有无参构造函数,和 只有一个参数,并且类型为collection的构造函数,其他的构造函数,要看具体的实现类的功能</p><p>下面举几个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ArrayList</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span>; <span class="comment">// 因为底层是数组,可以设置大小</span></span><br><span class="line"><span class="comment">// PriorityQueue</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">(<span class="type">int</span> initialCapacity,Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span>; <span class="comment">// 需要排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span>; <span class="comment">// 如果这个c属于排序类型的接口,那么会使用它的排序规则</span></span><br></pre></td></tr></table></figure><h2 id="Map结构"><a href="#Map结构" class="headerlink" title="Map结构"></a>Map结构</h2><p>map 是一种具有映射关系的数据结构,一个key对应一个value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>; <span class="comment">// 返回元素个数</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span>; <span class="comment">// 是否包含某个key</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span>; <span class="comment">// 是否包含某个值</span></span><br><span class="line">V <span class="title function_">get</span><span class="params">(Object key)</span>; <span class="comment">// 根据key 找到对应的value</span></span><br><span class="line">V <span class="title function_">put</span><span class="params">(K key, V value)</span>; <span class="comment">// 更改key的value,并且返回原先的value</span></span><br><span class="line">V <span class="title function_">remove</span><span class="params">(Object key)</span>; <span class="comment">// 删除某个key,并且返回它的value值</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span>; <span class="comment">// 将某个map的元素加入到当前容器中,相当于取出m的每个key,value 执行put操作</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>; <span class="comment">//清除所有的元素</span></span><br><span class="line">Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span>; <span class="comment">// 获得所有key的set集合</span></span><br><span class="line">Collection&lt;V&gt; <span class="title function_">values</span><span class="params">()</span>; <span class="comment">// 获得所有值的集合</span></span><br><span class="line"><span class="comment">// 为什么key 要用set来装,value用collection来装呢? 因为key必须唯一,value不需要</span></span><br><span class="line">Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet(); <span class="comment">// 获得实体对象集合</span></span><br><span class="line"><span class="keyword">default</span> v <span class="title function_">getOrDefault</span><span class="params">(Object key, V defaultValue)</span>; <span class="comment">// 如果key存在,则返回对应的value,否则返回给定的value</span></span><br><span class="line"><span class="keyword">default</span> V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span>; <span class="comment">//如果key值不存在才放入元素,否则不放入,返回key最终对应的value</span></span><br><span class="line"><span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object key, Object value)</span>; <span class="comment">//当k,v都等于给定值时,才移除</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/11/24/java/java%E6%A1%86%E6%9E%B6%E5%85%A8%E9%83%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2022/11/24/java/java%E6%A1%86%E6%9E%B6%E5%85%A8%E9%83%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h2><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络:"></a>计算机网络:</h2><p>​</p><pre><code>协议三要素:    语法:    语义:    同步:</code></pre><h2 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h2><h2 id="javase"><a href="#javase" class="headerlink" title="javase"></a>javase</h2><h2 id="javaweb"><a href="#javaweb" class="headerlink" title="javaweb"></a>javaweb</h2><pre><code>1.url-pattern几种形式2.同一个Tomcat下的不同应用之间seesion是共享的嘛?3.</code></pre><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><p>​数据源的作用:<br>​我们自己在使用jdbc连接数据库时,总是频繁的创建销毁连接,这样效率的非常低的,数据源帮我们管理这些连接,<br>​避免了频繁的创建与销毁连接(不过有的数据源也没有提供连接池的功能)</p><h2 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h2><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><h2 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h2><pre><code>bean的生命周期:    实例化,属性设置,初始化,销毁bean的作用域:    单例,原型,请求域,session,application什么是IOC    控制反转,实现对象之间的解耦    通过IOC容器,利用相互依赖关系注入的方式,实现对对象之间的解耦</code></pre><p>​</p><pre><code>什么是aop    aop是面向切面编程,实现程序功能统一维护的一种技术(动态代理(不修改源代码的情况下增强功能,进行解耦合,提高程序的可重用性))    作用:就是动态代理的作用    优势:减少代码重复,提高开发效率,便于维护    连接点:就是类中被增强的方法    切入点:包含哪些类的哪些方法要被增减    通知:增强方法执行前还是执行后要执行的方法    切面:切入点+通知     spring中使用aop:        导入aspectjweave坐标        xml格式:            声明aop自动代理            &lt;aop:aspectj-autoproxy&gt;        纯注解模式               后续学了再来总结        哪些地方使用了aop:        事务控制,日志,异常处理</code></pre><p>​<br>​</p><pre><code>aop的通知类型:    @Before    @AfterReturning    @Around    @AfterThrowing    @After    上面几个注解修饰的方法,必须是public的,参数都可以放一个JoinPoint类型的参数,    他可以用来获取连接的信息,比如名字啊,参数类型啊    其他类型的参数就可以按照这个名字的意思来看了切入点表达式可以有哪些:利用自定义注解+aop 实现日志打印的功能spring事务管理:    1.编程式:自己写开启事务,提交事务,回滚事务(不太好用)    2.声明式:不入侵业务代码    PlatformTranscationManager:事务管理器(定义了事务的一些行为)(不同的技术事务管理器可能不一样)    TranscationDefinition:事务的定义信息(事务的隔离级别,事务的传播行为,是否只读,超时时间)    Transcstatus:事务执行的状态(是否提交,是否回滚)spring的一些后置处理器及其作用:        1.BeanFactoryPostProcessor:         void postProcessBeanFactory(ConfigurableListableBeanFactory var1)        此时所有bean的定义信息已经被全部加载,但是还未实例化        用于bean实例化前执行的方法    2.BeanDefinitionRegistryPostProcessor:        postProcessBeanDefinitionRegistry(BeanDefinitionRegistry var1)        此时所有bean的定义信息将要被加载(里面有一部分了,也还有一部分没有加载进来,        因为这个接口里面的方法可以注册bean的定义信息),也还没实例化,看方法里面的参数就知道,我们还能自己注册bean    3.BeanPostProcessor:           里面定义了两个方法,分别用于bean的初始化前后执行        4.InstantiationAwareBeanPostProcessor extends BeanPostProcessor:(注意和BeanPostProcessor的区别)         postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName)        里面定义了两个方法,分别用于bean的实例化前后执行,可以用于代理bean,        因为容器是根据这里面的返回值确定容器里面放的bean是什么,看参数便知道,此时的bean尚未被创建        我们可以自己创建然后对其进行代理,aop就是这么做的        上面四个接口的执行顺序:        2-&gt;1-&gt;4-&gt;3</code></pre><p>​<br>​<br>​spring 源码总结(以注解驱动为列子):<br>​创建AnnotationConfigApplicationContext容器<br>​this();<br>​实例化IOC容器<br>​往里面添加一些后置处理器的bean定义信息<br>​this.register(componentClasses);<br>​注册当前配置类<br>​this.refresh()<br>​<br>​invokeBeanFactoryPostProcessors<br>​invokeBeanDefinitionRegistryPostProcessors<br>​先执行系统放进去的ConfigurationClassPostProcessor接口里面的方法,它会把所有的bean的定义信息加载到容器中<br>​(此步骤主要是找到所有扫描到的bean,import,component这些注解的东西,并将这些bean的定义信息加载进来),<br>​然后再根据优先级执行已经加载的bean里面的实现了BeanDefinitionRegistryPostProcessor的里面的方法,<br>​并将这些bean给加载到容器中<br>​<br>                    invokeBeanFactoryPostProcessors<br>                        执行所有已经注册bean的postProcessBeanFactory方法<br>                至此所有bean的定义信息已经被加载</p><pre><code>            registerBeanPostProcessors();注册所有的BeanPostProcessor对应的bean                从bean工厂里面拿到所有的BeanPostProcessor类型的bean定义信息,                然后按照优先级的顺序依次将这些bean注册到容器中            initMessageSource()初始化国际化信息            initApplicationEventMulticaster();初始化事件派发器,其实就是看哪个事件监听器能够处理当前的事件            registerListeners();注册所有事件监听器            finishBeanFactoryInitialization();注册完毕所有的单实例bean                如果当前bean是工厂bean,则注册工厂bean生成的那个对象,                然后将生成其他没有实例化和初始化的bean</code></pre><h2 id="mybatis"><a href="#mybatis" class="headerlink" title="mybatis"></a>mybatis</h2><p>开发流程(简单maven工程中):<br>    1.导入坐标mybatis的jar包,数据库的驱动,数据源 如果是spring中还要导入spring-mybatis的jar包<br>    2.编写实体类以及操作数据库接口<br>    3.编写数据库接口对应的sql语句(mapper代理)<br>    4.编写mybatis配置文件(设置别名啊,设置属性,配置环境(数据源,事务管理器),mapper映射文件的位置)</p><p>可以使用typeAliases 对类型起别名,在sql子标签resulttype属性中就可以使用,但是我感觉没有啥用</p><p>#{} 与 ${} 的区别在于 前者会设置参数防止SQL注入,后者是直接拼接</p><p>如果数据库的表名与实体类的属性名不同可以使用下面两种方法:<br>    1.给数据库中取出的字段取别名<br>    2.使用resultmap给出一组对应关系(主键字段需要用<id>标签取别名)</p><p>xml中默认不允许使用&lt;字符,如果需要使用,需要转义或者使用cd命名空间</p><p>传递参数的三种方式:<br>    多参数<br>        1.<br>            直接通过函数参数 当有多个参数的时候需要使用(@param(“”)注解,<br>            如果还是使用原来的那个参数名字会报错(因为有多个参数的时候,mybatis会把参数封装成一个map,然后键名就是arg0,arg1这些,建议全部使用@param注解)<br>    单参数:<br>        2.<br>            对象形式<br>        3.<br>            map形式</p><p>​在配置文件中只需要使用 #{参数名|属性名|key值} 就可以拿到参数值</p><p>​<br>​<br>​动态sql<br>​当用户输入的参数个数不确定时,我们也可以只写一个sql语句让mybatis帮忙生成对应的sql语句<br>​1. 动态查询<br>​<br>​<where> <if test=""> <where> 形式 test里面需要像sql</p><p>​<br>​当查询时出现一个实体类里面还出现了另外一些实体类时(一对一,一对多)<br>​1.自定义resultmap 将对应的列封装到属性中,如果是属性是对象,resultmap中的属性名就写对象变量名字.属性名<br>​(上面这种方法的缺点是需要重复太多的对象的变量名字)<br>​<br>​2.<br>​对象:<br>​&lt;association property&#x3D;”” javatype&#x3D;””(如果没有取别名,这里得写成包名路径+类名)&gt;<br>​这样就不用写很多次对象变量名字(里面就跟平常写resultmap一样了)<br>​集合:<br>​<collection></p><h2 id="springMVC"><a href="#springMVC" class="headerlink" title="springMVC"></a>springMVC</h2><p>​这个部分其实就是简化以前的javaweb 开发,对以前的代码进行了解耦合,以及提供了很强大的功能<br>​<br>​以前传统的javaweb太过于繁琐,需要自己继承servlet并且重写doGet,doPost方法,然后再在web.xml里面声明哪些servlet处理哪些请求<br>​其实这些都是可以简化的,springMVC就帮我们做到了这些,它接收指定路径下的所有请求,将这些请求进行解析,<br>​通过handlermapping对应的handler(其实就是找到哪个方法处理哪个请求),然后找到能够处理这个handler的适配器<br>​(适配器就能够通过参数解析器(argumentsResolver)解析请求参数或者请求体,提供handler需要的参数,并执行它),<br>​以及视图解析器,然后将数据返回给前端在这个过程中<br>​</p><p>我们希望做到的就是,前端传来的数据,我们不去自己进行接收和类型转化,只声明一下函数参数的类型就行,springMVC通过反射拿到函数参数类型<br>找到适合的类型转化器,将这些前端传来的数据变成对应的类型再传进函数供我们使用,再将返回值进行处理</p><p>使用文件上传功能时,需要导入依赖,然后配置文件视图解析器,前端必须以post方式请求,以及使用multipart&#x2F;form-data形式传递参数</p><p>请求所用注解<br>    @RequestParam<br>        如果是get请求,那么使用此注解,只会解析路径上携带的参数,如果是post请求那么将路径上的参数和请求体里面的参数<br>        (如果路径上的参数名字与请求体里面参数名字相同,则会合并)<br>    @PathVariable 接收restful风格的路径参数</p><p>​@RequestBody<br>​将请求体里面的所有数据全部拿来放到对应的参数里面,如果需要将里面的数据转换成java对象<br>​(这种就只适合application&#x2F;json格式的数据),需要开启webmvc注解驱动,并且导入json的包<br>​@RequetPart<br>​接收multipart&#x2F;form-data 类型数据</p><p>响应注解<br>    @ResponseBody<br>        将返回值直接当成返回的内容给用户,如果想直接将返回值变成json格式,只需要开启webmvc注解驱动,然后加入json包</p><p>如果参数前面没有加任何注解,springMVC是将这个对象创建出来,然后用这个对象的set方法尝试将参数注入进去,<br>所以如果这个参数类型是接口那不行,如果属性没有set方法也不行</p><p>静态资源问题:由于springMVC代替了默认的servlet处理器,请求资源的时候也被springMVC处理了,但是,它里面没有这些请求,<br>所以得做一个资源映射,告诉springmvc这些资源路径对应的资源在哪</p><p>filter 与 拦截器<br>    filter 是 servlet的一部分任何Javaweb的工程都能够使用(只能设置过滤路径,如果要在这些过滤路径中排出一些不要过滤的,需要在代码中实现)<br>    拦截器属于springmvc的,只有在springmvc中才能使用(能设置拦截路径,也能设置不拦截路径)<br>    filter适合对所有请求做相同的事情,比如设置编码啊,往里面请求中添加东西啊<br>    拦截器就适合拦截,对哪些请求放行,哪些请求不放行</p><p>​<br>​<br>​异常处理器:<br>​将所有的异常进行统一的处理<br>​<br>​@RestControllerAdvice声明这个类时异常处理类<br>​ @ExceptionHandler(Exception.class) 说明这个方法处理哪个异常<br>​</p><p>​这个就厉害了(它能够controller层拦截所有异常(404除外,因为它还没有进入controller层),请求参数不匹配啊…..)</p><p>​<br>​使用WebMvcConfigurationSupport+注解能够全面替代web.xml,原先在web.xml要配置的东西,都可以在这个配置类中写</p><p>​</p><h2 id="springboot"><a href="#springboot" class="headerlink" title="springboot"></a>springboot</h2><p>如果一个组件只有一个有参构造器,那么他的所有构造器参数都会从容器中去取</p><p>@Import注解一般是用来导入一个配置类,这个类必须具备无参构造器否则会报错<br>@ImportResouce 是导入spring的xml格式的配置文件</p><p>​springboot启动的时候会加载每个jar包下META-INF&#x2F;spring.factories里面写好的自动配置类,一般是xxxxxAutoConfiguration<br>​这些自动配置类会往容器里面注入很多的bean<br>​<br>​自己定制化的两种方式:<br>​1.自己注册bean替换底层组件<br>​</p><p>​2.修改配置文件即可(一般能变的属性,springboot都是通过配置文件与属性配置类进行绑定,修改配置文件里面的值就能修改属性值)</p><p>​<br>​springboot默认不支持jsp</p><p>springMVC 执行流程<br>    由于dispatcherservlet接管了&#x2F;请求,所以在springmvc中所有的请求都由dispatcherservlet来处理,请求处理映射器会把所有controller层的<br>    标注了requestmapping注解的方法全部记录起来,大体格式就是哪个请求对应哪个方法.<br>    当有请求来时,从请求处理映射器里面找到对应的handler(处理这个请求的方法),由于不同方式注册的请求对应的handler处理的方式不一样,<br>    需要再找到处理器适配器(springmvc里面有四个<br>        1.RequestMappingHandlerAdapter(根据requestmapping注解来找)<br>        2.HttpRequestHandlerAdapter<br>        3.HandlerFunctionAdapter<br>        4.SimpleControllerHandlerAdapter(根据url配置来找对应的controller,这个controller必须实现controller接口)<br>    )<br>    找到对应的适配后,就会执行处理此handler,首先会根据handler对应方法参数信息,找到对应的参数解析器,<br>    参数解析利用convert将请求参数或者请求体中的数据解析成形参对应的类型,然后就会通过反射执行方法,得到返回值,<br>    然后再根据返回值及handler的信息找到合适的返回值handler处理器然后进行内容协商,通过消息转化器将返回值解析成适合客户端的类型,<br>    最后将数据放入modelandview中,最后渲染页面或者直接返回数据给客户端</p><p>在dispatcherservlet中,任何handler执行完毕返回的 都是modelandview对象,里面包含数据,以及视图地址</p><p>springboot中好用的功能:<br>    shiro,jwt,async,socketio,,schedule,mybatis,mybatis-plus,</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/11/24/android/android%E7%AC%94%E8%AE%B0(%E8%8D%89%E7%A8%BF)/"/>
      <url>/2022/11/24/android/android%E7%AC%94%E8%AE%B0(%E8%8D%89%E7%A8%BF)/</url>
      
        <content type="html"><![CDATA[<h2 id="Andorid"><a href="#Andorid" class="headerlink" title="Andorid"></a>Andorid</h2><h3 id="UI组件"><a href="#UI组件" class="headerlink" title="UI组件"></a>UI组件</h3><p>所有的ui界面都是由view和viewgroup及其派生类组合而成,viewgroup也是view的派生类 </p><p>viewgroup 是组件容器,用来容纳view及其派生类</p><h4 id="view-与-viewgroup的区别"><a href="#view-与-viewgroup的区别" class="headerlink" title="view 与  viewgroup的区别"></a>view 与  viewgroup的区别</h4><h5 id="事件分发方面"><a href="#事件分发方面" class="headerlink" title="事件分发方面"></a>事件分发方面</h5><h5 id="UI绘制方面"><a href="#UI绘制方面" class="headerlink" title="UI绘制方面"></a>UI绘制方面</h5><h4 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h4><h5 id="LinearLayout"><a href="#LinearLayout" class="headerlink" title="LinearLayout"></a>LinearLayout</h5><p>常用属性</p><ol><li>layout_width<ul><li></li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/11/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/11/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="一-创建型模式"><a href="#一-创建型模式" class="headerlink" title="一 创建型模式"></a>一 创建型模式</h3><p>创建对象时隐藏创建逻辑,而不是直接使用new的方式创建对象,可以根据程序判定创建什么样的对象,这样会很灵活</p><h4 id="1-工厂模式"><a href="#1-工厂模式" class="headerlink" title="1.工厂模式"></a>1.工厂模式</h4><p>在工厂模式中,不对外暴露对象创建的过程,用户需要什么跟工厂要就行.</p><p>优点:</p><ul><li>不需要知道产品内部实现细节,只需要知道产品对应的接口能干嘛就行</li><li>扩展性高,增加一类产品只需要多写一个工厂类就行</li></ul><p>缺点:</p><ul><li>每次创建一类产品,都需要增加一个工厂类,而多增加一个产品,需要更改工厂类的代码</li></ul><p>举例说明:</p><p>​我们买车只需要直接告诉造车工厂我们需要什么车就行,不需要知道车怎么造出来的,如果我们需要买飞机,我们就需要告诉造飞机的工厂,</p><p>​车:接口</p><p>​奥迪:具体实现类</p><p>​造车工厂:工厂类</p><p>​我们知道车可以干嘛,然后我们可以根据喜欢向工厂要什么样的车.</p><p>​每多一个接口,就需要多 一个工厂类,每多一个具体实现类,工厂类里面就需要多些一段代码.</p><p>何时使用:  明确知道不同条件下需要创建什么对象,如果创建对象本来就很简单,我们还是直接new比较好</p><h4 id="2-抽象工厂模式-———"><a href="#2-抽象工厂模式-———" class="headerlink" title="2.抽象工厂模式(———)"></a>2.抽象工厂模式(———)</h4><p>抽象工厂是工厂的工厂,它可以创建工厂类对象,创建的工厂又可以提供创建用户需要对象的功能</p><p>优点:</p><ul><li>保证用户使用的都是一类产品</li></ul><p>缺点:</p><ul><li>扩展新的工厂比较麻烦,需要为抽象工厂添加新方法,每个具体工厂也得实现这个方法(虽然不干嘛)</li></ul><p>抽象工厂模式其实也是工厂模式,只不过抽象工厂创建的是工厂,工厂创建的是产品</p><h4 id="3-单例模式"><a href="#3-单例模式" class="headerlink" title="3.单例模式"></a>3.单例模式</h4><p>私有化构造器,保证全局只有一个对象</p><p>创建单例的几种方法:</p><ol><li>懒汉式</li><li>饿汉式</li><li>双重校验锁(其实也是懒汉式)</li><li>枚举</li><li>静态内部类(里面编写一个静态内部类,添加一个属性赋值为单例对象)</li></ol><h4 id="4-建造者模式"><a href="#4-建造者模式" class="headerlink" title="4.建造者模式"></a>4.建造者模式</h4><p>通过一步一步构建,创造出对象,与工厂模式的区别:更加关注装配的顺序</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/11/24/nginx/nginx/"/>
      <url>/2022/11/24/nginx/nginx/</url>
      
        <content type="html"><![CDATA[<h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><h3 id="如何设置反向代理"><a href="#如何设置反向代理" class="headerlink" title="如何设置反向代理"></a>如何设置反向代理</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/11/24/nginx/nginx-temp/"/>
      <url>/2022/11/24/nginx/nginx-temp/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo部署到远程服务器</title>
      <link href="/2022/11/24/hexo%E6%90%AD%E5%BB%BA/hexo%E9%83%A8%E7%BD%B2%E5%88%B0%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2022/11/24/hexo%E6%90%AD%E5%BB%BA/hexo%E9%83%A8%E7%BD%B2%E5%88%B0%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo-git-docker-x2F-nginx"><a href="#hexo-git-docker-x2F-nginx" class="headerlink" title="hexo+git+docker&#x2F;nginx"></a>hexo+git+docker&#x2F;nginx</h1><p>怎么安装,这些就自行百度,或者关注我之后的博客</p><h1 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h1><h2 id="创建一个用户"><a href="#创建一个用户" class="headerlink" title="创建一个用户"></a>创建一个用户</h2><p>由于需要使用到ssh免密操作,所有不好直接把公钥放到root用户下,新建一个用户来管理(当然,你也可以用root用户)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">useradd git</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将本地创建好的公钥放到/home/git/.ssh/authorized_keys 里面,这样就能免密登录了</span></span><br><span class="line">mkdir /home/git/.ssh</span><br><span class="line">vim  /home/git/.ssh/authorized_keys  #输入你的秘钥</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置不能通过git用户登录服务器,但是可以使用git操作仓库</span></span><br><span class="line">vim /etc/passwd</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">git:x:1002:1002::/home/git:/usr/bin/git-shell  只需要将/bin/bash 改成 /usr/bin/git-shell 这个就好了 ,需要改成自己git-shell的路径哦,每个人的git环境路径可能是不一样的</span></span><br></pre></td></tr></table></figure><h2 id="搭建git服务器"><a href="#搭建git服务器" class="headerlink" title="搭建git服务器"></a>搭建git服务器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在服务器上搭建一个裸仓库,用来当git服务器,目录自己选</span></span><br><span class="line">git init --bare /opt/git/repository </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将目录所有者给git</span></span><br><span class="line">chown -R git:git /opt/git </span><br></pre></td></tr></table></figure><h2 id="编写post-update钩子"><a href="#编写post-update钩子" class="headerlink" title="编写post-update钩子"></a>编写post-update钩子</h2><p>方便我们推送文章后,自动让另一个服务器本地仓库更新页面</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将钩子变的可用</span></span><br><span class="line">mv /opt/git/repository/hooks/post-update.sample /opt/git/repository/hooks/post-update</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">清空钩子内容</span></span><br><span class="line">echo &quot;&quot; &gt; /opt/git/repository/hooks/post-update</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编写git服务器的post-update钩子</span></span><br><span class="line">vim /opt/git/repository/hooks/post-update</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">################将下面的脚本全部复制进去######################</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务器给web服务器访问的博客目录</span></span><br><span class="line">blogpath=/opt/git/blog</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">git服务器地址</span></span><br><span class="line">repositorypath=/opt/git/repository</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果博客还不存在,则先<span class="built_in">clone</span>,如果存在直接拉取</span></span><br><span class="line">if [ ! -d $blogpath ]; </span><br><span class="line">then</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">克隆好服务器本地仓库</span></span><br><span class="line">  git clone $repositorypath $blogpath</span><br><span class="line">else</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">让本地仓库拉取本地远程仓库</span></span><br><span class="line">  git --work-tree=$blogpath --git-dir=$blogpath/.git pull -f</span><br><span class="line">fi</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="设置web服务器"><a href="#设置web服务器" class="headerlink" title="设置web服务器"></a>设置web服务器</h2><h3 id="方式一-nginx"><a href="#方式一-nginx" class="headerlink" title="方式一  nginx"></a>方式一  nginx</h3><p>现在我们已经有了所有的静态资源在&#x2F;opt&#x2F;git&#x2F;blog&#x2F;public目录下,我们只需要把这个目录交给web服务器就行,设置nginx的根目录为这个目录就行了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/nginx.conf  # 每个人的环境变量不一样哦,注意自己安装在哪</span><br><span class="line"></span><br><span class="line">listen       80;</span><br><span class="line">listen       [::]:80;</span><br><span class="line">server_name  _;</span><br><span class="line">root        /opt/git/blog/public;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">改成这样就OK啦</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="方式二-docker"><a href="#方式二-docker" class="headerlink" title="方式二 docker"></a>方式二 docker</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name hexonginx -v /opt/git/blog/public:/usr/share/nginx/html -p 80:80 nginx</span><br></pre></td></tr></table></figure><p>这个是不是巨方便啊,哈哈哈哈</p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="创建本地博客仓库"><a href="#创建本地博客仓库" class="headerlink" title="创建本地博客仓库"></a>创建本地博客仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自己选好路径</span></span><br><span class="line">git init </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加远程仓库,上面写好的,这里的ip需要写成服务器ip地址哦</span></span><br><span class="line">git remote add origin git@ip:/opt/git/repository </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加Gitee 仓库地址 主要也是做个备份,安全起见,万一哪天服务器不小心<span class="built_in">rm</span> -rf / 了,那我不得哭死啊</span></span><br><span class="line">git remote add gitee git仓库地址</span><br></pre></td></tr></table></figure><p>编写好.gitignore文件 我们只需要配置文件,以及source,public,其他的基本都不需要,下面是gitignore文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">.deploy*/</span><br><span class="line">_multiconfig.yml</span><br><span class="line">themes</span><br><span class="line">node_modules</span><br></pre></td></tr></table></figure><h3 id="编写好钩子"><a href="#编写好钩子" class="headerlink" title="编写好钩子"></a>编写好钩子</h3><p>在.git&#x2F;hook下面</p><p>编写一个pre-commit 文件,不要带任何后缀</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自动生成html文件</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">自动暂存(主要是为了将那些新创建的文件给添加到暂存区,不然commit -a 也没用)</span></span><br><span class="line">git add .</span><br><span class="line">echo &quot;添加到暂存区完成&quot;</span><br></pre></td></tr></table></figure><p>编写一个post-commit 文件,不要带任何后缀</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">echo &quot;开始推送&quot;</span><br><span class="line">git push gitee master</span><br><span class="line">echo &quot;推送到gittee成功&quot;</span><br><span class="line">git push origin master</span><br><span class="line">echo &quot;推送到自己服务器成功&quot;</span><br></pre></td></tr></table></figure><h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">当我们在<span class="built_in">source</span>/_post目录下写好文章之后</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">直接commit</span></span><br><span class="line">git commit -am &quot;终于完成了&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础</title>
      <link href="/2022/11/24/linux/linux/"/>
      <url>/2022/11/24/linux/linux/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>以下总结全部基于CentOS Linux release 7.6.1810 (Core) 总结出来的命令,不同版本对应的命令可能不同</p><blockquote><p>小技巧: 当我们不会某个命令时,我们可以使用 命令 –help 来查看它的参数及使用</p></blockquote><h3 id="系统目录结构"><a href="#系统目录结构" class="headerlink" title="系统目录结构"></a>系统目录结构</h3><h4 id="必须存在的目录"><a href="#必须存在的目录" class="headerlink" title="必须存在的目录"></a>必须存在的目录</h4><ul><li>&#x2F;bin 里面存放着一些经常使用的命令</li><li>&#x2F;boot 存放着linux启动时的核心文件</li><li>&#x2F;dev 里面存放着linux外部设备文件</li><li>&#x2F;etc 里面存放系统管理需要的配置文件</li><li>&#x2F;lib 存放着基本的动态链接共享库 </li><li>&#x2F;media 放置可移除的设备,U盘 DVD这些</li><li>&#x2F;mnt 临时挂在其他设备,与media差不多</li><li>&#x2F;opt 给额外软件所摆放的目录</li><li>&#x2F;run 用来放置系统启动的时候产生的信息 &#x2F;var&#x2F;run 软连接了这个目录</li><li>&#x2F;sbin 超级管理员使用的系统管理工具</li><li>&#x2F;srv 用于放某些服务器所需要的数据 </li><li>&#x2F;temp 临时文件 系统会开机自动删除</li><li>&#x2F;usr (unix software resource) 很多用户的应用程序和文件都放在这个文件下面(可分享,不变动),和windows的C:\Program Files 类似</li><li>&#x2F;usr&#x2F;bin  &#x2F;bin就是软连接了这个目录,所以与&#x2F;bin的作用一样</li><li>&#x2F;usr&#x2F;sbin &#x2F;sbin 也是软连接了这个目录</li><li>&#x2F;usr&#x2F;lib &#x2F;lib 就是软连接了这个目录</li><li>&#x2F;usr&#x2F;local 放置我们安装软件的地方</li><li>&#x2F;usr&#x2F;share 放置共享只读的数据</li><li>&#x2F;var(variable) 里面放着不断扩充的东西,比如一些日志信息,mysql的数据文件</li></ul><h4 id="建议存在的目录"><a href="#建议存在的目录" class="headerlink" title="建议存在的目录"></a>建议存在的目录</h4><ul><li><p>&#x2F;proc 是系统内存的映射文件,它是虚拟文件,在内存中,并不在硬盘中,里面包含了很多进程的信息</p></li><li><p>&#x2F;home 用户家目录</p></li><li><p>&#x2F;lost + found 非法关机存放的文件</p></li><li><p>&#x2F;root 超级用户的家目录</p></li><li><p>&#x2F;sys 也是虚拟目录,记录核心与系统硬件的信息</p></li><li><p>&#x2F;usr (unix software resource) 很多用户的应用程序和文件都放在这个文件下面</p></li></ul><h3 id="文件与目录管理"><a href="#文件与目录管理" class="headerlink" title="文件与目录管理"></a>文件与目录管理</h3><h4 id="文件基本属性"><a href="#文件基本属性" class="headerlink" title="文件基本属性"></a>文件基本属性</h4><p>d rwx r-x r-x 3 root root 4096 Nov  6 21:14</p><p>文件类型 文件拥有者的权限 文件组用户权限 其他人的权限 硬链接计数 文件拥有者 文件所属组 大小 最后修改时间</p><p>这些文件拥有者,所属组,其他人其实都只是为了把权限分配的清楚点</p><h5 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h5><ul><li>d 目录(direction)</li><li>L(l) 软连接(ln)</li><li>c 字符块设备(char)</li><li>b 块设备(block)</li><li>p 管道文件(pipe)</li><li>s 本地套接字文件(socket)</li><li>- 普通文件(使用find命令的时候,f代表普通文件)</li></ul><h4 id="文件-x2F-目录属性操作"><a href="#文件-x2F-目录属性操作" class="headerlink" title="文件&#x2F;目录属性操作"></a>文件&#x2F;目录属性操作</h4><p>文件&#x2F;目录权限: rwx  读写执行</p><h5 id="默认权限"><a href="#默认权限" class="headerlink" title="默认权限"></a>默认权限</h5><p>文件默认权限  -rw-rw-rw- 就所有人都只有读写权限</p><p>目录默认权限 -rwxrwxrwx 所有人都有读写执行权限  (至于目录为什么要有执行权限,请看额外补充<a href="#t1">目录权限与文件权限的区别</a>)</p><p>有人就会说了,我明明创建一个目录,不是所有人都有这个权限啊,比如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir testdir</span><br><span class="line">ll -ld ./testdir</span><br><span class="line"></span><br><span class="line">drwxr-xr-x. 2 root root 6 11月 27 15:22 testdir</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>你看输出的权限,明明跟你说的不是一回事.</p><p>别急,后面还有个umask呢</p><h5 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h5><p>这个东西就是在默认权限上,需要减掉的权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输入这个命令看输出什么</span></span><br><span class="line">[root@localhost ~]# umask</span><br><span class="line">0022</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出0022</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">第一个数字是特殊权限,暂时不管 第二个数字代表拥有者要减去的权限</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">第三个数字代表所有组要减去的权限,第四个数字代表其他人要减去的权限</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个数字是可以自己更改的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">umask 002 </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">比如我们默认创建文件的时候,不想其他人读,我们就可以设置成这样</span></span><br></pre></td></tr></table></figure><h5 id="chattr"><a href="#chattr" class="headerlink" title="chattr"></a>chattr</h5><p>这个是设置隐藏属性的(不是隐藏文件啊),这些隐藏属性还是很厉害的,比如设置有些属性后,文件只能增加内容,不能修改和删除,就连root也不行,必须先解除属性,才能删除</p><ul><li>-   取消某一个属性   + 增加某一个属性 &#x3D; 设置全部属性</li><li>-a 只能增加内容,不能修改和删除</li><li>-i 不能被删除、改名、设置链接也无法写入或新增数据！</li></ul><h5 id="lsattr"><a href="#lsattr" class="headerlink" title="lsattr"></a>lsattr</h5><p>查看隐藏属性(不是查看隐藏文件哦)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lsattr -d test4</span><br><span class="line">-----a---------- test4</span><br></pre></td></tr></table></figure><p>你会看到这个与ls输出还是有区别的</p><h5 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h5><p>更改文件所有者命令:    chown [-R] 所有者:所属组</p><h5 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h5><p>常用参数:</p><ul><li>a 对所有人操作</li><li>u 对所有者操作</li><li>g 所属对用户组操作</li><li>o 对其他人操作</li></ul><p>更改文件权限: </p><ul><li>chmod [-R] 777 用数字代表修饰的权限 1执行 2 写 4读取</li><li>chmod [-R] a+x-w 用符号去更改权限</li><li>chmod 7777 还有一种下面这个特殊权限的写法 第一个代表特殊权限   后三个就是跟上面的一样</li></ul><h5 id="特殊权限SUID-SGID-SBIT"><a href="#特殊权限SUID-SGID-SBIT" class="headerlink" title="特殊权限SUID ,SGID,SBIT"></a>特殊权限SUID ,SGID,SBIT</h5><h6 id="SUID-set-uid"><a href="#SUID-set-uid" class="headerlink" title="SUID(set uid)"></a>SUID(set uid)</h6><p>在具有执行权限的应用程序上(而不是shell脚本哈),对拥有者新增s权限,</p><p>这个权限的作用是,在可执行的文件的基础上,让<strong>执行者</strong>暂时具有<strong>拥有者的权限</strong>,什么意思呢? 我举个栗子,比如&#x2F;etc&#x2F;shadow普通用户用cat是无法查看里面的内容的,但是我们用chmod <strong>u+s</strong>  &#x2F;usr&#x2F;bin&#x2F;cat之后, 普通用户再执行cat &#x2F;etc&#x2F;shadow是能够看到里面内容了,还有就是passwd命令,它修改了&#x2F;etc&#x2F;shadow里面的东西,普通用户是不是也能通过这个命令修改密码?但是我们不能够手动的去修改&#x2F;etc&#x2F;passwd吧!!,所以这些特殊权限的出现都是为了解决问题的,感觉这个特殊权限的出现就是为了解决,<strong>让普通用户只有用指定命令,才能查看或者修改文件或者目录里面的东西</strong>,<strong>重点还是修改,一般连看都不会让看</strong></p><p>这里我们自己做一个演示</p><p>这里有root 和 djm 两个用户 操作目录在&#x2F;root&#x2F;test4中</p><p>首先root用户编写一段c++代码命名为test.cpp查看&#x2F;etc&#x2F;shdow里面的东西(这个文件的权限是000)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;/etc/shadow&quot;</span>)</span></span>;</span><br><span class="line">        <span class="type">char</span> buff[<span class="number">80</span>];</span><br><span class="line">        in&gt;&gt;buff;</span><br><span class="line">        cout&lt;&lt;buff&lt;&lt;endl;</span><br><span class="line">        in.<span class="built_in">close</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test4] g++ -o test test.cpp  #编译</span><br><span class="line">[root@localhost test4] ./test  #运行</span><br><span class="line">root:$1$6TJ77l9F$sizoIqVNB4hGQWtYlu5.S.::0:99999:7:::  # 我们看到是能够出现东西的</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>切换到djm这个用户去执行这个脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[djm@localhost test4]$ ./test</span><br><span class="line"></span><br><span class="line">[djm@localhost test4]$</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">我们发现什么都没有输出,因为里面肯定出错了,没有权限去读这个文件</span></span><br></pre></td></tr></table></figure><p>我们将这个应用程序拥有者加上s权限,再让djm去执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test4] chmod u+s test</span><br><span class="line">[root@localhost test4] su djm</span><br><span class="line">[djm@localhost test4] ./test</span><br><span class="line">root:$1$6TJ77l9F$sizoIqVNB4hGQWtYlu5.S.::0:99999:7:::</span><br><span class="line">[djm@localhost test4]  #发现能够顺利的读出来了 </span><br></pre></td></tr></table></figure><h6 id="SGID"><a href="#SGID" class="headerlink" title="SGID"></a>SGID</h6><ul><li>在所属组具有执行权限的应用程序上(而不是shell脚本哈),对所属组新增s权限,这样的话执行者暂时拥有了用户组的权限</li><li>在所属组具有执行权限的目录上,对所属组新增s权限,执行者就能够拥有目录的所属组的权限了,而且这个执行者创建的东西,所属组会变成跟目录所属组一样(默认创建文件的所属组是用户的当前组哦)</li></ul><h6 id="SBIT"><a href="#SBIT" class="headerlink" title="SBIT"></a>SBIT</h6><p>在具有<strong>执行权限的目录</strong>上,对其他人新增t权限,在这个目录下,除了root和我自己,别人都不能删掉我的文件(包括跟我一个组的人),纵使他在这个目录下有写权限</p><h5 id="file"><a href="#file" class="headerlink" title="file"></a>file</h5><p>查看文件的类型,这个函数还是挺有用的,可以准确的判断出文件里面的东西,以及文件的特殊权限,还有打包方式这些啊</p><h4 id="文件和目录的操作"><a href="#文件和目录的操作" class="headerlink" title="文件和目录的操作"></a>文件和目录的操作</h4><h5 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h5><p>移动文件 mv 源地址 目标地址</p><h5 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h5><p>统一用 rm -rf 目标地址 (强烈不推荐使用这个命令 要删除文件时候,直接使用mv 移动到回收站 到时候定期删除回收站就行)</p><h5 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h5><p>复制文件  统一用 cp -r  源文件或者目录 目标文件或者目录   </p><ul><li>-p 连同属性一起复制过去(不使用这个参数,使用cp命令的时候,可能改变文件的属性)</li><li>-d 如果是链接文件,则复制链接文件属性,而不是链接文件指向的那个文件(如果不加这个参数,复制的是链接文件所链接的那个文件)</li><li>-r 复制目录</li><li>-u 如果目的地址文件存在且比源地址文件时间旧或者目的地址文件不存在才进行复制</li></ul><h5 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h5><p>硬链接计数或者创建软链接 </p><p>创建硬链接 ln 源文件(<strong>这里必须使用绝对路径</strong>) 目标文件</p><p>创建软连接 ln -s 源文件 目标文件</p><p>软连接与硬链接的区别: 软链接相当于快捷方式 当别人使用它时,先找到目标地址再使用,硬链接相当于指向同一个物理块</p><h5 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h5><p>创建目录 统一用 mkdir -p 目录</p><h4 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h4><h5 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h5><p>查看指定文件或者目录信息,ls 可以用来查看文件大小,但是并不能用来查看目录总共大小,它查看的只是这个目录的大小</p><p>常用参数:</p><ul><li>-a 显示所有文件</li><li>-l 显示文件信息</li><li>-h 显示文件大小(带单位)</li><li>-F 显示目录后缀</li></ul><h5 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h5><p>可以查看文件内容,建议查看小文件内容(毕竟终端缓存有限) 也可以写入内容 cat &gt; file </p><h5 id="tac"><a href="#tac" class="headerlink" title="tac"></a>tac</h5><p>倒着查看文件内容 和 cat正好反着来</p><h5 id="nl"><a href="#nl" class="headerlink" title="nl"></a>nl</h5><p>打印文件带有行号</p><h5 id="more"><a href="#more" class="headerlink" title="more"></a>more</h5><p>可以翻页查看</p><h5 id="head"><a href="#head" class="headerlink" title="head"></a>head</h5><p>默认查看前十行,可以指定行数 head -行数</p><h5 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h5><p>跟head差不多 不过是看后面</p><h5 id="basename"><a href="#basename" class="headerlink" title="basename"></a>basename</h5><p>查看最后一个&#x2F;对应的文件或者目录名字</p><h5 id="dirname"><a href="#dirname" class="headerlink" title="dirname"></a>dirname</h5><p>查看倒数第二个&#x2F;对应的目录名字(如果没有则用&#x2F;表示)</p><h3 id="用户信息与管理"><a href="#用户信息与管理" class="headerlink" title="用户信息与管理"></a>用户信息与管理</h3><h4 id="UID"><a href="#UID" class="headerlink" title="UID"></a>UID</h4><ul><li>UID&#x3D;0 这个代表是系统管理员,我们可以在创建用户的时候指定它的UID让他也成为系统管理员,拥有root权限</li><li>UID &#x3D; 1-999 系统账号 1-200 系统自己创建 201-999 用户可以创建</li><li>UID &#x3D; 1000+  这个是给用户自己用的</li></ul><h4 id="su"><a href="#su" class="headerlink" title="su"></a>su</h4><p>切换用户</p><ul><li>su username  切换到另一个用户</li><li>su -l username 连带环境变量这些过去</li></ul><h4 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h4><p>这是个动词,然后后面的用户做</p><ul><li>sudo 命令 默认是root用户执行</li><li>sudo -u user  命令 让 user用户执行</li></ul><h4 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h4><p>添加一个用户(<strong>如果没有让设置密码,可以通过passwd 用户名 设置密码</strong>),这个命令必须是具有sudo权限的用户才可以使用</p><h4 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h4><p>删除一个用户 sudo userdel <strong>-r</strong> username 这里如果不使用-r 的话,不会删除用户的家目录,这个命令要慎用哦,它会把&#x2F;etc&#x2F;passwd,&#x2F;etc&#x2F;shadow,这些记录了它的数据都删掉哦,这样的话,这个用户就彻底不能用啦,如果我们只是不想让这个用户使用了,我们可以设置用户密码失效,或者过期</p><h4 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h4><p>修改用户信息,其实是为了修改当时useradd里面设置或者默认的参数值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">user -c </span><br><span class="line">usermod -a -G 用户组 用户名  #将用户添加到某个组</span><br><span class="line">usermod -g 用户组 用户名 #将用户改成某个组</span><br><span class="line">usermod -l 新用户名字 旧用户名</span><br><span class="line">usermod -s 修改登录shell</span><br><span class="line"></span><br><span class="line">usermod --help 更多的请看这个</span><br></pre></td></tr></table></figure><h4 id="groups"><a href="#groups" class="headerlink" title="groups"></a>groups</h4><p>查看当前用户属于哪些组</p><h4 id="newgrp"><a href="#newgrp" class="headerlink" title="newgrp"></a>newgrp</h4><p>一个用户可能属于多个用户组,当用户创建文件的时候,那这个文件是属于当前这个用户所在的组的,我们可以通过这个命令修改当前用户所在组,然后改变创建的文件的用户组,前提是这个用户必须属于待转变的组</p><h4 id="gpasswd"><a href="#gpasswd" class="headerlink" title="gpasswd"></a>gpasswd</h4><p>让用户成为一个群组的管理员,可以添加删除用户,也可以更改群组密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# gpasswd -A djm project  # 让djm成为project的管理员</span><br><span class="line">[djm@localhost ~]$ gpasswd -a root project # djm 让root加入这个组</span><br><span class="line">[djm@localhost ~]$ gpasswd -d root project # djm 让root退出这个组</span><br></pre></td></tr></table></figure><h4 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h4><ul><li>-S 查看用户的密码相关信息(失效时间,加密方式,……)    djm PS 2022-11-18 0 99999 7 -1 (密码已设置，使用 MD5 算法。)</li><li>passwd username 修改密码</li><li>-l 让用户密码失效(用户则无法登陆)</li><li>-u 让用户密码生效</li></ul><h4 id="chage"><a href="#chage" class="headerlink" title="chage"></a>chage</h4><p>修改密码的相关信息,但是不能修改密码哦, 如果对passwd -S 列出来的信息看不太明白,可以使用chage -l看的更加详细</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost shelltest]# chage -l djm</span><br><span class="line">最近一次密码修改时间                                    ：11月 18, 2022</span><br><span class="line">密码过期时间                                    ：从不</span><br><span class="line">密码失效时间                                    ：从不</span><br><span class="line">帐户过期时间                                            ：从不</span><br><span class="line">两次改变密码之间相距的最小天数          ：0</span><br><span class="line">两次改变密码之间相距的最大天数          ：99999</span><br><span class="line">在密码过期之前警告的天数        ：7</span><br></pre></td></tr></table></figure><h4 id="pwck"><a href="#pwck" class="headerlink" title="pwck"></a>pwck</h4><p>检查&#x2F;etc&#x2F;passwd与&#x2F;etc&#x2F;shadow里面的信息是否一致,如果不一致,会提示修改</p><h4 id="查看所有用户信息"><a href="#查看所有用户信息" class="headerlink" title="查看所有用户信息"></a>查看所有用户信息</h4><p>cat &#x2F;etc&#x2F;passwd</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line"></span><br><span class="line">格式:  用户名 用户密码(x代表设有密码,加密密码在/etc/shadow里面)  用户id 用户组id 描述信息 主目录(也就是家目录,登录后的目录) 默认shell(用户登录后启动这个shell进程,将用户的操作传递给内核,我们可以通过设置这个shell程序,让用户只能运行指定程序,而不登录)</span><br></pre></td></tr></table></figure><h4 id="查看所有用户名"><a href="#查看所有用户名" class="headerlink" title="查看所有用户名"></a>查看所有用户名</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd | awk &#x27;BEGIN &#123;FS=&quot;:&quot;&#125;&#123;print $1&#125;&#x27;</span><br></pre></td></tr></table></figure><h4 id="查看所有用户组"><a href="#查看所有用户组" class="headerlink" title="查看所有用户组"></a>查看所有用户组</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/group | awk &#x27;BEGIN &#123;FS=&quot;:&quot;&#125;&#123;print $1&#125;&#x27;</span><br></pre></td></tr></table></figure><h4 id="查看所有用户密码-加密了的"><a href="#查看所有用户密码-加密了的" class="headerlink" title="查看所有用户密码(加密了的)"></a>查看所有用户密码(加密了的)</h4><p>cat &#x2F;etc&#x2F;shadow</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用户名：加密密码：最后一次修改密码时间：最小修改密码时间间隔：密码有效期：密码需要变更前的警告天数：密码过期后的宽限时间：账号失效时间：保留字段</span><br><span class="line">root:$1$Mladfbadfdsqyh$x/vIgIfuiYp.XZybGThAB1:19302:0:99999:7:::</span><br><span class="line">bin:*:17834:0:99999:7:::</span><br><span class="line">polkitd:!!:17962::::::</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果加密密码为*,!这些就是为了让密码失效</span></span><br></pre></td></tr></table></figure><h4 id="查看所有用户组信息"><a href="#查看所有用户组信息" class="headerlink" title="查看所有用户组信息"></a>查看所有用户组信息</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dockerroot:x:980:</span><br><span class="line">hjc:x:1001:</span><br><span class="line">project:x:1003:djm,hjc</span><br><span class="line">git:x:1002:</span><br><span class="line">docker:x:979:</span><br><span class="line">用户组名称:密码:用户组id:属于该组的用户</span><br></pre></td></tr></table></figure><h3 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h3><h4 id="df"><a href="#df" class="headerlink" title="df"></a>df</h4><p>用于查看分区的总容量 剩余容量 以及用掉的容量</p><ul><li>-a 列出所有分区</li><li>-h 将大小变成人容易看懂的大小</li><li>-k 以KB为单位显示分区大小</li><li>-m 以MB为单位显示分区大小</li><li>df 文件或者目录 会显示这个文件或者目录所在分区的情况</li></ul><h4 id="da"><a href="#da" class="headerlink" title="da"></a>da</h4><p>用于查看文件或者目录所占大小</p><ul><li>-a 查看所有子目录和文件的大小,默认是只看所有子目录大小的</li><li>-h 就是说人话啦</li><li>-s 只显示指定目录大小,不列出它的子目录所占大小</li><li>-S 子目录大小与我的大小分开计算  就是当前目录的大小就是文件所占大小 不包括子目录</li><li>-k 以kB显示</li><li>-m 以MB显示</li></ul><h3 id="压缩与解压"><a href="#压缩与解压" class="headerlink" title="压缩与解压"></a>压缩与解压</h3><h4 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h4><p>涉及的参数:</p><ul><li>c 压缩</li><li>x 解压</li><li>z 以gzip方式解压缩</li><li>j 以bzip2方式解压缩</li><li>v 显示解压缩过程</li><li>f 指定压缩包名字</li><li>-C  如果要解压到其他目录去</li></ul><h5 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar czvf  压缩包名字.tar(.tar.gz 它两压缩方式一样) 待压缩文件</span><br><span class="line">tar cjvf  压缩包名字.tar.bz2 待压缩文件</span><br></pre></td></tr></table></figure><h5 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar xzvf 压缩包名字.tar -C 解压到的目录(必须存在)</span><br><span class="line">tar xjvf 压缩包名字.tar.bz2 -C</span><br></pre></td></tr></table></figure><h4 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h4><h5 id="压缩-1"><a href="#压缩-1" class="headerlink" title="压缩"></a>压缩</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -r 压缩包名字.zip 待压缩文件</span><br></pre></td></tr></table></figure><h5 id="解压-1"><a href="#解压-1" class="headerlink" title="解压"></a>解压</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip 压缩包名字 -d 解压路径</span><br></pre></td></tr></table></figure><h4 id="xz"><a href="#xz" class="headerlink" title="xz"></a>xz</h4><p>先压缩成tar 在压缩成tar.xz  xz -z 压缩包.tar</p><p>先解压缩成tar  xz -d 压缩包的.tar.xz</p><h3 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h3><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>主要功能 根据指定的信息 查找文件&#x2F;目录的路径 这个查找比较慢,一般也不太常用</p><p>格式是 : find 查找路径 参数类型 参数</p><p>常用参数:</p><ul><li><p>-name 根据文件名字进行查询  可以进行模糊查询 * 代表任意多字符 ? 代表一个字符</p></li><li><p>-type 根据文件类型进行查找</p></li><li><p>-size 根据文件大小进行查找 +4M 代表(4M,无穷大) -4M 代表(0,3M] 4M 代表(3M,4M]</p></li><li><p>-maxdepth 最多搜索到第几层</p></li><li><p>-mindepth 最少从第几层搜索</p><blockquote><p>如果想把搜索出来的结果当成参数传递给后面的命令 直接使用管道是不行的,至于为什么不行,请看十万个为什么章节,下面将介绍几个可以后面接命令的参数</p></blockquote></li></ul><p>同时执行多个操作</p><ul><li>-exec 后面可以接待执行的命令,最后得接{} ; 代表结束</li><li>-ok 它跟exec的功能时相似的 不过它是询问式的 问用户是否要进行后面的操作</li><li>xargs 它是一个单独的命令 可以将前一个命令的输出流解析成参数给后面的命令 find -name test -type d | xargs ls</li></ul><h4 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h4><p>这个命令是去linux系统自己维护的数据库中查找,每天自动更新,所以实时更新的文件它会找不到必须先更新它的数据库</p><blockquote><p>sudo updatedb</p></blockquote><ul><li>单纯根据名字查找文件 locate 文件名 (查找数据库中所有路径包含关键字的文件或者目录)</li><li>根据路径查找(必须是绝对路径) locate 绝对路径  (查找所有路径中 以这个路径开头的路径对应的文件或者目录)</li><li>-i 忽略大小写</li><li>-n 显示前几个</li><li>-r 使用正则表达式</li></ul><h4 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h4><p>在指定目录下找文件  whereis filename  </p><ul><li>-l 查看查找的目录</li><li>-b 查找二进制文件</li></ul><h3 id="文本三剑客"><a href="#文本三剑客" class="headerlink" title="文本三剑客"></a>文本三剑客</h3><h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><p>grep 和 find 的区别 在于 grep是查找文件里面的东西</p><p>格式: grep “搜索内容” 搜索目录&#x2F;文件 参数</p><p>常用参数:</p><ul><li>-r 如果要搜索目录下文件内容的东西 必须使用这个参数</li><li>-i 忽略大小写</li><li>-n 显示搜索内容所在文件行</li><li>-v 显示不满足要求的文件内容</li><li>-w 整个单词匹配</li></ul><p>如果不写搜索文件 而且也没有使用-r 参数 则会根据输入内容进行匹配</p><p>如果不写搜索文件 但是使用了-r 参数 则会执行执行这样的命令 grep “搜索内容” -r &#x2F;  相当于全盘文件内容查找</p><h4 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h4><p>sed可以利用脚本处理文件或者输入流,可以编辑,删除,新增文件里面的东西</p><p>参数:</p><ul><li>-e 以指定脚本操作文本</li><li>-f 以指定脚本文件操作文本</li><li>-n 仅显示脚本操作后的文本</li><li>-i 修改源文件</li></ul><p>动作:</p><ul><li>a 新增</li><li>c 取代</li><li>d 删除</li><li>i 插入</li><li>p 打印</li><li>s 取代(可以使用正则)</li></ul><p>有什么一个文件hello.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;log&quot;</span>  </span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log.SetPrefix(<span class="string">&quot;greetings: &quot;</span>)</span><br><span class="line">    log.SetFlags(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看我操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除第一行的内容</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;1d&#x27;</span> hello.go</span></span><br><span class="line">import (</span><br><span class="line">    &quot;log&quot;</span><br><span class="line">)</span><br><span class="line">func main() &#123;</span><br><span class="line">    log.SetPrefix(&quot;greetings: &quot;)</span><br><span class="line">    log.SetFlags(0)</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此时文件并没有改变,需要在sed后面加上-i才能改掉文件或者指定输出重定向覆盖掉原先的</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在main函数第一行里面新增一个 log.Fatal(<span class="string">&quot;hello world&quot;</span>)</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;5a  log.Fatal(&quot;hello world&quot;)&#x27;</span> hello.go</span></span><br><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;log&quot;</span><br><span class="line">)</span><br><span class="line">func main() &#123;</span><br><span class="line">log.Fatal(&quot;hello world&quot;)</span><br><span class="line">    log.SetPrefix(&quot;greetings: &quot;)</span><br><span class="line">    log.SetFlags(0)</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">把所有<span class="built_in">log</span>替换成logs</span></span><br><span class="line">sed &#x27;%s/log/logs/g&#x27;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h4><p>将文件或者输入流的一行按照 空格或者制表符(我们也能指定分隔符)拆开分成若干个参数供后面函数使用</p><p>常用参数</p><ul><li>-F 指定输入分割符</li><li>-f 指定脚本文件读取命令</li><li>-v 用户指定一个变量的值(可以用于内置变量,也可以用于自定义变量)</li></ul><p>内置变量</p><ul><li><p>FS 指定输入分割符</p></li><li><p>OFS 指定输出分割符</p></li><li><p>NF 字段数量(主要用于取倒数的第一个,减几个就是倒数几个)</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">取出用户名字和它的shell</span></span><br><span class="line">cat /etc/passwd | awk -v FS=&quot;:&quot; &#x27;&#123;print $1 &quot; &quot; $(NF-1)&#125;&#x27;</span><br></pre></td></tr></table></figure><h3 id="vim的使用"><a href="#vim的使用" class="headerlink" title="vim的使用"></a>vim的使用</h3><h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><h5 id="进入输入模式"><a href="#进入输入模式" class="headerlink" title="进入输入模式"></a>进入输入模式</h5><p>命令模式下的光标比较大,是覆盖了当前字符的,光标前就是这个字符前面,光标后就是这个字符后面</p><ul><li>i 当前光标前输入</li><li>a 光标后输入</li><li>I行首输入</li><li>A行尾输入</li><li>o向下插入新行</li><li>O向上插入新行</li></ul><h5 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h5><p>h 向左 j向下 k向上 l 向右</p><ul><li>0 移动到行首</li><li>^ 移动到行首字母</li><li>$ 移动到行尾</li><li>gg 移动到文件第一行行首</li><li>G 移动到文件最后一行行尾</li><li>nG 移动到第几行</li><li>n+回车 向下移动多少行</li><li>w 下一个字开头</li><li>b 上一个字开头</li><li>fx 移动到本行的下一个x字符开头</li><li>ctrl + u (up)向上翻半页</li><li>ctrl + d (down)向下翻半页</li></ul><h5 id="代码格式化"><a href="#代码格式化" class="headerlink" title="代码格式化"></a>代码格式化</h5><p>gg&#x3D;G</p><h5 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h5><ul><li>x 删除光标所在位置</li><li>X 删除光标前一个位置</li><li>dw 删除当前光标到这个单词结束的部分  比如 aa光标位置ww  会删除 ww</li><li>d0 删除当前位置到这一行开头的字符串</li><li>d$ 删除当前位置到这一行结尾的字符串</li><li>dd 删除当前行</li><li>ndd 删除n行</li></ul><h5 id="撤销与重做"><a href="#撤销与重做" class="headerlink" title="撤销与重做"></a>撤销与重做</h5><ul><li>u 撤销命令</li><li>Ctrl + r 重做</li></ul><h5 id="复制与粘贴"><a href="#复制与粘贴" class="headerlink" title="复制与粘贴"></a>复制与粘贴</h5><ul><li>yy 复制当前行</li><li>p 粘贴 小写粘贴到当前行下边 大写粘贴到当前行上边</li><li>nyy 复制n行</li></ul><h5 id="打开到指定行"><a href="#打开到指定行" class="headerlink" title="打开到指定行"></a>打开到指定行</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim file +100</span><br></pre></td></tr></table></figure><h4 id="末行模式"><a href="#末行模式" class="headerlink" title="末行模式"></a>末行模式</h4><h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/word  向后查找</span><br><span class="line">?word 向前查找</span><br><span class="line">按 n 执行上一次操作</span><br><span class="line">按 N 反向执行上一次操作</span><br></pre></td></tr></table></figure><h5 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1,$ s/查找字符/替换字符/g  等价于 %s/查找字符/替换字符/g</span><br><span class="line">替换1-最后一行的所有字符</span><br><span class="line"></span><br><span class="line">s/查找字符/替换字符/g</span><br><span class="line">替换当前行的所有字符</span><br><span class="line"></span><br><span class="line">s/查找字符/替换字符/</span><br><span class="line">替换当前行第一个匹配的字符</span><br></pre></td></tr></table></figure><h3 id="yum的使用"><a href="#yum的使用" class="headerlink" title="yum的使用"></a>yum的使用</h3><p>yum为什么会出现? 它解决了什么问题?</p><p>在最开始的时候,linux一般使用编译源码的方式安装应用程序,这样太麻烦了,后来出现了rpm包管理工具 只需要下载好.rpm包(这个包是编译好了的包)然后使用rpm安装就行,但是它有个缺点就是如果一个应用程序需要其他依赖,还得自己手动再去下载其他依赖,所以yum诞生了, 它将所有rpm包放在仓库中,安装一个rpm包时会自动下载它依赖的rpm包,我们也可以更改&#x2F;etc&#x2F;yum.repos.d&#x2F; 里面的文件更改yum仓库源</p><h4 id="更改为阿里源"><a href="#更改为阿里源" class="headerlink" title="更改为阿里源"></a>更改为阿里源</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo</span><br><span class="line">yum clean all #清除原先缓存</span><br><span class="line">yum makecache # 构建现在仓库缓存</span><br><span class="line">yum update # 更新程序</span><br></pre></td></tr></table></figure><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><ul><li>yum check-update 列出所有可以更新的软件</li><li>yum update (软件名字) 如果没有跟软件名字则更新所有软件 这个更新不会删除原来的软件</li><li>yum insall 软件名字   安装软件,这个过程可以会下载其他依赖,系统会询问你是否下载, 如果不想系统询问 可以 yum -y install</li><li>yum list 查看服务器提供的所有软件</li><li>yum upgrade  它和update功能差不多 不过它会删除过时的软件 而且还会更新系统内核</li><li>yum remove 删除软件包(也就是卸载)</li><li>yum search 搜索软件包</li><li>yum list updates 查看哪些软件可以更新</li></ul><h3 id="查看-x2F-操作系统信息命令"><a href="#查看-x2F-操作系统信息命令" class="headerlink" title="查看&#x2F;操作系统信息命令"></a>查看&#x2F;操作系统信息命令</h3><h4 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h4><p>常用参数</p><ul><li>start 开启服务</li><li>stop 关闭服务</li><li>status 查看服务状态</li><li>enable 设置服务开机自启动</li><li>disable 关机开启自启动</li><li>restart 重启服务</li></ul><h4 id="hostname"><a href="#hostname" class="headerlink" title="hostname"></a>hostname</h4><p>查看当前主机名</p><h4 id="hostnamectl"><a href="#hostnamectl" class="headerlink" title="hostnamectl"></a>hostnamectl</h4><p>修改主机名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostnamectl set-hostname name</span><br></pre></td></tr></table></figure><h4 id="fuser"><a href="#fuser" class="headerlink" title="fuser"></a>fuser</h4><p>查看哪个进程正在使用当前文件或者目录</p><h4 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h4><p>主要用于查看进程打开的文件名称和数目 (非root用户使用时,可能看不到root用户的某些信息),linux 万物皆文件,所以也能查看进程对应的网络信息</p><p>这个命令的功能太强大了,下面就只写几个好用一点的</p><ul><li>lsof -i :port 显示使用port 端口的进程信息 (把-i 看成Internet)</li><li>lsof -i  tcp(udp) 显示所有tcp(udp)的网络信息 </li><li>上面两个是可以组合的 比如 lsof -i tcp:22</li><li>lsof -c vsftpd 显示 vsftpd 打开的文件</li><li>lsof -p pid 显示pid对应的进程打开的文件</li><li>lsof -u djm 显示djm这个用户打开的文件</li></ul><h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><p>查看系统进程</p><ul><li>ps -a 查看当前用户的所有进程</li><li>ps -aux 显示所有用户的进程,并且列出进程所属用户</li></ul><h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>可以查看内存和交换区已经用了多少,还剩多少,cpu的状态</p><p>各个进程的占用资源的实时信息</p><p>类似于windows的资源管理器</p><h4 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h4><p>查看系统运行的时间,当前登录用户,工作负载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost shelltest]# uptime </span><br><span class="line"> 11:12:42 up  1:25,  3 users,  load average: 6.26, 4.86, 3.35</span><br></pre></td></tr></table></figure><h4 id="查看系统版本"><a href="#查看系统版本" class="headerlink" title="查看系统版本"></a>查看系统版本</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/os-release</span><br><span class="line">cat /etc/centos-release</span><br></pre></td></tr></table></figure><h4 id="查看日志信息-journalctl"><a href="#查看日志信息-journalctl" class="headerlink" title="查看日志信息(journalctl)"></a>查看日志信息(journalctl)</h4><p>我们平时开启了很多服务,这些服务都是后台运行,那它们的日志信息我们就不能看到,不过linux提供了Systemd来管理所有日志信息,我们只需要通过journalctl这个命令就能查看</p><ul><li><strong>journalctl -u 查看指定服务的日志</strong> </li><li>journalctl -k 查看内核日志</li><li>journalctl -b 查看启动日志</li><li>-n 查看最近几行的</li><li>-r 查看最旧的几行</li><li>-f 实时显示</li></ul><h4 id="查看CPU型号"><a href="#查看CPU型号" class="headerlink" title="查看CPU型号"></a>查看CPU型号</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmidecode -s processor-version</span><br></pre></td></tr></table></figure><h4 id="查看CPU详细信息"><a href="#查看CPU详细信息" class="headerlink" title="查看CPU详细信息"></a>查看CPU详细信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo</span><br></pre></td></tr></table></figure><h4 id="查看物理cpu个数"><a href="#查看物理cpu个数" class="headerlink" title="查看物理cpu个数"></a>查看物理cpu个数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep &quot;physical id&quot; | sort | uniq|wc -l</span><br></pre></td></tr></table></figure><h4 id="查看一个CPU是几核"><a href="#查看一个CPU是几核" class="headerlink" title="查看一个CPU是几核"></a>查看一个CPU是几核</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep &quot;cores&quot;|uniq</span><br></pre></td></tr></table></figure><h4 id="查看CPU逻辑核心数"><a href="#查看CPU逻辑核心数" class="headerlink" title="查看CPU逻辑核心数"></a>查看CPU逻辑核心数</h4><p>逻辑核心数 &#x3D; CPU个数*CPU核数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep &quot;processor&quot; |wc -l</span><br></pre></td></tr></table></figure><h4 id="例行性工作调度"><a href="#例行性工作调度" class="headerlink" title="例行性工作调度"></a>例行性工作调度</h4><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><h4 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h4><p>用于杀死或者停止一个进程</p><ul><li>kill -1 重新加载进程</li><li>kill -9 杀死进程</li></ul><h4 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h4><p>用于统计文件中 字符数 行数 单词数目</p><ul><li>wc -l 统计行数</li><li>wc -w 统计单词数目</li><li>wc -c 统计字符数</li><li>wc  依次显示上面三个</li></ul><h4 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h4><p>可以设置运行同一个命令的间隔</p><ul><li>-n 设置时间间隔</li><li>-d 显示变化的部分</li></ul><h4 id="tee"><a href="#tee" class="headerlink" title="tee"></a>tee</h4><p>这个命令主要将输入流的东西写到文件里面去</p><ul><li>-i  忽略中断</li><li>-a 追加到文件里面去,而不是覆盖</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls | tee test.txt  #将ls的输出全部放到test.txt中去</span><br><span class="line">tee test.txt # 将我们自己的输入写到文件里面去</span><br></pre></td></tr></table></figure><h4 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h4><p>显示当前工作目录</p><h4 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h4><p>文件不存在则创建文件,文件存在更新修改时间</p><h4 id="which"><a href="#which" class="headerlink" title="which"></a>which</h4><p>查看非内建命令的位置</p><h4 id="date"><a href="#date" class="headerlink" title="date"></a>date</h4><p>查看或者设置系统时间</p><h4 id="clock"><a href="#clock" class="headerlink" title="clock"></a>clock</h4><p>查看或者设置硬件时间</p><h4 id="tzselect"><a href="#tzselect" class="headerlink" title="tzselect"></a>tzselect</h4><p>选择时区</p><h4 id="lastlog"><a href="#lastlog" class="headerlink" title="lastlog"></a>lastlog</h4><p>查看用户上一次登录时间</p><h3 id="shell-编程"><a href="#shell-编程" class="headerlink" title="shell 编程"></a>shell 编程</h3><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>定义一个变量</p><h4 id="unset"><a href="#unset" class="headerlink" title="unset"></a>unset</h4><p>删除一个变量</p><h4 id="变量的使用方式"><a href="#变量的使用方式" class="headerlink" title="变量的使用方式"></a>变量的使用方式</h4><p>比如有个变量x </p><p>赋值  x&#x3D;1</p><p>取值 $x  或者 ${x} 推荐使用后者 ,  不要和$()搞混哦</p><p>计算 $(($x+1))</p><h4 id="decalre"><a href="#decalre" class="headerlink" title="decalre"></a>decalre</h4><ul><li>-i 声明为 整数类型</li><li>+i 删除为整数类型</li><li>-f 显示函数内容</li><li>-p 显示属性名字和值</li><li>-r 增加为只读属性</li><li>-x 设置为全局变量</li><li>+x 设置为自订变量</li></ul><h4 id="变量的测试与替换"><a href="#变量的测试与替换" class="headerlink" title="变量的测试与替换"></a>变量的测试与替换</h4><table><thead><tr><th align="center">表达式</th><th align="center">str没有设定</th><th align="center">str为空字符串</th><th align="center">str设定了且不为空字符串</th></tr></thead><tbody><tr><td align="center">var&#x3D;${str-expr}</td><td align="center">var&#x3D;$expr</td><td align="center">var&#x3D;$str</td><td align="center">var&#x3D;$str</td></tr><tr><td align="center"><strong>var&#x3D;${str:-expr}</strong></td><td align="center">var&#x3D;$expr</td><td align="center">var&#x3D;$expr</td><td align="center">var&#x3D;$str</td></tr><tr><td align="center">var&#x3D;${str+expr}</td><td align="center">var&#x3D;$str</td><td align="center">var&#x3D;$expr</td><td align="center">var&#x3D;$expr</td></tr><tr><td align="center">var&#x3D;${str:+expr}</td><td align="center">var&#x3D;$str</td><td align="center">var&#x3D;$str</td><td align="center">var&#x3D;$expr</td></tr><tr><td align="center">这个也太难记住了吧</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h4 id="变量的数值运算"><a href="#变量的数值运算" class="headerlink" title="变量的数值运算"></a>变量的数值运算</h4><p>$( <strong>($a*$b)</strong> ) 中间这个括号不能省</p><p>举个例子    a&#x3D;1,b&#x3D;2    $($a*$b) &#x3D;&gt; $(1*2)  这个式子bash是看不懂的哦 因为 $()是代表执行里面的命令  而 $((1*2)) 会被计算是因为(1*2)代表的命令时计算</p><h4 id="test"><a href="#test" class="headerlink" title="test"></a>test</h4><p>test命令主要用于判断</p><h5 id="文件是否存在或者权限判定"><a href="#文件是否存在或者权限判定" class="headerlink" title="文件是否存在或者权限判定"></a>文件是否存在或者权限判定</h5><ul><li>-e name 是否有文件名或者目录名为name</li><li>-f name 文件是否存在</li><li>-d name 目录是否存在</li><li>-r name 是否可读</li><li>-w name 是否可写</li><li>-x name 是否可执行</li><li>-u name 是否具有suid权限</li><li>-g name 是否具有sgid权限</li><li>-k name 是否具有 sbit权限</li></ul><h5 id="整数判定"><a href="#整数判定" class="headerlink" title="整数判定"></a>整数判定</h5><ul><li>-eq 是否相等</li><li>-ne 是否不相等</li><li>-gt 大于</li><li>-lt 小于</li><li>-ge &gt;&#x3D;</li><li>-le &lt;&#x3D;</li></ul><h5 id="字符串判定"><a href="#字符串判定" class="headerlink" title="字符串判定"></a>字符串判定</h5><ul><li>-z string 是否是空串</li><li>-n string 是否不是空串</li><li>&#x3D;&#x3D; 两个字符串是否相等</li><li>!&#x3D; 两个字符串是否不相等</li></ul><h5 id="多重判定"><a href="#多重判定" class="headerlink" title="多重判定"></a>多重判定</h5><ul><li>-a and</li><li>-o or</li><li>! 取反</li></ul><h5 id="代替test"><a href="#代替test" class="headerlink" title="[]代替test"></a>[]代替test</h5><p>我们经常用[] 代替test 这里要主要格式</p><p>[  “a” &#x3D;&#x3D; “b” ] 要注意空格哦 ,还有就是使用变量名的时候最好用”$a” 这种</p><h4 id="预设变量"><a href="#预设变量" class="headerlink" title="预设变量"></a>预设变量</h4><ul><li>$0 文件名字</li><li>$# 变量个数</li><li>$@ 全部变量</li><li>$* 全部变量  </li><li>$1……n 输入的参数</li></ul><h4 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h4><h5 id="if"><a href="#if" class="headerlink" title="if"></a>if</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if [];then</span><br><span class="line">elif [];then</span><br><span class="line">else</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h5 id="case"><a href="#case" class="headerlink" title="case"></a>case</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">case $1 in</span><br><span class="line">变量|常量)</span><br><span class="line">代码段</span><br><span class="line">;;</span><br><span class="line">变量)</span><br><span class="line">代码段</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for var in a b c</span><br><span class="line">do</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while [ 判断表达式 ] </span><br><span class="line">do</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>函数里面也有预设变量哦 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">函数的定义</span></span><br><span class="line">function func()&#123;</span><br><span class="line">echo $@</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">必须先定义才能使用</span></span><br><span class="line">func 1 2 3</span><br></pre></td></tr></table></figure><h4 id="shell-脚本debug"><a href="#shell-脚本debug" class="headerlink" title="shell 脚本debug"></a>shell 脚本debug</h4><ul><li>-n 检查语法不执行</li><li>-v 执行前将命令输出到屏幕</li><li>-x 将用到的命令才输出到屏幕</li></ul><h3 id="例行性工作"><a href="#例行性工作" class="headerlink" title="例行性工作"></a>例行性工作</h3><h4 id="at"><a href="#at" class="headerlink" title="at"></a>at</h4><h4 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h4><h3 id="程序管理"><a href="#程序管理" class="headerlink" title="程序管理"></a>程序管理</h3><h4 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h4><p>我们在一个终端中,是可以在后台执行多个任务的,只需要使用 &amp; 跟在最后面就行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zpcvf /tmp/etc.tar.gz /etc &amp;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">备份/etc目录</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这个时候,我们还是可以操作前台的</span></span><br></pre></td></tr></table></figure><h4 id="jobs"><a href="#jobs" class="headerlink" title="jobs"></a>jobs</h4><p>我们可以通过这个命令来查看当前终端的后台任务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost shelltest]# jobs</span><br><span class="line">[1]+  运行中               sh test.sh &gt; test.txt &amp;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>-l 列出pid</li><li>-r 列出正在背景中进行工作</li><li>-s 列出停止了的工作</li></ul><h4 id="fg"><a href="#fg" class="headerlink" title="fg"></a>fg</h4><p>如果我们想让后台的工作拿到前台来,可以使用这个命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fg 工作号</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">比如上列中将工作号为1的拿到前台来工作</span></span><br><span class="line">fg 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果不输入工作号,则会拿取有+号的任务,列如下面会那去2号任务</span></span><br><span class="line">[1]-  运行中               sh test.sh &gt; test.txt &amp;</span><br><span class="line">[2]+  运行中               sh test.sh &gt; test1.txt &amp;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>拿到前台来工作后,我们可以使用Ctrl+z来停止这个任务并且丢到后台去,但是没有删除哦(ctrl+c 会删除这个任务)</p><h4 id="bg"><a href="#bg" class="headerlink" title="bg"></a>bg</h4><p>这个命令可以使后台的停止了的任务重新执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我们将上面的2号任务拿到前台</span></span><br><span class="line">[root@localhost shelltest]# fg </span><br><span class="line">sh test.sh &gt; test1.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后按ctrl+z 停止它</span></span><br><span class="line">^Z</span><br><span class="line">[2]+  已停止               sh test.sh &gt; test1.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我们可以输入下面这个命令重新后台运行那个任务</span></span><br><span class="line">bg 2 </span><br><span class="line"></span><br><span class="line">[root@localhost shelltest]# bg 2</span><br><span class="line">[2]+ sh test.sh &gt; test1.txt &amp;</span><br><span class="line">[root@localhost shelltest]# jobs</span><br><span class="line">[1]-  运行中               sh test.sh &gt; test.txt &amp;</span><br><span class="line">[2]+  运行中               sh test.sh &gt; test1.txt &amp;</span><br><span class="line">[root@localhost shelltest]# </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="kill-1"><a href="#kill-1" class="headerlink" title="kill"></a>kill</h4><p>如果我们想结束一个工作,可以使用kill命令  格式 kill   -singnal %number  (必须是%number哦,不然默认是进程号)</p><ul><li>-9 %number 强制删除</li><li>-15 %number 正常删除</li></ul><h4 id="nohub"><a href="#nohub" class="headerlink" title="nohub"></a>nohub</h4><p>默认情况下,所有的工作都是在当前终端的背景下执行的哦,当我们终端退出后,所有的工作都将结束,这当然是我们不想看到的,所有我们可以通过这个命令,可以让终端机退出后依然执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohub sh test.sh &gt; test4.txt &amp; </span><br></pre></td></tr></table></figure><h3 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h3><h4 id="测试桥接哪些ip能用"><a href="#测试桥接哪些ip能用" class="headerlink" title="测试桥接哪些ip能用"></a>测试桥接哪些ip能用</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> str <span class="keyword">in</span> <span class="string">&quot;10.8.38&quot;</span> <span class="string">&quot;10.8.39&quot;</span>  <span class="comment"># 这里的ip得换成自己的</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        i=1</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$i</span> -lt 255 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        str1=<span class="string">&quot;<span class="variable">$str</span>.<span class="variable">$i</span>&quot;</span></span><br><span class="line">        sed -i  <span class="string">&quot;1,\$s/^IPADD.*\$/IPADDR=<span class="variable">$str1</span>/g&quot;</span>  ./ifcfg-ens33 &gt; log.txt</span><br><span class="line"></span><br><span class="line">        systemctl restart network <span class="comment"># 这里是可以优化的地方,但是我</span></span><br><span class="line">        <span class="comment"># ifconfig ens33 $str1 </span></span><br><span class="line">        <span class="keyword">if</span> [ $? -eq 0 ];<span class="keyword">then</span></span><br><span class="line">                curl  --connect-timeout 1  -s http://www.baiud.com &gt; log.txt <span class="comment"># 如果局域网里面能够ping的话建议用ping</span></span><br><span class="line">                <span class="keyword">if</span> [ $? -eq 0 ];<span class="keyword">then</span></span><br><span class="line">                         <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$str1</span> isok&quot;</span></span><br><span class="line">                         <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$str1</span> isok&quot;</span> &gt;&gt; ok.txt</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$str1</span> not ok&quot;</span></span><br><span class="line">                <span class="keyword">fi</span></span><br><span class="line">                        i=$((<span class="variable">$i</span>+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">sleep</span> 1</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="firewall-cmd"><a href="#firewall-cmd" class="headerlink" title="firewall-cmd"></a>firewall-cmd</h4><ul><li>firewall-cmd –state 查看运行状态</li><li>firewall-cmd –zone&#x3D;public –list-posts 查看开放的端口</li><li>firewall-cmd –zone&#x3D;public –add-port&#x3D;80&#x2F;tcp –permanent 打开端口</li><li>firewall-cmd –zone&#x3D;public –remove-port&#x3D;80&#x2F;tcp –permanent 关闭端口</li><li><strong>firewall-cmd –reload</strong>  所有开放端口关闭端口,都需要重新使用这个命令才能生效</li></ul><p>增加端口开关脚本</p><p>openport (输入参数为一个时,开启一个端口,两个时,开启[a,b) 左闭右开 )</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">if [ &quot;$#&quot; -gt &quot;0&quot; ]; then</span><br><span class="line">        if [ &quot;$#&quot; -eq &quot;1&quot; ]; then</span><br><span class="line">                firewall-cmd --zone=public --add-port=$1/tcp --permanent &gt; /dev/null</span><br><span class="line">        elif [ &quot;$#&quot; -eq &quot;2&quot; ]; then</span><br><span class="line">                a=$1</span><br><span class="line">                b=$2</span><br><span class="line">                [ &quot;$1&quot; -gt &quot;$2&quot; ]&amp;&amp;a=$2                 </span><br><span class="line">                [ &quot;$1&quot; -gt &quot;$2&quot; ]&amp;&amp;b=$1</span><br><span class="line">                for((i=$a;i&lt;$b;i++))</span><br><span class="line">                do</span><br><span class="line">                        firewall-cmd --zone=public --add-port=$i/tcp --permanent &gt; /dev/null</span><br><span class="line">                done            </span><br><span class="line">        fi</span><br><span class="line">        if [ &quot;$?&quot; -eq &quot;0&quot; ]; then</span><br><span class="line">                firewall-cmd --reload &gt; /dev/null</span><br><span class="line">                echo &quot;success&quot;</span><br><span class="line">        fi</span><br><span class="line"> </span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>closeport(参数与openport同理)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">if [ &quot;$#&quot; -gt &quot;0&quot; ]; then</span><br><span class="line">        if [ &quot;$#&quot; -eq &quot;1&quot; ]; then</span><br><span class="line">                firewall-cmd --zone=public --remove-port=$1/tcp --permanent &gt; /dev/null</span><br><span class="line">        elif [ &quot;$#&quot; -eq &quot;2&quot; ]; then</span><br><span class="line">                a=$1</span><br><span class="line">                b=$2</span><br><span class="line">                [ &quot;$1&quot; -gt &quot;$2&quot; ]&amp;&amp;a=$2                 </span><br><span class="line">                [ &quot;$1&quot; -gt &quot;$2&quot; ]&amp;&amp;b=$1</span><br><span class="line">                for((i=$a;i&lt;$b;i++))</span><br><span class="line">                do</span><br><span class="line">                        firewall-cmd --zone=public --remove-port=$i/tcp --permanent &gt; /dev/null</span><br><span class="line">                done            </span><br><span class="line">        fi</span><br><span class="line">        if [ &quot;$?&quot; -eq &quot;0&quot; ]; then</span><br><span class="line">                firewall-cmd --reload &gt; /dev/null</span><br><span class="line">                echo &quot;success&quot;</span><br><span class="line">        fi</span><br><span class="line"> </span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h4><p>查看网络状态</p><ul><li>-t 显示tcp相关选项</li><li>-u 显示udp相关选项</li><li>-n 拒绝使用别名 能用数字的用数字(不然看不了端口号)</li><li>-l 仅显示正在监听的网络的信息</li><li>-p 显示对应进程pid 以及其名字</li><li>-a 显示所有连线的socket</li></ul><h4 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h4><p>查看电脑网卡信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有网卡信息</span><br><span class="line">ipconfig </span><br><span class="line"># 查看指定网卡信息</span><br><span class="line">ipconfig ens33</span><br><span class="line"># 配置网卡ip (临时有效,但是用了这个之后,路由什么的都没有了,很烦,就上不了网ss)</span><br><span class="line">ifconfig ens33 192.168.100.1 </span><br><span class="line"># 开关网卡(临时</span><br><span class="line">ifconfig ens33 up/down</span><br></pre></td></tr></table></figure><h4 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h4><h4 id="route"><a href="#route" class="headerlink" title="route"></a>route</h4><h4 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h4><p>它是linux内核中的包过滤防火墙,它包含四个表(filter(包过滤表),nat(地址转化表),mangle(修改数据标记位规则表),raw(跟踪数据规则表)), 5 个规则链。每个规则表中包含多个数据链：INPUT（入站数据过滤）、OUTPUT（出站数据过滤）、FORWARD（转发数据过滤）、PREROUTING（路由前过滤）和POSTROUTING（路由后过滤）</p><p><img src="/2022/11/24/linux/linux/../img/linuxassets/image-20221215110855463.png" alt="image-20221215110855463"></p><p>语法格式</p><p><img src="/2022/11/24/linux/linux/../img/linuxassets/image-20221215112303404.png" alt="image-20221215112303404"></p><p>iptables [-t table] COMMAND [chain] CRETIRIA -j ACTION</p><p>常用参数</p><ul><li>-t 指定要操作的规则表,默认为filter表</li><li>COMMAND 子命令</li><li>chain 指明链路</li><li>CRETIRIA 匹配参数</li><li>ACTION 触发动作</li></ul><p>常用选项</p><ul><li>-L 列出表规则</li><li>-F 清空表规则</li><li>-A 添加防火墙规则</li><li>-D 删除防火墙规则</li><li>-I 插入表规则</li><li>-R 替换防火墙规则</li></ul><p>触发动作</p><ul><li>ACCEPT 允许包通过</li><li>DROP 丢弃包</li><li>REJECT 拒绝数据包</li><li>LOG 将数据包信息记录 syslog 曰志</li><li>DNAT 目标地址转换</li><li>SNAE 源地址转换</li><li>MASQUERADE 地址欺骗</li><li>REDIRECT 重定向</li></ul><h4 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">declare -x all_proxy=&quot;socks://192.168.100.1:7890/&quot;</span><br><span class="line">declare -x http_proxy=&quot;http://192.168.100.1:7890/&quot;</span><br><span class="line">declare -x no_proxy=&quot;localhost,127.0.0.0/8,::1&quot;</span><br></pre></td></tr></table></figure><h4 id="配置网络信息"><a href="#配置网络信息" class="headerlink" title="配置网络信息"></a>配置网络信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">TYPE=&quot;Ethernet&quot;        # 网卡类型</span><br><span class="line">PROXY_METHOD=&quot;none&quot;    # 代理方式</span><br><span class="line">BROWSER_ONLY=&quot;no&quot;   </span><br><span class="line">BOOTPROTO=&quot;none&quot;   # ip设置方式  none:不使用协议,自己指定  static: 静态ip,自己指定  dhcp: 动态获取</span><br><span class="line">DEFROUTE=&quot;yes&quot;   # 默认路由</span><br><span class="line">IPV4_FAILURE_FATAL=&quot;no&quot; </span><br><span class="line">IPV6INIT=&quot;yes&quot;    </span><br><span class="line">IPV6_AUTOCONF=&quot;yes&quot;</span><br><span class="line">IPV6_DEFROUTE=&quot;yes&quot;</span><br><span class="line">IPV6_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;</span><br><span class="line">NAME=&quot;ens33&quot;  # 网卡物理设备名称</span><br><span class="line">UUID=&quot;3ebc507c-6401-4454-b5ff-4108c88f230a&quot;</span><br><span class="line">DEVICE=&quot;ens33&quot;           # 网卡设备名称,必须和name一样</span><br><span class="line">ONBOOT=&quot;yes&quot;# 是否开机自启动</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##### 如果没有用 dhcp协议的话,下面这些就得自己指定</span></span></span><br><span class="line">IPADDR=&quot;192.168.100.3&quot;   # ip地址</span><br><span class="line">NETMASK=&quot;255.255.255.0&quot;  # 子网掩码   PREFIX=24  推荐用这个,写起来方便</span><br><span class="line">GATEWAY=&quot;192.168.100.2&quot;  # 网关</span><br><span class="line">DNS1=&quot;192.168.100.2&quot;     # dns服务器,可以指定多个 比如 DNS2=&quot;114.114.1&quot;</span><br></pre></td></tr></table></figure><h3 id="SELinux"><a href="#SELinux" class="headerlink" title="SELinux"></a>SELinux</h3><h3 id="额外补充"><a href="#额外补充" class="headerlink" title="额外补充"></a>额外补充</h3><h4 id="目录权限与文件权限的区别"><a href="#目录权限与文件权限的区别" class="headerlink" title="目录权限与文件权限的区别  "></a><span id="t1">目录权限与文件权限的区别  </span></h4><p><strong>文件权限</strong>: 给了某个权限就能用某个权限,没给权限就不能用,比如没给x权限,你就不能执行这个程序,哎,有人就刚我了,它说我这里有个shell脚本,我用sh能够执行啊,大哥,你那是把脚本里面的东西读出来一句一句给sh去执行呢,你把读权限关了试试,如果我们不是文件的拥有者(root除外),我们无法更改文件的路径,权限,所有者</p><p><strong>目录权限</strong>: 如果我们没有 这个目录的 x权限,我们是无法进入这个目录的(也就是把当前工作目录变成这个目录,例如cd命令就无法使用),也无法查看里面的东西(最多看到文件名),也就没有办法对这个目录执行任何命令, 在 x权限的基础上,有了r权限,我们才能这个这个目录下面的文件的属性,这个目录下的东西又有它们的权限, 在有了x权限的基础上,有了w权限,我们可以在这个文件夹里删除任何数据,创建任何数据,不管这个文件或者文件夹属于谁.</p><p><strong>工作目录</strong>:就是pwd显示的目录,如果我们不能把某个目录当成我们的工作目录(即 没有x权限,那么我们是无法对这个目录执行任何命令的</p><p>总结:<strong>如果我们开放一个目录的权限,首先要开放x权限,只给r,w是没有用的</strong>,如果我们要给一个文件权限,我们可以看着给,是只给读还是只给执行,还是混着来</p><h4 id="sudoers文件如何编写"><a href="#sudoers文件如何编写" class="headerlink" title="sudoers文件如何编写"></a>sudoers文件如何编写</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">为单独一个用户设置</span> </span><br><span class="line">root    ALL=(ALL)       ALL</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">用户名  可以在哪些主机上下达命令 可以切换的账号  可以执行的命令</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">为一个群组设置(只要是这个群组的人就可以享受下面的这个配置)</span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">wheel  ALL=(ALL)       ALL</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">群组名称 可以在哪些主机上下达命令 可以切换的账号  可以执行的命令</span>  </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">上面配置好后,使用sudo的时候,需要输入自己的密码,还是挺麻烦的</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">无密码使用sudo</span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">wheel  ALL=(ALL)       NOPASSWD:ALL</span></span><br><span class="line">root    ALL=(ALL)       NOPASSWD:ALL</span><br></pre></td></tr></table></figure><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>&gt; 代表 覆盖</p><p>&gt;&gt; 代表追加</p><h4 id="什么是管道命令"><a href="#什么是管道命令" class="headerlink" title="什么是管道命令(|)"></a>什么是管道命令(|)</h4><blockquote><p>用来连接多条命令,前一个<strong>命令正确</strong>后,其<strong>输出流会变成后一个命令的输入流</strong>(此时前一个命令的输出不会再打印到终端),<strong>而不是参数</strong> </p><p>我个人当时难以区分的就是参数与输入流 参数的参数,输入流是输入流,不要搞混了,有些命令可以带参数,但是不具备输入流</p><p><strong>管道命令还可以当连接命令来用,可以连接很多命令,这些命令都会执行</strong></p></blockquote><h4 id="配置环境变量的方法"><a href="#配置环境变量的方法" class="headerlink" title="配置环境变量的方法"></a>配置环境变量的方法</h4><h5 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h5><p>可以在 ~&#x2F;.bash_profile(只有当前用户可以用) 或者 &#x2F;etc&#x2F;profile(全部用户都可以用) 的末尾加上 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:目录的绝对路径(必须是目录和绝对路径)</span><br></pre></td></tr></table></figure><p>然后 再 source  ~&#x2F;.bash_profile 或者 &#x2F;etc&#x2F;profile</p><p>这两个的区别在于 一个只有当前用户生效,一个全局生效</p><p>其实也可以在 ~&#x2F;.bashrc里面更改</p><h5 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h5><p>通过软连接把应用程序连接到已经在PATH的路径下 列如 &#x2F;urs&#x2F;bin</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s 程序绝对地址 /usr/bin</span><br></pre></td></tr></table></figure><h4 id="命令与服务的区别"><a href="#命令与服务的区别" class="headerlink" title="命令与服务的区别"></a>命令与服务的区别</h4><p>命令运行一次就结束了,比如ls,cd 这些,都是放在环境变量下面的,而服务是启动后就一直再后台跑,接收请求,响应请求</p><h4 id="设置回收站"><a href="#设置回收站" class="headerlink" title="设置回收站"></a>设置回收站</h4><p>建议使用rm 命令的时候一定要格外注意特别是 rm -rf .&#x2F; 与 rm -rf &#x2F; 我的建议是都是用绝对路径,另外也不要配置管道命令来使用</p><p>用别名把rm替换成mv这个命令,然后移动到回收站中,我这里做一个简易的回收站</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建回收站目录</span></span><br><span class="line">mkdir /trash</span><br><span class="line"></span><br><span class="line">vim /etc/bashrc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在最后面输入</span></span><br><span class="line"></span><br><span class="line">alias rm=trash</span><br><span class="line"></span><br><span class="line">trash()&#123;</span><br><span class="line">    mv $@ /trash #这个路径必须和回收站路径一样</span><br><span class="line">&#125;</span><br><span class="line">rmtrash()&#123;</span><br><span class="line">         read -p &quot;确定要清空回收站吗?[y/n]&quot; confirm</span><br><span class="line">    [ $confirm == &#x27;y&#x27; ] || [ $confirm == &#x27;Y&#x27; ] &amp;&amp; /bin/rm -rf /trash/* #这个路径也要和回收站路径一样</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输入完成后退出,更新</span></span><br><span class="line">source /etc/bashrc</span><br></pre></td></tr></table></figure><p>千万不要用 mv &#x2F;* 所以这个回收站还是没啥用 </p><h4 id="如何设置系统时间"><a href="#如何设置系统时间" class="headerlink" title="如何设置系统时间"></a>如何设置系统时间</h4><p>linux有系统时间与硬件时间的区别,我们更改系统时间的同时,也要同步硬件时间</p><h5 id="方式一-1"><a href="#方式一-1" class="headerlink" title="方式一"></a>方式一</h5><p>使用date命令更改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">date -s &quot;2022-11-11 20:00:00&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">同步硬件时间</span></span><br><span class="line">clock --systohc</span><br></pre></td></tr></table></figure><p>这种方式只能一次生效,当你的系统没有运行了,时间也会停止.</p><h5 id="方式二-推荐"><a href="#方式二-推荐" class="headerlink" title="方式二(推荐)"></a>方式二(推荐)</h5><p>使用tzselect更改时区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tzselect</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输入完后根据提示选择即可</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">选择完后会输出下面一段信息</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ou can make this change permanent <span class="keyword">for</span> yourself by appending the line</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">TZ=<span class="string">&#x27;Asia/Shanghai&#x27;</span>; <span class="built_in">export</span> TZ</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">to the file <span class="string">&#x27;.profile&#x27;</span> <span class="keyword">in</span> your home directory; <span class="keyword">then</span> <span class="built_in">log</span> out and <span class="built_in">log</span> <span class="keyword">in</span> again.</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">最后一定要进行下一步,将上面选择的时区信息加到启动配置文件中去(系统启动之后才会看到时间更改)</span></span><br><span class="line">echo &quot;TZ=&#x27;Asia/Shanghai&#x27;; export TZ&quot; &gt;&gt; /etc/profile</span><br></pre></td></tr></table></figure><h4 id="export"><a href="#export" class="headerlink" title="export"></a>export</h4><p>终端分 自订变量与环境变量 通过set 或者 直接赋值的变量是 自订变量,通过export的会变成环境变量,每个子程序会继承父程序的环境变量,而不会继承父程序的自订变量</p><h4 id="source与sh的区别"><a href="#source与sh的区别" class="headerlink" title="source与sh的区别"></a>source与sh的区别</h4><p>source 或者 . 不另开进程执行脚本,而sh 或者 .&#x2F; 会另开进程执行脚本,source 能够使用 当前终端的自订变量,sh不能</p><h4 id="各个环境配置文件的区别"><a href="#各个环境配置文件的区别" class="headerlink" title="各个环境配置文件的区别"></a>各个环境配置文件的区别</h4><p>我们得先区分loginshell 与 nonloginshell 的区别,loginshell是用户登录取得bash的时候需要完整的登录流程,nologinshell 是 当我们登录后,再启动子bash程序,是不需要再登录的,这个就是nologinshell</p><p>&#x2F;etc&#x2F;profile (loginshell 才会去读) 是 每个用户登录取得bash的时候会读取一遍的文件</p><p>~&#x2F;.bash_profile(loginshell 才会去读)  bash 读取完全局的&#x2F;etc&#x2F;profile 后 会读取用户自己的配置文件, 它其实有个顺序,  .bash_profile .bash_login  .profile  只要前面的文件存在,后面的文件就不会被读取,我们可以看一下.bash_profile 的内容:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if [ -f ~/.bashrc ]; then    </span><br><span class="line">        . ~/.bashrc   </span><br><span class="line">fi</span><br><span class="line">PATH=$PATH:$HOME/bin</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们发现它还会去找 家目录下的 bashrc文件</p><p>~&#x2F;.bashrc(nonshell 才会去读),我们每启动一个子终端,就回去读取一次的文件,我们可以看一下文件内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alias rm=&#x27;rm -i&#x27;</span><br><span class="line">alias cp=&#x27;cp -i&#x27;</span><br><span class="line">alias mv=&#x27;mv -i&#x27;</span><br><span class="line">if [ -f /etc/bashrc ]; then</span><br><span class="line">        . /etc/bashrc</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>我么发现它还去读了&#x2F;etc&#x2F;bashrc 这个配置文件</p><p>这些东西都是在root用户下看的哦,不同的用户可能不同</p><p><strong>总结:  在loginshell 中 bash 会去读取&#x2F;etc&#x2F;profile   <del>&#x2F;.bash_profile ,在 nonloginshell中bash 会去读取</del>&#x2F;.bashrc里面的东西,这些是bash会帮我们自动读取的,如果需要读其他配置文件,我们需要在上面的shell中写好读取哪些文件</strong></p><h4 id="特殊变量中-与-的区别"><a href="#特殊变量中-与-的区别" class="headerlink" title="特殊变量中$* 与 $@ 的区别"></a>特殊变量中$* 与 $@ 的区别</h4><p>如果直接使用$* 与 $@ 他们没有任何区别,如果 加上双引号,”$*”循环遍历的时候是一个整体,而”$@” 则是 分开遍历</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">传入参数 1 2 3 4</span></span><br><span class="line">for i in &quot;$@&quot;</span><br><span class="line">do</span><br><span class="line">        echo $i</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4</span></span><br><span class="line">for i in &quot;$*&quot;</span><br><span class="line">do</span><br><span class="line">        echo $i</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输出 1 2 3 4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="查看端口占用情况"><a href="#查看端口占用情况" class="headerlink" title="查看端口占用情况"></a>查看端口占用情况</h4><h5 id="查看端口是否被占用"><a href="#查看端口是否被占用" class="headerlink" title="查看端口是否被占用"></a>查看端口是否被占用</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lsof -i :80</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">或者</span></span><br><span class="line">netstat -tunlp | grep 80</span><br></pre></td></tr></table></figure><h5 id="查看进程占用哪个端口"><a href="#查看进程占用哪个端口" class="headerlink" title="查看进程占用哪个端口"></a>查看进程占用哪个端口</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tunlp | grep nginx(进程大概名字)</span><br></pre></td></tr></table></figure><h4 id="测试远程端口是否开放"><a href="#测试远程端口是否开放" class="headerlink" title="测试远程端口是否开放"></a>测试远程端口是否开放</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install telnet</span><br><span class="line"></span><br><span class="line">telnet ip port</span><br></pre></td></tr></table></figure><h4 id="如何上传文件到服务器"><a href="#如何上传文件到服务器" class="headerlink" title="如何上传文件到服务器"></a>如何上传文件到服务器</h4><h5 id="使用ftp"><a href="#使用ftp" class="headerlink" title="使用ftp"></a>使用ftp</h5><p>这里有一个容易搞混的地方就是,linux 里面是不是带有一个ftp 命令,这个是一个命令,而不是一个服务,它相当于ftp客户端,可以上传文件到服务器,所以要想使用ftp传输文件到服务器需要先在服务器中启动一个ftp服务</p><p>安装ftp服务器并且启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装ftp服务器</span></span><br><span class="line">yum install vsftpd -y</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动ftp服务器</span></span><br><span class="line">systemctl start vsftpd</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">记得关闭防火墙,如果不关闭防火墙就需要开启端口</span></span><br></pre></td></tr></table></figure><p>启动后需要注意的是它的配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls  /etc/vsftpd</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ftpusers  user_list  vsftpd.conf  vsftpd_conf_migrate.sh</span></span><br><span class="line">user_list: 里面的用户无法登陆ftp服务器</span><br><span class="line">vsftpd.conf: 里面ftp服务器的相关配置</span><br></pre></td></tr></table></figure><p>推荐一款客户端ftp工具</p><p><a href="https://filezilla-project.org/">https://filezilla-project.org/</a></p><p>其实也可以直接使用windows自带的,直接在资源管理器的路径里面输入 <a href="ftp://192.168.183.128/">ftp://192.168.183.128/</a></p><p>注意点: 使用ftp时,就只能操作当前ftp用户的家目录,其他的目录是操作不了的</p><h5 id="使用scp"><a href="#使用scp" class="headerlink" title="使用scp"></a>使用scp</h5><p>格式:</p><p>scp 参数 源地址 目的地址</p><p>将源地址的东西 放到目的地址上面 ,所以可以实现上传与下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">上传普通文件</span></span><br><span class="line">scp root@192.168.183.128:路径 ./ </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">上传目录文件</span></span><br><span class="line">scp -r root@192.168.183.128:路径 ./</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载相反就可以了</span></span><br></pre></td></tr></table></figure><h4 id="如何下载网上文件"><a href="#如何下载网上文件" class="headerlink" title="如何下载网上文件"></a>如何下载网上文件</h4><h5 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h5><ul><li>-b 后台下载 输出的东西会写到日志文件中去</li><li>-q 就是不输出日志</li><li>-O 就是起别名 wget -O 别名  url</li><li>可以支持多个文件下载 url之间用空格隔开就行</li><li>-i 可以实现批量下载 wget -i test.txt  test.txt里面写上要下载的url路径</li><li>-c 适合下载大文件,如果网路被中断,就会暂停之前的下载,如果我们不使用这个参数就会从头下载,所以这个参数可以继续之前的下载</li></ul><h5 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h5><p>这个命令的功能可以充当一个http客户端,可以发起http请求,所以也可以下载文件</p><ul><li>-O url</li><li></li></ul><h4 id="network服务启动失败"><a href="#network服务启动失败" class="headerlink" title="network服务启动失败"></a>network服务启动失败</h4><p>在CentOS系统上，目前有NetworkManager和network两种网络管理工具。如果两种都配置会引起冲突。由于一般我们都是使用 network 配置静态ip，可能是关机（某种缘故）导致NetWorkManager自动配置，发生了冲突，所以把它禁用掉就好了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop NetworkManager</span><br><span class="line">systemctl stop NetworkManager</span><br></pre></td></tr></table></figure><h4 id="ssh-设置好公钥还是需要密码验证"><a href="#ssh-设置好公钥还是需要密码验证" class="headerlink" title="ssh 设置好公钥还是需要密码验证"></a>ssh 设置好公钥还是需要密码验证</h4><p>这个大概率是权限问题,我们可以通过下面这个查看日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">journalctl --unit=sshd</span><br><span class="line"></span><br><span class="line">Nov 21 10:09:47 localhost.localdomain sshd[2760]: Authentication refused: bad ownership or modes for file /home/git/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>发现权限出了错误,我们只需要更改权限就可以了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br><span class="line">chmod 700 .</span><br><span class="line">chmod 600 authorized_keys</span><br></pre></td></tr></table></figure><h4 id="同一个服务开启多个"><a href="#同一个服务开启多个" class="headerlink" title="同一个服务开启多个"></a>同一个服务开启多个</h4><p>我们有时候可能需要多个一样的服务,下面以ftp服务器为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">复制一份配置文件</span></span><br><span class="line">cp /etc/vsftpd/vsftpd.conf /etc/vsftpd/vsftpd2.conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改端口</span></span><br><span class="line">vim /etc/vsftpd/vsftpd2.conf</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">增加一行</span></span><br><span class="line">listen_port=555</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置启动服务脚本</span></span><br><span class="line">cp /usr/lib/systemd/system/vsftpd.service /usr/lib/systemd/system/vsftpd2.service</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更改配置文件位置</span></span><br><span class="line">vim /usr/lib/systemd/system/vsftpd2.service</span><br><span class="line"> </span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/sbin/vsftpd /etc/vsftpd/vsftpd2.conf  # 改成我们刚刚新增的配置文件</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新载入配置文件</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看我们的服务是否加载进来了</span></span><br><span class="line"> systemctl list-unit-files | grep vsftpd</span><br><span class="line"><span class="meta prompt_"> # </span><span class="language-bash">输出下面这个vsftpd2就代表加载进来了</span></span><br><span class="line">vsftpd.service                                disabled</span><br><span class="line">vsftpd2.service                               disabled</span><br><span class="line">vsftpd@.service                               disabled</span><br><span class="line">vsftpd.target                                 disabled</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看状态</span></span><br><span class="line">systemctl status vsftpd2</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动服务</span></span><br><span class="line">systemctl start vsftpd2</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="关闭交换区"><a href="#关闭交换区" class="headerlink" title="关闭交换区"></a>关闭交换区</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除交换区的内容</span></span><br><span class="line">swapoff -a</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">让交换区启动不挂载</span></span><br><span class="line">vim /etc/fstab</span><br><span class="line"></span><br><span class="line">UUID=053918e3-e0ed-4a26-be89-61424b5d40ab /                       xfs     defaults        0 0</span><br><span class="line">UUID=32920875-4523-4302-a295-1267fd27952d /boot                   xfs     defaults        0 0</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">UUID=9c3b3cd9-6cd2-4b4c-8395-38f081300bd8 swap                    swap    defaults        0 0 <span class="comment"># 注释掉这一行</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="桌面系统开关"><a href="#桌面系统开关" class="headerlink" title="桌面系统开关"></a>桌面系统开关</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭桌面,开启命令模式</span></span><br><span class="line">systemctl set-default multi-user.target</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启桌面</span></span><br><span class="line">systemctl set-default graphical.target</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">记得重启</span></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h4 id="忘记密码了怎么办-centos-7"><a href="#忘记密码了怎么办-centos-7" class="headerlink" title="忘记密码了怎么办(centos 7)"></a>忘记密码了怎么办(centos 7)</h4><p>没忘记root密码 直接passwd修改用户密码</p><p>忘记root密码  采用单用户进入</p><p>方式一</p><p>刚启动系统时 就按 e 键 跳转到启动配置页面 <strong>将 ro 及其后面的这一行的字符全部删掉变成</strong> rw init&#x3D;&#x2F;bin&#x2F;sh crashkernel&#x3D;auto</p><p>然后 <strong>Ctrl+x</strong>  就会进入单用户模式 然后输入passwd 就能更改密码</p><p><img src="/2022/11/24/linux/linux/../img/linuxassets/image-20221205111145547.png" alt="image-20221205111145547"></p><p><img src="/2022/11/24/linux/linux/../img/linuxassets/image-20221205111314908.png" alt="image-20221205111314908"></p><p>方式二</p><p>刚启动系统时 就按 e 键 跳转到启动配置页面 ,然后新增rd.break,ctrl+x然后chroot &#x2F;sysroot 然后 passwd就行了</p><p><img src="/2022/11/24/linux/linux/../img/linuxassets/image-20221205111748610.png" alt="image-20221205111748610"></p><p><img src="/2022/11/24/linux/linux/../img/linuxassets/image-20221205111850903.png" alt="image-20221205111850903"></p><h3 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h3><h4 id="1-SELinux策略"><a href="#1-SELinux策略" class="headerlink" title="1.SELinux策略"></a>1.SELinux策略</h4><p>这是一个安全策略,它默认是开启的,只要任何违反策略的行动都会被禁止,我们对这个策略不了解当然不知道怎么才能访问,怎么就不可以访问,我当时在centos7上,安装了一个nginx,然后把访问根目录放在了root目录下,权限也都开放了,还是403,最后把这个玩意弄成disable就行了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/selinux/config</span><br><span class="line">把SELINUX=enforceing</span><br><span class="line">改成SELINUX=disable</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当然,这样我们就失去了selinux的防护,作为一个爱好linux的人,当然要借此把linux的权限搞清楚</p><h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><p>1.当我们的服务起不来,没有提示信息的时候,一定要去找报错信息,起服务的时候把它能显示信息的参数全部带上,没找到解决办法,就去用systemctl status 去看看有什么提示没</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">TYPE=&quot;Ethernet&quot;</span><br><span class="line">PROXY_METHOD=&quot;none&quot;</span><br><span class="line">BROWSER_ONLY=&quot;no&quot;</span><br><span class="line">BOOTPROTO=&quot;none&quot;</span><br><span class="line">DEFROUTE=&quot;yes&quot;</span><br><span class="line">IPV4_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">IPV6INIT=&quot;yes&quot;</span><br><span class="line">IPV6_AUTOCONF=&quot;yes&quot;</span><br><span class="line">IPV6_DEFROUTE=&quot;yes&quot;</span><br><span class="line">IPV6_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;</span><br><span class="line">NAME=&quot;ens33&quot;</span><br><span class="line">UUID=&quot;5e2fa212-3b9e-49e1-b45d-57232f94c918&quot;</span><br><span class="line">DEVICE=&quot;ens33&quot;</span><br><span class="line">ONBOOT=&quot;yes&quot;</span><br><span class="line">IPADDR=&quot;192.168.100.3&quot;</span><br><span class="line">NETMASK=&quot;255.255.255.0&quot;</span><br><span class="line">GATEWAY=&quot;192.168.100.2&quot;</span><br><span class="line">DNS1=&quot;192.168.100.2&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云模型概述</title>
      <link href="/2022/11/24/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/%E4%BA%91%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0/"/>
      <url>/2022/11/24/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/%E4%BA%91%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不同的人对于云计算的要求是不一样的,有的需要灵活,有的需要方便,因此诞生出了几种云服务模型,我们可以根据自己的需要,选择不同的云计算模型</p><h2 id="IaaS-基础设施即服务"><a href="#IaaS-基础设施即服务" class="headerlink" title="IaaS(基础设施即服务)"></a>IaaS(基础设施即服务)</h2><p>云服务商帮我们管理那些硬件,服务器啊,网络啊,存储啊,不需要我们去操心,如果你不想自己去购买与维护这些硬件,那么Iaas是一个很好的选择,在这个模型下我们仍有很大的工作量要去做,管理操作系统,数据库,应用程序,但是也相对灵活</p><h2 id="PaaS-平台即服务"><a href="#PaaS-平台即服务" class="headerlink" title="PaaS(平台即服务)"></a>PaaS(平台即服务)</h2><p>云服务商,提供了基本的操作系统,数据库,web服务器,中间件这些,我们只要专心的写我们的代码和少量的平台搭建</p><h2 id="SaaS-软件即服务"><a href="#SaaS-软件即服务" class="headerlink" title="SaaS(软件即服务)"></a>SaaS(软件即服务)</h2><p>云服务商给我提供好已经可以开箱即用的应用程序,我们只需要关心怎么去运营就好了</p>]]></content>
      
      
      
        <tags>
            
            <tag> 云 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
